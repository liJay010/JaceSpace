```c++
//198. 打家劫舍
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for (int i = 2; i < nums.size() ; ++i) {
            dp[i] = max(dp[i-1],nums[i] + dp[i-2]);
        }
        return dp[nums.size()-1];
    }
};
```

```c++
//213. 打家劫舍 II

class Solution {
public:
    int rob(vector<int>& nums)
    {
        if(nums.size() == 1)return nums[0];
        vector<int> s(nums.begin()+1,nums.end());
        vector<int> s2(nums.begin(),nums.end()-1);
        return max(getmax(s),getmax(s2));
    }
    int getmax(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for (int i = 2; i < nums.size() ; ++i) {
            dp[i] = max(dp[i-1],nums[i] + dp[i-2]);
        }

        return dp[nums.size()-1];
    }
};

```



```c++
//337. 打家劫舍 III（树）
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```





```c++
//121. 买卖股票的最佳时机
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.size()-1][1];

    }
};

```



```c++
//122. 买卖股票的最佳时机 II
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i]);//区别
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.size()-1][1];

    }
};
```



```c++
//123. 买卖股票的最佳时机 III
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(4,0));
        dp[0][0] = -prices[0]; //第一次持有
        dp[0][1] = 0;//第一次不持有
        dp[0][2] = -prices[0];//第二次不持有
        dp[0][3] = 0;//第二次不持有
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],-prices[i]);//第一次持有
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);//第一次不持有

            dp[i][2] = max(dp[i-1][2],dp[i][1]-prices[i]);//第二次持有
            dp[i][3] = max(dp[i-1][3],dp[i][2]+prices[i]);//第二次不持有

        }
        return dp[prices.size()-1][3];

    }
};

```

```c++
//188. 买卖股票的最佳时机 IV
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2*k,0));
        for (int i = 0; i < 2*k; i+=2) {
            dp[0][i] = -prices[0]; //第i次持有
            dp[0][i+1] = 0;//第i次不持有
        }

        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],-prices[i]);//第一次持有
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);//第一次不持有

            for (int j = 2; j < 2*k; j+=2) {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]-prices[i]);//第j次持有
                dp[i][j+1] = max(dp[i-1][j+1],dp[i][j]+prices[i]);//第j次不持有
            }

        }
        return dp[prices.size()-1][2*k-1];

    }
};
```

```c++
//309. 最佳买卖股票时机含冷冻期
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(4,0));
        dp[0][0] = -prices[0]; //持有状态
        dp[0][1] = 0;//保持可以买入状态
        dp[0][2] = 0;//卖出状态
        dp[0][3] = 0;//冷冻期
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));//持有状态
            dp[i][1] = max(dp[i-1][1],dp[i-1][3]);//保持可以买入状态

            dp[i][2] = dp[i-1][0] + prices[i];//卖出状态
            dp[i][3] = dp[i-1][2];//冷冻期

        }
        return max(dp[prices.size()-1][1], max(dp[prices.size()-1][2],dp[prices.size()-1][3]));

    }
};
```



```c++
//714. 买卖股票的最佳时机含手续费
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        if (prices.size() < 2)return 0;
        vector<vector<int>> dp(prices.size(),vector<int>(2,0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i]);//区别
            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);
        }
        return dp[prices.size()-1][1];

    }
};
```



```c++
//300. 最长递增子序列
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        vector<int> dp(nums.size(),1);
        int result = 1;
        for (int i = 1; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i]>nums[j])
                {
                    dp[i] = max(dp[i],dp[j]+1);
                }
            }
            result = max(result,dp[i]);
        }
        return result;
    }
};
```

```c++
//674. 最长连续递增序列
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        vector<int> dp(nums.size(),1);
        int result = 1;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums[i] > nums[i-1])
            {
                dp[i] = dp[i-1]+1;
            }
            result = max(result,dp[i]);
        }
        return result;
    }
};
```

```c++
//718. 最长重复子数组
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int result =0;
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1,0));
        for (int i = 1; i <= nums1.size(); ++i) {
            for (int j = 1; j <= nums2.size(); ++j) {
                if (nums1[i-1]== nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] +1;
                result = max(result,dp[i][j]);
            }
        }
        return result;
    }
};

```

```c++
//1143. 最长公共子序列
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int result = 0;
        vector<vector<int>> dp(text1.size()+1,vector<int>(text2.size()+1,0));
        for (int i = 1; i <= text1.size(); ++i) {
            for (int j = 1; j <= text2.size(); ++j) {
                if (text1[i-1]==text2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```

```c++
//1035. 不相交的线（思路与上题完全一样，就是求最长公共子序列）
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1,0));
        for (int i = 1; i <=nums1.size() ; ++i) {
            for (int j = 1; j <=nums2.size(); ++j) {
                if (nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
            }
        }
        return dp[nums1.size()][nums2.size()];
    }
};

```

```c++
//53. 最大子数组和
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        int reult = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            dp[i] = max(dp[i-1]+nums[i],nums[i]);
            reult = max(reult,dp[i]);
        }
        return reult;
    }
};
```

```c++
//392. 判断子序列
//解法一，双指针
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int fast = 0 ,slow = 0;
        while (fast < t.size())
        {
            if (s[slow] == t[fast]) slow++;
            fast++;
        }
        return  slow == s.size();
    }
};

//解法二，动态规划
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>>dp(s.size()+1,vector<int>(t.size()+1,0));
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 1; j <= t.size(); ++j) {
                if (s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = dp[i][j-1];
            }
        }
        return dp[s.size()][t.size()] == s.size();
    }
};
```

```c++
//115. 不同的子序列
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>>dp(s.size()+1,vector<uint64_t>(t.size()+1,0));

        for (int i = 0; i < s.size()+1; ++i) {
            dp[i][0] = 1;
        }

        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 1; j <= t.size(); ++j) {
                if (s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[s.size()][t.size()];

    }
};
```

```c++
//583. 两个字符串的删除操作
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>>dp(word1.size()+1,vector<int>(word2.size()+1,0));

        for (int i = 0; i <= word1.size(); ++i) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); ++j) dp[0][j] = j;

        for (int i = 1; i <= word1.size(); ++i) {
            for (int j = 1; j <= word2.size(); ++j) {
                if (word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j]+1,min(dp[i][j-1]+1,dp[i-1][j-1]+2));
            }
        }
        return dp[word1.size()][word2.size()];

    }
};
```

```c++
//72. 编辑距离
class Solution {
public:
    int minDistance(string word1, string word2){
        vector<vector<int>>dp(word1.size()+1,vector<int>(word2.size()+1,0));

        for (int i = 0; i <= word1.size(); ++i) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); ++j) dp[0][j] = j;

        for (int i = 1; i <= word1.size(); ++i) {
            for (int j = 1; j <= word2.size(); ++j) {
                if (word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;
            }
        }
        return dp[word1.size()][word2.size()];

    }
};
```

```c++
//647. 回文子串
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(), false));
        for (int i = s.size()-1; i>=0 ; --i) {
            for (int j = i; j < s.size(); ++j) {
                if (s[i]==s[j])
                {
                    if (j-i <=1)
                    {
                        dp[i][j] = true;
                        result++;
                    }
                    else if(dp[i+1][j-1])
                    {
                        dp[i][j] = true;
                        result++;
                    }
                }
            }
        }
        return result;
    }
};
```

```c++
//516. 最长回文子序列
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int result = 1;
        vector<vector<int>>dp(s.size(),vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); ++i) {
            dp[i][i]=1;
        }
        for (int i = s.size()-1; i>=0 ; --i) {
            for (int j = i+1; j < s.size(); ++j) {
                if (s[i]==s[j])
                {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                    result = max(result, dp[i][j]);
                }
                else
                {
                    dp[i][j] = max(dp[i+1][j],dp[i][j-1]);
                    result=max(result,dp[i][j]);
                }
                }
            }
        return result;
    }
};
```


# 设计模式

转自https://blog.csdn.net/QIANGWEIYUAN/article/details/88792594?spm=1001.2014.3001.5501

## 1.单例模式

### 1.什么是单例模式？

顾名思义，单例模式就是在这个单例类确保**只有一个对象被创建**。也就是说这个类只能实例化一个对象。

特征：1.单例类最多只能有一个实例； 

​			2.单例类必须自己创建自己唯一的实例； 

​			3.单例类必须给所有其他的对象提供这一实例。



### 2.为什么要有单例模式？

首先，单例模式中某一类只能实例化一个对象，然后该类**提供了一个全局都可以访问的实例化静态对象**，以此来应对**程序中某些频繁销毁构建的全局类**

优点：1.内存中该类只实例化了一个对象，减少了内存的消耗；2.避免资源的重复占用

缺点：单例类的话，不能被继承，因为它的**构造函数那些东西都是私有(private)的；**

### 3.应用场景

​		1.假如说我们现在要写一个连接数据库的程序，因为创建数据库链接对象非常消耗资源，如果我们每次都重复操作，创建数据库链接对象，就会非常消耗内存资源 ，我们也可以发现，这个数据库链接是可以复用的，所以我们将对象设计成单例的，这样就可以重复使用这个对象就可以了，可以在很大程度上减少资源的消耗。

​		2.内存池设计pool的时候，保证内存池是只有一个对象

### 4.单例模式的实现：

#### 1.饿汉模式(空间换时间)->线程安全：

**将单例类的唯一对象实例，通过一个静态成员变量来实现，加载进程时即完成创建，无论用或不用该单例对象都一直存在。**

```cpp
class Chairman
{
public:
	void print()
	{
		cout << "对象调用" << endl;
	}
private:
	Chairman()  //私有构造函数
	{
		cout << "创建chairman类" << endl;
	}
 
public:
	static Chairman* singleman;  //类内声明chairman对象指针
};
 
Chairman* Chairman::singleman = new Chairman;  //类外进行初始化
 
int main()
{
	cout << "main函数开始执行" << endl;
	Chairman::singleman->print();
 
	system("pause");
	return 0;
}
```

**上述代码是先创建的chairman，然后才调用的main主函数 ，也就是说在预编译阶段已经将对象构建完成(这也是饿汉模式的特点)**

**但是饿汉模式也会有问题：当这个对象特别大的时候，无论你用不用该对象，在使用程序开始的那一课开始，对象已经存在，会造成巨大的内存浪费。**



#### 2.懒汉模式(时间换空间)

 **第一次用到类实例的时候才会去实例化，在还没使用到类实例的时候，它是不会进行实例化的。(只有在用到该类示例的时候才会进行实例化)。**

```cpp
class Chairman
{
public:
	void print()
	{
		cout << "对象调用" << endl;
	}
	static Chairman* getChairman()
	{
		if (Chairman::singleman == nullptr)
		{
            //加锁
			Chairman::singleman = new Chairman();
		}
		return Chairman::singleman;
	}
private:
	Chairman()  //私有构造函数
	{
		cout << "创建chairman类" << endl;
	}
 
private:
	static Chairman* singleman;
};
 
Chairman* Chairman::singleman = nullptr;
 
int main()
{
	cout << "main主函数开始调用" << endl;
	Chairman* c1 = Chairman::getChairman();
	c1->print();
 
	system("pause");
	return 0;
}
```

 **上述代码运行结果如上，可以看到只有在需要实例化chairman的时候，才回去调用chairman的构造函数。**

**懒汉模式的缺点：在多线程中可能不是线程安全的。**

**以下是线程安全版本：**

```cpp
class Chairman
{
public:
	void print()
	{
		cout << "对象调用" << endl;
	}
	static Chairman* getChairman()
	{
		static Chairman instance; //无需加锁
		return &instance;
	}
private:
	Chairman()  //私有构造函数
	{
		cout << "创建chairman类" << endl;
	}
};
 
 
int main()
{
	cout << "main主函数开始调用" << endl;
	Chairman* c1 = Chairman::getChairman();
	c1->print();
 
	system("pause");
	return 0;
}
```

## 2.工厂模式

### 2.1 简单工厂

  		简单工厂（Simple Factory）不属于标准的OOP设计模式中的一项，在编写大型C++软件的时候，代码里面会出现很多的类，每次创建对象的时候，都需要通过new 类名称的方式来生成对象，这样一来，用户需要记忆很多类的名称，暂且不管记不记得住，这样的设计使得代码很难维护，类名如果做了改变，那么所有使用类名称的地方都需要去修改，耦合性太强，不符合我们软件设计的思想，Simple Factory就是在这样的需求下诞生的。

​		所有对象的创建不再通过new 类名称的方式进行了，而是把对象的创建都封装在了SimpleFactory类的createProduct方法当中，通过传入一个事先设计好的枚举类型，然后返回一个对应的对象，既解耦了对象的创建，还不用再记忆那么多的类名。下面通过代码演示SimpleFactory简单工厂的使用，代码如下：

1. **产品Product基类**

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;
// 产品类型
class Product
{
public:
	Product(string name) :_name(name) {}
	// 模拟产品对象的一个抽象方法
	virtual void show() = 0;
protected:
	string _name;
};


```

**2.具体的产品Product派生类型**

```cpp
// 产品实体类型定义
class ProductA : public Product
{
public:
	ProductA(string name) :Product(name){}
	void show() { cout << "获取了一个ProductA对象:" << _name << endl; }
};
// 产品实体类型定义
class ProductB : public Product
{
public:
	ProductB(string name) :Product(name) {}
	void show() { cout << "获取了一个ProductB对象:" << _name << endl;
	}
};

```

**3.创建描述产品类型的枚举和简单工厂类**

```cpp
// 产类枚举类型定义
enum ProductType
{
	XIAOMI,
	HUAWEI,
};
// 简单工厂类
class SimpleFactory
{
public:
	// 通过传入的枚举类型，创建相应的对象，返回所有对象的基类指针
	Product* createProduct(ProductType type)
	{
		switch (type)
		{
		case XIAOMI:
			return new ProductA("小米手机");
		case HUAWEI:
			return new ProductB("华为手机");
		}
	}
};

```

**4.添加测试简单工厂的main函数**

```cpp
int main()
{
	// 创建简单工厂实例
	SimpleFactory sf;

	// 使用智能指针自动释放堆内存
	unique_ptr<Product> p1(sf.createProduct(XIAOMI));
	unique_ptr<Product> p2(sf.createProduct(HUAWEI));

	p1->show();
	p2->show();

	return 0;
}

```

​		SimpleFactory简单工厂解决了一些问题，但是它本身也有很明显的问题，就是把所有对象的创建都封装在了一个SimpleFactory类的createProduct函数中，根据传入的参数，选择产生不同的对象，很明显，createProduct这个函数做不到“开-闭”原则，即对原有代码修改关闭，对功能扩展开放，这个函数随着新对象的添加，或者原有对象的删除，都会导致该函数的代码修改，而且有可能影响原来的功能，所以这样的设计不能算完美。

那么接下来看看工厂方法（Factory Method）模式是否能够解决上面简单工厂的问题。

### 2.2 工厂方法

​		Factory Method工厂方法是标准的OOP设计模式之一，主要解决了上面使用简单工厂遇到的问题。**工厂方法为每一种产品提供相应的实例工厂进行对象创建**，更符合实际的面向对象设计，比如说不同厂家的汽车，肯定都有自己的汽车生产工厂，BMW和Audi两种汽车都有自己的工厂在生产。

​		工厂方法模式中，**通过产生具体的工厂创建具体的产品，做到了在扩充新产品时，能够达到软件设计的“开-闭”原则**，因为生产新的Product，只需要提供新的Factory类就可以了，不用修改原来的代码。Factory Method工厂方法代码示例如下：

​		

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

// 产品类型
class Product
{
public:
	Product(string name) :_name(name) {}
	// 模拟产品对象的一个抽象方法
	virtual void show() = 0;
protected:
	string _name;
};
// 产品实体类型定义
class ProductA : public Product
{
public:
	ProductA(string name) :Product(name){}
	void show() { cout << "获取了一个使用老外高通芯片的手机:" << _name << endl; }
};
// 产品实体类型定义
class ProductB : public Product
{
public:
	ProductB(string name) :Product(name) {}
	void show() { cout << "获取了一个使用自研麒麟芯片的手机:" << _name << endl;
	}
};

// 工厂基类
class Factory
{
public:
	virtual Product* createProduct() = 0;
};

// 生产小米手机的工厂
class XiaomiFactory : public Factory
{
public:
	Product* createProduct()
	{
		// 小米工厂肯定生产小米手机
		return new ProductA("小米手机");
	}
};
// 生产华为手机的工厂
class HuaweiFactory : public Factory
{
public:
	Product* createProduct()
	{
		// 华为工厂肯定生产华为手机
		return new ProductB("华为手机");
	}
};

int main()
{
	// 使用智能指针自动释放堆内存
	// 创建具体的工厂
	unique_ptr<Factory> f1(new XiaomiFactory);
	unique_ptr<Factory> f2(new HuaweiFactory);

	// 通过工厂方法创建产品
	unique_ptr<Product> p1(f1->createProduct());
	unique_ptr<Product> p2(f2->createProduct());

	p1->show();
	p2->show();

	return 0;
}

```

​		仔细理解上面的工厂方法模式，会发现一个问题，就是每一个实例工厂负责生产一个实例产品，也就是一个产品对应一个工厂，一个工厂对应一个产品，那么小米不仅仅生产手机，还生产耳机，智能手环，智能插座等等相关的小米产品簇，不可能给这每一个产品都创建一个工厂类，那样的话代码中的类就太多了，不好维护，而且也不符合实际情况。

​		实际上小米或者华为的工厂里面，有相关联的产品簇都是在一个工厂完成创建的；BMW或者Audi汽车制造工厂除了生产汽车，生产线上也有可能生产轮胎，或者其它的汽车附属产品。

​		所以对于包含产品簇这么一类实体关系的设计，就需要使用Abstract Factory抽象工厂了，你也可以把上面的工厂方法看作只生产一种产品的抽象工厂，本质是相同的。

### 2.3 抽象工厂

ProductA和ProductB就是一个产品簇，通过下面抽象工厂的代码示例和上面的类设计图，仔细理解抽象工厂设计模式的意义，代码如下：

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

// 产品簇手机类型
class ProductA
{
public:
	ProductA(string name) :_name(name) {}
	// 模拟产品对象的一个抽象方法
	virtual void show() = 0;
protected:
	string _name;
};
// 产品实体类型定义
class XiaomiPhone : public ProductA
{
public:
	XiaomiPhone(string name) :ProductA(name){}
	void show() { cout << "获取了一个小米手机:" << _name << endl; }
};
// 产品实体类型定义
class HuaweiPhone : public ProductA
{
public:
	HuaweiPhone(string name) :ProductA(name) {}
	void show() { cout << "获取了一个华为手机:" << _name << endl;
	}
};

// 产品簇智能手环类型
class ProductB
{
public:
	ProductB(string name) :_name(name) {}
	// 模拟产品对象的一个抽象方法
	virtual void show() = 0;
protected:
	string _name;
};
// 产品实体类型定义
class XiaomiCircle : public ProductB
{
public:
	XiaomiCircle(string name) :ProductB(name) {}
	void show() { cout << "获取了一个小米智能手环设备:" << _name << endl; }
};
// 产品实体类型定义
class HuaweiCircle : public ProductB
{
public:
	HuaweiCircle(string name) :ProductB(name) {}
	void show() {
		cout << "获取了一个华为智能手环设备:" << _name << endl;
	}
};

// 抽象工厂，创建通过一个产品簇的设备产品
class AbstractFactory
{
public:
	// 工厂里面创建手机的纯虚函数接口
	virtual ProductA* createPhone() = 0;
	// 工厂里面创建智能手环的纯虚函数接口
	virtual ProductB* createSmartCircle() = 0;
};

// 生产小米产品簇的工厂
class XiaomiFactory : public AbstractFactory
{
public:
	ProductA* createPhone()
	{
		// 小米工厂肯定生产小米手机
		return new XiaomiPhone("小米x9");
	}
	ProductB* createSmartCircle()
	{
		// 小米工厂肯定生产小米智能手环
		return new XiaomiCircle("小米智能手环2代时尚版");
	}
};
// 生产华为产品簇的工厂
class HuaweiFactory : public AbstractFactory
{
public:
	ProductA* createPhone()
	{
		// 华为工厂肯定生产华为手机
		return new HuaweiPhone("华为荣耀7x");
	}
	ProductB* createSmartCircle()
	{
		// 华为工厂肯定生产华为智能手环
		return new HuaweiCircle("华为智能手环B3青春版");
	}
};

int main()
{
	// 使用智能指针自动释放堆内存
	// 创建具体的工厂
	unique_ptr<AbstractFactory> f1(new XiaomiFactory);
	unique_ptr<AbstractFactory> f2(new HuaweiFactory);

	// 通过工厂方法创建手机产品
	unique_ptr<ProductA> p1(f1->createPhone());
	unique_ptr<ProductA> p2(f2->createPhone());
	p1->show();
	p2->show();

	// 通过工厂方法创建智能手环产品
	unique_ptr<ProductB> p3(f1->createSmartCircle());
	unique_ptr<ProductB> p4(f2->createSmartCircle());
	p3->show();
	p4->show();

	return 0;
}

```

可以看到，抽象工厂模式把一个产品簇的产品放在一个工厂类中去创建，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。**根据上面的内容描述，仔细思考简单工厂，工厂方法和抽象工厂的区别联系**。

## 3.代理模式

​		代理模式是一种结构型的软件设计模式，在不改变原代码前提下，提供一个代理，**以控制对原对象的访问**。

**代理模式的优点：**

职责清晰。真实对象专注于自身业务逻辑，不用考虑其他非本职内容，交给代理完成。
高拓展性。真实对象的改变不影响代理。
解耦。将客户端与真实对象分离，降低系统耦合度。
提高性能。虚拟代理可以减少系统资源的消耗。
高安全性和稳定性。代理能很好地控制访问，提高程序安全。
**代理模式的缺点：**

增加系统复杂度。代理的职责往往较冗杂。
请求速度降低。客户端与真实对象中加入代理，一定程度上会降低整个系统流程的运行效率。

 场景描述：游戏往往有自己的代理商，想要玩魔兽，需要和其代理进行沟通，在进行充值后，正常游戏。

```cpp
//Game.h
/****************************************************/
#pragma once
 
#include <iostream>
using namespace std;
 
// 抽象游戏类
class Game 
{
public:
	// 游戏加载
	virtual void load() = 0;
 
	// 游戏退出
	virtual void exit() = 0;
};
 
// 真实游戏类-魔兽世界
class WOW : public Game 
{
public:
	// 游戏加载
	virtual void load() {
		cout << "魔兽世界加载。" << endl;
	}
 
	// 游戏退出
	virtual void exit() {
		cout << "魔兽世界退出。" << endl;
	}
};
 
// 代理类-魔兽代理
class ProxyWOW : public Game 
{
public:
	// 构造函数
	ProxyWOW() {
		m_wow = new WOW();
	}
 
	// 析构函数
	virtual ~ProxyWOW() {
		if (m_wow != nullptr) {
			delete m_wow;
			m_wow = nullptr;
		}
	}
 
	// 充值时间
	void recharge(int money) {
		m_time += money / 100;
		cout << "充值：" << money << endl;
		cout << "获得时长：" << m_time << endl;
	}
 
	// 游戏加载
	virtual void load() {
		cout << "代理启动。" << endl;
		if (m_time > 0) {
			m_wow->load();
			cout << "游戏时长1小时。" << endl;
			m_time -= 1;
			cout << "剩余时长：" << m_time << endl;
			flag = true;
		}
		else {
			cout << "剩余游戏时长不足，请充值。" << endl;
			flag = false;
		}
	}
 
	// 游戏退出
	virtual void exit() {
		if (flag) {
			m_wow->exit();
			flag = false;
		}
		cout << "代理关闭。" << endl;
	}
 
private:
	bool flag = false;
	int m_time = 0;
	WOW* m_wow;
};
 
```

## 4.观察者模式



## 5.装饰器模式



## 6.适配器模式
# Linux服务器



# 1.什么是gcc

**gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。**

最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言。



# 2.gcc工作流程

- 预处理（--E）
  - 宏替换
  - 头文件展开
  - 去掉注释
  - .c文件变成了.i文件（本质上还是.c文件，只不过#include中的程序给链接进去）
- 编译（--S）
  - gcc调用不同语言的编译器
  - .i文件编程.s（汇编文件）
  - 生成汇编文件

- 汇编（-c）
  - .s文件转化成.o文件
  - 翻译成机器语言指令
  - 二进制文件
- 链接
  - .o文件变成可执行文件，一般不加后缀

> ![img](img\202201241320667.jpeg)
>
> **预处理**实际上是将头文件、宏进行展开。
>
> **编译阶段**gcc调用不同语言的编译器。gcc实际上是个工具链，在编译程序的过程中调用不同的工具。
>
> **汇编阶段**gcc调用汇编器进行汇编。汇编语言是一种低级语言，在不同的设备中对应着不同的机器语言指令，一种汇编语言专用于某种计算机体系结构，可移植性比较差。通过相应的汇编程序可以将汇编语言转换成可执行的机器代码这一过程叫做汇编过程。汇编器生成的是可重定位的目标文件，在源程序中地址是从0开始的，这是一个相对地址，而程序真正在内存中运行时的地址肯定不是从0开始的，而且在编写源代码的时候也不能知道程序的绝对地址，所以**重定位**能够将源代码的代码、变量等定位为内存具体地址。
>
> **链接过程**会将程序所需要的目标文件进行链接成可执行文件。



# 3.gcc常用参数

- -v/--version：查看gcc的版本
- -I：编译的时候指定头文件路径，不然头文件找不到
- -c：将汇编文件转换成二进制文件，得到.o文件
- -g：gdb调试的时候需要加
- -D：编译的时候指定一个宏（调试代码的时候需要使用例如printf函数，但是这种函数太多了对程序性能有影响，因此如果没有宏，则#ifdefine的内容不起作用）
- -wall：添加警告信息
- -On：-O是优化代码，n是优化级别：1，2，3



# 4.静态库和动态库

![clip_image002[4]](img\16201602-9c6047fe25ac46659d0a5ab2945552ce.png)

1. 什么是库？

   - 库是写好的现有的，成熟的，可以复用的代码。
   - 现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。			

   - 库是二进制文件，.o文件
   - 将源代码变成二进制的源代码
   - 主要起到加密的作用，为了防止泄露

2. 静态库的制作

   - 原材料：源代码（.c或.cpp文件）

   - 将.c文件生成.o文件（ex：g++ a.c -c）

   - 将.o文件打包
     - ar rcs  静态库名称   原材料(ex: ar rcs libtest.a  a.0)

   - 态库的使用

   <img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210608145829.png" alt="image-20210509140337810" style="zoom: 50%;" align="left" />

3. 动态库的制作(so代表动态库)
   - 命名规则：libxxx.so
   - 制作步骤
     - 将源文件生产.o文件（gcc a.c -c -fpic）
     - 打包（gcc -shared a.o -o libxxx.so）
   - 动态库的使用
     - 跟静态库一样 
   - 动态库无法加载的问题
     - 使用环境变量（临时设置和全局设置）




# 5.gdb相关问题

- gdb 不能显示代码（No symbol table is loaded. Use the "file" command）
  - 要是用-g 比如： g++ map_test.cpp -g -o mao



# 6.linux权限相关问题

对任意一个文件使用ls -l命令，如下图所示：

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210608145838.png" alt="image-20210512102626440" style="float: left;" />

**任意取一行，如：drwxr-xr-x  2 root root 4096 2009-01-14 17:34 bin**

**用序列表示为：0123456789**

- 第一列

  - d：代表目录
  - -：代表文件
  - l：代表链接，如同windows的快捷方式

- 第一到九列

  - r：可读
  - w：可写
  - x：可执行文件
  - 0：代表文件类型
  - 123：表示文件所有者的权限
  - 456：表示同组用户的权限
  - 789：表示其他用户的权限

- 权限的数字表示

  - 读取的权限等于4，用r表示
  - 写入的权限等于2，用w表示
  - 执行的权限等于1，用x表示

- 改变文件权限命令

  > chmod 权限数字（如777） filename

- 改变目录下所有的文件的权限命令

  > chmod -R 权限数字（如777） 目录(如/home)



# 7.套接字类型

下面是创建套接字所用的socket所用的函数

```
#include<sys/socket.h>
int socket(int domain,int type,int protocol);
```

- **协议簇（Protocol Family）（int domain）**

  > 套接字有许多不同的通信协议分类，由socket函数第一个参数进行传递。其中最重要的是PF_INET（IPv4互联网协议族）

- **套接字类型（Type）（int type）**

  > socket函数的第二个参数决定套接字数据传输的方式。
  >
  > 协议族并不能决定数据传输方式，因为一个协议族也有很多数据传输方式

  - 面向连接的套接字（SOCK_STREAM）

     **面向连接的套接字类似于传送带**

    有如下特点

    1. 传输的过程中数据不会丢失
  2. 按需传送数据
    3. 传输数据不存在数据边界问题
    4. 两端套接字必须一一对应
  
    > 收发的套接字内部有缓冲，就是有字节数组。因此通过套接字传输的数据将保存在数组，因此数据可以填满缓冲一次被读取，也可以分段被读取，不存在数据边界问题。当缓冲区占满后，套接字无法接受数据，停止传输。所以不存在数据丢失问题

  - 面向消息的套接字（SOCK_DGRAM）

    **面向消息的套接字类似于快递**

    有如下特点

    1. 强调快速传送而非顺序传送
    2. 传输的数据可能丢失也可能损坏
    3. 传输的数据有边界
    4. 限制每次传输的数据大小
  
- **协议信息（int protocol）**

  > 由于socket函数前两个参数的存在，大部分情况可以向第三个参数传递0。但若同一个协议族中存在多个数据传输方式相同的协议，即数据传输方式相同，协议不同，需要第三个参数制定具体协议

  ```c++
  //IPv4中面向连接的套接字
  int tcp_socket=(PF_INET,SOCK_STREAM,IPPROTO_TCP)
  //IPv4中面向消息的套接字
  int tcp_socket=(PF_INET,SOCK_STREAM,IPPROTO_UDP)
  ```

  

# 8.实现基于TCP/IP的客户端服务端

- **TCP服务端默认函数调用顺序**

  1. socket()   创建套接字 
  2. bind()       分配套接字地址
  3. listen()      等待连接请求状态
  4. accpet()       允许连接
  5. read()/write()   交换数据
  6. close()         断开连接

- **TCP客户端默认函数调用顺序**

  1. socket()      创建套接字

  2. connect()    请求连接

  3. read()/write()    交换数据

  4. close()         断开连接

      >实现服务器端重要/必经过程就是给套接字分配IP和端口号（bind），但是客户端实现过程并未出现套接字的分配，而是创建套接字后立即调用了connect函数，为什么？
      >
      >答：客户端其实是分配了IP和端口号的。在调用connect的时候分配的（何时），在操作系统内核中进行分配（何地），IP用的是主机的IP，端口号随机分配（何种方式）

- **注意事项**

  - 服务器端创建套接字后连续调用bind、listen函数进入等待状态，客户端通过connect函数发起连接请求
  - 客户端只能等到服务端调用listen后才能调用connect函数
  - 客户端调用connect函数前，服务器可能率先调用accept函数，然后服务端进入阻塞状态，直到客户端调用connect为止
  
- **TCP套接字中的I/O缓冲**

  > write函数调用后并不是立刻传送数据，read函数调用后也不是马上接收数据。而是将这些数据移到输入和输出缓冲中

  如下图所示：

  ![img](img\20210615153016.png)

  I/O缓冲有以下特点：

  1. I/O缓冲在每个TCP套接字中单独存在
  2. I/O缓冲在创建套接字时自动生成
  3. 即使关闭套接字也会继续传递输出缓冲中遗留的数据
  4. 关闭套接字将丢失输入缓冲中的数据

- **套接字的断开**

  > close()函数表示完全断开套接字链接，并且不能收发任何数据。很显然这样做是不好的，若A主机断开连接后，完全无法调用接收数据和发送数据相关函数，这会导致B向A发送数据，A必须接受的数据也被销毁

  套接字中会生成两个I/O流，如下图：

![TCP/IP网络编程》第7 章优雅的断开套接字的连接笔记_riba2534的博客-CSDN博客](img\20210616133503.png)

​		一旦两台主机间建立了套接字链接，每个主机就会拥有单独的输入流和输出流



# 9.Linux操作系统中断

- **中断概念**

  > 中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。这样的中断机制极大的提高了CPU运行效率。

  根据CSAPP中所描述，中断是异常的一种类别。（p504）什么是异常？比如说在处理器中，依次执行对应的指令流程，这样的控制转移序列叫做控制流。但是系统会出现一些变化，系统必须对这种变化做出反应，而且这种变化是随机的，也不一定跟执行当前的程序关联，比若说子进程终止时父进程必须得到通知，硬盘定时器定期产生一个信号。这种叫做**控制流发生突变**，这些突变成为**异常控制流**。计算机的各个层次都会发生异常。(p502)

  异常可以分为：中断、陷阱、故障、终止

  | 类别 |       原因        | 同步/异步 |       返回行为       |
  | :--: | :---------------: | :-------: | :------------------: |
  | 中断 | 来自I/O设备的信号 |   异步    | 总是返回到下一条指令 |
  | 陷阱 |    有意的异常     |   同步    | 总是返回到下一条指令 |
  | 故障 | 潜在可恢复的错误  |   同步    |  可能返回到当前指令  |
  | 终止 |  不可恢复的错误   |   同步    |       不会返回       |
  
  
  
- **硬中断**

  硬中断是我们通常所说的中断的概念。硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。内核中维护了一个IDT（中断描述符表），表中是中断处理函数的地址和一些其他的控制位。0-31号中断号位系统为预定义的中断和异常保留的，用户不得使用，所以硬件中断号从32开始分发。每当CPU接收到一个中断或者异常信号，CPU首先要做的决定是否响应这个中断（具体由中断控制器根据中断优先级决定是否给CPU发送中断信号），如果决定响应，就终止当前运行进程的运行，根据IDTR寄存器获取中断描述符表基地址，然后根据中断号定位具体的中断描述符。

- **软中断**	

  软中断是由当前正在运行的进程所产生的。 软中断并不会直接中断CPU。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。

  > 中断在本质上是软件或者硬件发生了某种情形而通知处理器的行为，处理器进而停止正在运行的指令流，去转去执行预定义的中断处理程序。软件中断也就是通知内核的机制的泛化名称，目的是促使系统切换到内核态去执行异常处理程序。这里的异常处理程序其实就是一种系统调用，软件中断可以当做一种异常。总之，软件中断是当前进程切换到系统调用的过程。



# 10.系统调用知识点

## 用户态和内核态

用户态（User Mode）和内核态（Kernel Mode）是操作系统中的两种不同的运行级别。当一个程序在运行时，它可以在用户态中执行或者在内核态中执行。

1. 用户态：在用户态运行的程序只能访问有限的计算机资源并受到限制。在用户态，程序运行在应用程序的上下文中，它们不能直接访问操作系统的核心功能。用户态程序可以执行一般的计算任务和用户自定义的操作。用户态程序通常不能直接操作硬件设备，这是为了确保操作系统的稳定性和安全性。
2. 内核态：内核态是操作系统的最高特权级别。当操作系统内核在执行时，它运行在内核态。在内核态，操作系统拥有对计算机的完全访问权限，并可以执行特权指令和访问所有硬件设备。内核态提供了操作系统核心功能的访问，如设备驱动程序、内存管理、进程调度等等。只有当需要执行特权操作时，程序才能切换到内核态。

用户态和内核态之间的切换是由操作系统内核控制的，这种切换称为上下文切换。当一个程序需要执行一些需要特权访问或涉及操作系统的功能时，它需要从用户态切换到内核态。常见的情况包括系统调用、中断处理和异常处理等。

总结起来，用户态和内核态是操作系统中的两种运行级别，用户态中的程序受到限制并不能直接访问核心功能和硬件资源，而内核态拥有完全的访问权限和控制权。操作系统通过上下文切换来管理这两种运行态之间的切换。

## 系统调用过程

用户空间的程序无法直接执行内核代码，它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统安全就会失去控制。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序来执行该系统调用了。

通知内核的机制是靠软件中断实现的。首先，用户程序为系统调用设置参数。其中一个参数是系统调用编号。参数设置完成后，程序执行“系统调用”指令。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并跳转到一个新的地址，并开始执行那里的异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。它与硬件体系结构紧密相关。

> **系统调用的过程：**首先将API函数参数压到栈上，然后将函数内调用系统调用的代码放入寄存器，通过陷入中断，进入内核将控制权交给操作系统，操作系统获得控制后，将系统调用代码拿出来，跟操作系统一直维护的一张系统调用表做比较，已找到该系统调用程序体的内存地址，接着访问该地址，执行系统调用。执行完毕后，返回用户程序

## 系统调用和函数调用区别	

**库函数调用**

函数调用主要通过压栈出栈的操作，面向应用开发。库函数顾名思义是把函数放到库里。是把一些常用到的函数编完放到一个文件里，供别人用。别人用的时候把它所在的文件名用include加到里面就可以了。一般是指编译器提供的可在c源程序中调用的函数。可分为两类，一类是c语言标准规定的库函数，一类是编译器特定的库函数。(由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)

**系统调用**

系统调用就是用户在程序中调用操作系统所提供的一个子功能，也就是系统API，系统调用可以被看做特殊的公共子程序。通俗的讲是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

------



# 11.对事件的两种处理方式

## reactor

如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。要这么解决这个问题呢？我们可以使用「资源复用」的方式。也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务？

当一个连接对应一个线程时，线程一般采用「read -> 业务处理 -> send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 `read` 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 `read` 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。要解决这一个问题，最简单的方式就是将 socket 改成非阻塞，然后线程不断地轮询调用 `read` 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。

有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用。线程池复用+IO复用就形成了reactor模式。

**Reactor的定义：**是一种接收多个输入事件的服务器事件驱动处理模式。服务器端通过IO多路复用来处理这些输入事件，并将这些事件同步分派给对应的处理线程。其实reactor模式也叫做Dispatcher 模式，本质上就是将收到的事件进行分发处理。Reactor模式中有两个关键的组成：①主反应堆reactor在一个单独的线程中运行，负责监听和分发事件，将接收到的事件分为监听socket和连接socket，连接socket放入任务队列让线程池线程去抢占式调度。②Handlers或Accepter，处理任务队列中具体的逻辑或者建立连接socket。

根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：

1. 单 Reactor 单线程；
2. 单 Reactor 多线程；
3. 主从 Reactor 多线程。

接下来一一介绍：

- **单 Reactor 单线程**

  顾名思义，一个主反应堆reactor，一个accepter或者handler来处理接收的事件。

  <img src="img\单Reactor单进程.png" alt="img" style="zoom:50%;float:left" />

  **优点：**模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。

  **缺点：**性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。
  可靠性问题，线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。

  **使用场景：**客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。

- **单 Reactor 多线程**

  一个主反应堆reactor和一个线程池，线程池用来处理分发的事件

  <img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/操作系统/Reactor/单Reactor多线程.png" alt="img" style="zoom:46%;float:left" />

  **优点：**可以充分利用多核 CPU 的处理能力。

  **缺点：**多线程数据共享和访问比较复杂；Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈。

- **主从 Reactor 多线程**

  就是游双书里面的半同步/半反应堆模型，给这个归到了代码逻辑层面。

  <img src="img\202203290943547.png" style="zoom:45%;float:left" />

  主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。

  主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。

  **优点：**父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。
  父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。
  这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。

## preactor

在 Reactor 模式中，Reactor 等待某个事件或者可应用或者操作的状态发生（比如文件描述符可读写，或者是 Socket 可读写）。
然后把这个事件传给事先注册的 Handler（事件处理函数或者回调函数），由后者来做实际的读写操作。
其中的读写操作都需要应用程序同步操作，所以 Reactor 是非阻塞同步网络模型。
如果把 I/O 操作改为异步，即交给操作系统来完成就能进一步提升性能，这就是异步网络模型 Proactor。

preactor模型如下图所示：

<img src="img\202203290949372.png" alt="img" style="zoom:50%;float:left" />

工作流程如下：

1. Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过
   Asynchronous Operation Processor 注册到内核；
2. Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；
3. Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor；
4. Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；
5. Handler 完成业务处理；

理论上 Proactor 比 Reactor 效率更高，异步 I/O 更加充分发挥 DMA(Direct Memory Access，直接内存存取)的优势。
但是Proactor有如下缺点：

1. 编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以 Debug；
2. 内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比 Reactor 模式，在 Socket 已经准备好读或写前，是不要求开辟缓存的；
3. 操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux 2.6 才引入，目前异步 I/O 还不完善。
4. Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；

> 可惜的是，在 Linux 下的异步 I/O 是不完善的，
> `aio` 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。
>
> 而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 `IOCP`，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。



# 12.文件(不带缓存的)I/O和标准(带缓存的)I/O

​	**首先要明确一个问题：有无缓存是相对于用户层面来说的，而不是系统内核层面。在系统内核层面，一直都存在有“内核高速缓存”**

- 不带缓存的概念

  > 所谓不带缓存，并不是指内核不提供缓存，而是在用户进程层次没有提供缓存。不带缓存的I/O只存在系统调用(write和read函数)，不是函数库的调用。**系统内核对磁盘的读写都会提供一个块缓冲（在有些地方也被称为内核高速缓存）**，当用write函数对其写数据时，直接调用系统调用，将数据写入到块缓存进行排队，当块缓存达到一定的量时，才会把数据写入磁盘。因此所谓的不带缓存的I/O是指用户进程层面不提供缓存功能（但内核还是提供缓冲的）。
  >
  > 文件I/O以文件标识符（整型）作为文件唯一性的判断依据。这种操作与系统有关，移植有一定的问题。

- 带缓存的概念

  >  与之相对的就是带缓存I/O。而带缓存的是在不带缓存的基础之上封装了一层，在用户进程层次维护了一个输入输出缓冲区，使之能跨OS，成为ASCI标准，称为标准IO库。其实就是在用户层再建立一个缓存区，这个缓存区的分配和优化长度等细节都是标准IO库代你处理好了，不用去操心。第一次调用带缓存的文件操作函数时标准库会自动分配内存并且读出一段固定大小的内容存储在缓存中。所以以后每次的读写操作并不是针对硬盘上的文件直接进行的，而是针对内存中的缓存的。
  >
  >  不带缓存的文件操作通常都是系统提供的系统调用， 更加低级，直接从硬盘中读取和写入文件，由于IO瓶颈的原因，速度并不如意，而且原子操作需要程序员自己保证，但使用得当的话效率并不差。另外标准库中的带缓存文件IO 是调用系统提供的不带缓存IO实现的。

  - 因此，标准I/O函数有两个优点：

    ​	1. 具有良好的移植性

    ​	2. 利用用户层提供的缓存区（流缓冲）提高性能

  - 标准I/O函数缺点

    1. 不容易进行双向通信
    2. 有时可能频繁调用fflush函数
    3. 需要以FILE结构体指针的形式返回文件描述符

- 举例说明

  > **带缓冲的I/O在往磁盘写入相同的数据量时，会比不带缓冲的I/O调用系统调用的次数要少。**比如内核缓冲存储器长度为100字节，在进行写操作时每次写入10个字节，则你需要调用10次write函数才能把内核缓冲区写满。但是要注意此时数据还在缓冲区，不在磁盘中，缓冲区满时才进行实际的I/O操作，把数据写入到磁盘，这样调用了太多次系统调用，显得效率很低。但是若调用标准I/O函数，假设用户层缓冲区为50字节（称为流缓存），则用fwrite将数据写入到流缓存，等到流缓存区存满之后再进入内核缓存区，在调用write函数将数据写入到内核缓冲区中，若内核缓冲区满或执行fflush操作，那么内核缓冲区的数据会写入到磁盘中

  - 无缓存IO操作数据流向路径：**数据——内核缓存区——磁盘**
  - 标准IO操作数据流向路径：**数据——流缓存区——内核缓存区——磁盘**

- apue三种io的总结

  在apue中有三种io类型，如下：

  1. 文件I/O（不带缓冲的I/O）：open、read、write、lseek、close
  2. 标准I/O（带缓冲的I/O）：标准I/O库由ISO C标准说明
  3. 高级I/O：非阻塞I/O、I/O多路转接、异步I/O、readv和writev



# 13.阻塞非阻塞，同步异步的区别

[参考](https://blog.51cto.com/yaocoder/1308899)

[参考2，这个比较符合我的想法](https://blog.csdn.net/historyasamirror/article/details/5778378)

进程通讯层面，阻塞就是同步，非阻塞就是异步，一个意思

IO层面，就不一样。要记住，IO操作只有两个阶段：

1. 数据准备阶段    
2. 内核缓冲区（内核空间）复制数据到用户进程缓冲区（用户空间）阶段

对于数据准备阶段，是阻塞和非阻塞的层面。对于数据从内核转移到用户空间，就是同步异步阶段。

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/202203221656865.png" alt="img" style="zoom: 80%; float: left;" />

阻塞和非阻塞的区别在于内核数据还没准备好时，用户进程在一阶段数据准备时是否会阻塞；

同步IO与异步IO的区别在于当数据从内核`copy`到用户空间时，用户进程是否会阻参与第二阶段的数据读写，是由用程序完成还是由内核完成。



# 14.对于套接字socket的理解

这里我类比一下插座和套接字，为什么这样类比呢？因为套接字的中文有插座的含义....

电器如何才能供电？电器需要连接上电网。如何连接到电网？需要把电器插销插到插座上，通过插座连接到电网，这样电器就有电可以工作

计算机如何收发消息？计算机需要连接上互联网。如何连接互联网？硬件层面我们可以拉一根网线，软件层面需要套接字。通过套接字连接到互联网，进而可以和互利网上的所有主机进行通信。

<img src="https://cdn.jsdelivr.net/gh/luogou/cloudimg/data/20210824151934.png" alt="img" style="zoom:67%;" />

***socket* 其实就是操作系统提供给程序员操作「网络协议栈」的接口，说人话就是，你能通过*socket* 的接口，来控制协议找工作，从而实现网络通信**



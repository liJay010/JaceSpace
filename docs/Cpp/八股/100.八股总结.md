# 面试问题总结

## 一.CPP篇

1. **const关键字？**

   **const 修饰基本类型数据类型：**表示类型为常量不可以修改

   加在**函数前**表示返回值为const，加在**函数后面**表示函数里的值不可修改（在成员函数中）。

   **const 修饰指针变量和引⽤变量：**const在\*左侧为底层cost，表示指向那个变量不可改变。const在*右侧为顶层cost，表示指针本身为不可变。

   **const 成员变量**：表示对象中不可变，对于整个类可变。

   **const 修饰类对象**：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

   

2. **C++的内存结构**，**什么情况下使用堆区什么情况使用栈区**
   由高到底地址分别为：
   **栈区：**由编译器管理分配和回收，效率很高，但是分配的内存容量有限。存放局部变量和函数参数。
   **堆区:** 由程序员管理，需要⼿动分配和回收，空间较大但可能会出现内存泄漏和空闲碎⽚的情况。动态内存分配的时候使用。
   **全局/静态存储区:**存储初始化和未初始化的**全局变量**和**静态变量**。
   **常量区:**存储常量，⼀般不允许修改。
   **代码区:** 存放程序的⼆进制代码。

   

3. **动态链接库静态链接库特点、区别**

   **静态链接：**链接器在链接时将库的内容加入到可执行程序中。运行环境的依赖性较小，但是**生成的程序比较大**，**库函数有了更新，必须重新编译应用程序**

   **动态链接：**连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。

   - 在需要的时候才会调入对应的资源函数

   - 简化程序的升级；有着较小的程序体积

   - 实现进程之间的资源共享（避免重复拷贝）

   - 依赖动态库，不能独立运行

   - 动态库依赖版本问题严重

     

4. **static关键字作用**

   在**全局变量**或者**普通函数**上改变作用域为当前文件可以访问。

   在**局部变量**上，改变局部变量生命周期为程序结束，并且只初始化一次。

   在类中**成员变量**上，所有对象共享同一份变量，可以通过类名访问，初始化必须在类外。

   **static成员函数**，可以通过类名访问，不含this指针，只能操作对应的static成员变量。

   

5. **面向对象三大特性**

   **封装：**将（成员变量）和（成员函数）打包在一个单元中，形成一个类。封装提供了对类内部实现的隐藏，使得代码更加模块化和可维护。

   **继承：**一个类（子类或派生类）可以使用另一个类（父类或基类）的属性和行为，并且可以扩展或修改它们。

   **多态：**多态是指同一个接口可以被用于不同的数据类型。父类指针可以指向不同的子类对象。
   多态分为（静态多态）和（动态多态）。

   静态多态通过**函数重载**和**运算符重**载来实现的，允许一个接口有多个不同的实现，这称为静态绑定。

   动态多态是通过**虚函数**和**抽象类**实现的。在运行时，同一个函数调用可能会**根据对象的实际类型**执行不同的代码，这称为动态绑定。
   

6. **虚函数相关（虚函数表，虚函数指针），虚函数的实现原理**

   ​	基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。

   类中包含虚函数时，编译器会为该类⽣成⼀个**虚函数表**，保存该类中**虚函数的地址**（编译期 - 在静态全局区）。定义⼀个派⽣类对 象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个**虚函数指针**，指向该类型的虚函数表，这个虚函数指针的**初始化**是在**构造函数中完成的**。后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻 找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。函数地址的晚绑定。

   

7. **函数调用的过程中堆栈的变化情况**

   - 当一个函数被调用时，栈帧被压入堆栈。

   - 被调用函数的**参数**被压入栈帧。

   - 函数的**局部变量**在栈帧中被分配空间。

   - 函数的**返回地址被推入栈帧**。

   - 被调用函数的栈帧被弹出，栈帧中的局部变量和参数的空间被释放。

     

8. **栈帧是什么**

   在**函数调用**过程中存储相关信息的一块**内存区域**，它被压入堆栈（栈）以支持函数的调用和返回。**每个函数**调用都会创建**一个新的栈帧**，该栈帧包含了与函数调用相关的信息，如**局部变量**、**函数参数**、**返回地址**和其他必要的控制信息。
   

9. **什么是内存泄漏、如何防止**

   程序员申请的动态内存空间在使用完没有释放，会导致内存资源浪费甚至内存不足系统崩溃。	
   防止：申请和释放内存要成对出现、使用智能指针、使用Rall思想，在构造函数中申请，析构函数中释放内存。

   

10. **介绍智能指针**

    智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏。智能指针就是⼀个类，当超出作⽤域会⾃动 调⽤析构函数，析构函数会⾃动释放资源。

    **unique_ptr**：独占式指针，同⼀时间内只有⼀个智能指针可以指向该对象。不能拷贝，可以用move转移资源。

    **shared_ptr**：共享式拥有概念，多个智能指针可以指向相同对象。每多一个指针指向它，引用计数+1，析构一个引用计数-1，减到0的时候释放空间。

    **weak_ptr**：弱引用，不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象，不会改变引用计数。为了解决shared_ptr循环引用导致内存泄漏问题。还可以使用lock函数解决多线程中线程安全问题。

    

11. **讲一下shared_ptr的内部结构**

    计数器（reference count）、指针和控制块（control block）

    控制块：包含计数器和一些额外的信息。

    

12. **宏定义，typedef区别**

    执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；

    define 是宏定义，发⽣在预处理阶段， 不进⾏类型检查，只是进行简单的文本替换；
    

13. **c++ 11新特性**

    智能指针、Lambda表达式、unordered_set/unordered_map、初始化成员列表、右值引用、范围for循环等
    

14. **C++程序的时候如果进程崩了，怎么排查问题**

    **核心转储（Core Dump）：**启用核心转储功能，以便在程序崩溃时生成核心转储文件。核心转储文件包含了崩溃时的内存状态，可以通过它进行后续调试。

    **分析核心转储：**使用调试器（例如 GDB）分析核心转储文件。在终端中执行 `gdb <your_program> core`，然后可以使用 `bt`（backtrace）命令查看函数调用栈，以确定程序崩溃的位置。

    **查看错误信息：**核心转储文件中可能包含有关崩溃原因的信息，可以查看这些信息，例如段错误（Segmentation Fault）或空指针引用。

    

15. **C++中原子操作有哪些库函数，怎么实现的？**

    主要通过\<atomic\>库实现，atomic有个类模板实现各个基本类型的原子操作。

    atomic_load（加载原子变量的值）、atomic_store（存储新的值到原子变量）、atomic_fetch_add 、atomic_fetch_sub （这两个函数用于原子地执行加法和减法操作）、atomic_exchange （交换原子变量的值）

    这些实现会利用底层的**硬件原子操作指令**或操作系统提供的**原子操作机制**来实现。

16. **Mutex加锁底层怎么实现的？**

    **原子操作：** Mutex 的实现通常依赖于原子操作，确保对共享资源的访问是原子的，即不会被中断。

    **等待策略：**等待策略是指当一个线程或进程没有获取到锁时，应该采取什么样的行为
    					**自旋等待（spin-wait）：**自旋等待是指线程或进程不断地检查锁的状态，直到获取到锁为止。这种策略适用于锁的竞争不激烈，等待时间较短的情况，因为它可以避免上下文切换的开销，但是也会浪费CPU资源。
    					**阻塞等待（block-wait）：**阻塞等待是指线程或进程在获取不到锁时，主动让出CPU，进入等待队列，等待被唤醒。这种策略适用于锁的竞争较激烈，等待时间较长的情况，因为它可以节省CPU资源，但是也会增加上下文切换的开销。

    **自旋锁：** 在 Mutex 的实现中，可能会使用自旋锁（Spin Lock）。自旋锁是一种在获取锁失败时不立即进入睡眠状态，而是反复尝试获取锁的锁实现。在实现上，可以使用**原子操作**来更新锁的状态，例如设置锁的**标志位**。

17. **vector是如何做内存管理的**

    1. **动态内存分配：** 当你向 `std::vector` 中添加元素时，如果当前的容量不足以存储新元素，`std::vector` 就会分配一块新的内存区域，通常是原来容量的两倍，然后将原来的元素拷贝到新的内存中。这是为了避免每次添加元素都进行内存分配，提高性能。

       **一级空间配置器**：

       - 负责大块内存的分配和释放。
       - 使用 `malloc` 和 `free` 进行内存的分配和释放。
       - 一般情况下，分配的内存较大，用于处理较大的对象，例如数组。

       **第二级（二级配置器）**：

       - 负责小块内存的分配和释放。
       - 利用 memory pool（内存池）管理小块内存。
       - 内部采用多个 free lists，每个 free list 存储一组大小相等的内存块，用于快速分配和释放。
       - 当 free list 中无法满足需求时，会调用第一级配置器进行大块内存的分配。

    2. **内存释放：** 当你从 `std::vector` 中删除元素或者清空整个容器时，它会释放相应的内存。这确保了 `std::vector` 只占用实际存储的元素所需的内存空间。

    3. **迭代器稳定性：** `std::vector` 的迭代器在插入或删除元素时的行为是相对稳定的。也就是说，在插入或删除元素后，指向修改点之前的迭代器仍然有效，而指向修改点之后的迭代器可能会失效。

    4. **连续内存：** `std::vector` 保证其元素在内存中是连续存储的，这使得访问元素更加高效，因为可以通过指针算术运算直接访问内存。

    5. **预留空间：** 你可以使用 `reserve` 函数预留一定的空间，这样在添加元素时，不必每次都重新分配内存，提高了性能。

18. **C++左值和右值**

    **右值：**无名字，无地址 （字面常量、临时对象、函数返回的临时值等都是右值。）

    **左值：**有名字，有地址（ 变量、对象、数组元素、引用等都是左值）

    **右值引用的特点：**通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。

    **右值拷贝（ move 构造函数）：**可以实现 move语义 ，即从右值中直接拿数据过来初始化 或修改左值， ⽽不需要重新构造左值后再析构右值。⼀个 move 构造函数是这样声明的。

    

19. **一个类有多个基类，内存中怎么虚函数表是怎么分布的？**

​		对于多继承而言，每个**基类**都有自己的**虚函数表（vtable）**，而派生类会包含所有**基类的虚函数表**。













## 二.操作系统篇

1. **进程和线程的区别**

   - 调度：线程是调度的基本单位（PC，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。

   - 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。

   - 系统开销：线程创建销毁只需要处理PC值，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁PCB结构以及相关资源，系统开销大。

     

2. **进程间的通信方式有哪些**

   - **管道：**
     - 无名管道（**内存文件**）：管道是一种**半双工的通信方式**，数据只能**单向流动**，而且只能在具有**亲缘关系的进程之间使用**。
     - 有名管道（FIFO文件，借助**文件系统**）：允许在没有亲缘关系的进程之间使用，管道是**先进先出**的通信方式。
   - **共享内存：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
   - **消息队列：**存放在内核中并由**消息队列标识符标识**。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
   - **套接字：**适用于**不同机器间进程通信**，在本地也可作为两个进程通信的方式。
   - **信号：**用于通知接收**进程某个事件已经发生**，比如按下ctrl + C就是信号。
   - **信号量：**信号量是一个计数器，可以用来控制多个进程对**共享资源的访问**。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

   

3. **介绍以下中断和异常的区别，以及中断处理步骤？**

   **中断：**由**外部设备或其他处理器发起**的，用于通知 CPU 有一个事件需要处理，例如 I/O 完成，敲击键盘等。然后CPU识别中断来源并发送给内核。分为硬中断和软中断，硬中断为硬件发起，软中断通常是由操作系统内核中的代码生成的，用于执行一些系统级的任务。
   **异常：**由CPU发起的，如遇到缺页、除0、访问非法内存异常等等。发送给内核。

   **中断处理步骤：**

   1. **中断发生：** 外部设备或其他处理器发出中断信号，通知 CPU 有事件需要处理。
   2. **保存当前上下文：** CPU 会保存当前执行的程序计数器、寄存器状态和其他必要的信息，以便在中断处理完成后能够恢复执行。
   3. **中断服务例程（ISR）的调用：** CPU跳转到中断向量表（Interrupt Vector Table）中的相应入口，开始执行中断服务例程。
   4. **恢复现场：** 在中断服务例程执行完毕后，CPU 恢复之前保存的上下文信息，包括程序计数器、寄存器等。
   5. **中断返回：** 执行完中断服务例程后，CPU 返回到被中断的程序，继续执行。

   

4. **内存映射和共享内存**

   **内存映射：**

   1. **映射方式：** 内存映射是将文件或其他对象映射到进程的地址空间，使得这些对象可以像内存一样被访问。这包括**文件映射**和**匿名映射**。
   2. **文件映射：** 主要用于将文件映射到内存，这样可以直接在内存中读取或写入文件数据，而无需通过传统的文件 I/O 操作。
   3. **匿名映射：** 创建一个与文件无关的映射，可以用于进程间通信或创建共享的内存区域。
   4. **使用场景：** 内存映射通常用于处理文件、数据库等大型数据集，或者用于多进程之间的通信。

   **共享内存：**

   1. **共享方式：** 共享内存是通过在不同的进程之间创建共享的内存区域，使得这些进程可以直接访问共享的内存段，而无需通过中间介质。
   2. **通信方式：** 共享内存主要用于进程间通信，允许多个进程之间快速、高效地共享数据。进程可以读取和写入共享内存中的数据，实现数据的共享。
   3. **使用场景：** 共享内存通常用于需要频繁交换大量数据的进程之间，以提高性能和效率。

   **区别总结：**

   1. **映射对象：** 内存映射主要涉及将文件或其他对象映射到进程的地址空间，而共享内存是直接在不同进程之间创建共享的内存区域。
   2. **用途：** 内存映射通常用于处理文件、数据库等数据集，而共享内存用于进程间通信，特别是需要频繁交换大量数据的情况。
   3. **实现机制：** 内存映射可以是文件映射或匿名映射，而共享内存是直接创建一块共享的内存区域。

5. **为啥要用虚拟内存，怎么实现？**

   虚拟内存通过内存和磁盘之间的映射，虚拟出来更大的内存空间，实现了隔离和保护机制。

   虚拟内存实现是基于分页或者分段实现，分页是将内存和磁盘分成大小相等的块，通过页面调度算法对页面进行换入和换出。通过页表对虚拟地址和逻辑地址的映射。分段是根据逻辑将进程分为数据段、代码段等，分配更灵活。
   

6. 

   

   

   

   

   

   

   

## 三.计算机网络篇

1. **介绍一下OSI七层协议，各层协议都有哪些**

   1. **物理层（Physical Layer）：**
      - 功能：传输比特流，主要关注物理介质、电流、编码等。
      - 协议：没有特定的协议，主要涉及硬件标准（如Ethernet、Wi-Fi等）。
   2. **数据链路层（Data Link Layer）：**
      - 功能：负责将比特流组织成帧，进行错误检测和纠正。
      - 协议：ARP（Address Resolution Protocol）等。
   3. **网络层（Network Layer）：**

      - 功能：负责在不同网络之间进行路由和转发，实现端到端的数据传输。
      - 协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等。
   4. **传输层（Transport Layer）：**
      - 功能：提供端到端的通信，负责数据的可靠性、流量控制和错误恢复。
      - 协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。
   5. **会话层（Session Layer）：**

      - 功能：管理和协调会话，确保数据传输的正确顺序。
      - 协议：NetBIOS（Network Basic Input/Output System）等。
   6. **表示层（Presentation Layer）：**

      - 功能：处理数据的表示和格式，确保应用层能够解释数据。
      - 协议：JPEG、GIF、SSL/TLS（Secure Sockets Layer/Transport Layer Security）等。
   7. **应用层（Application Layer）：**

      - 功能：为用户提供网络服务，是网络应用程序的接口。
      - 协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、DNS（Domain Name System）等。
        

2. **输入一个网页，到出现页面，这中间发送了什么？**

   - 域名解析DNS
   - 发起TCP的3次握手
   - 建立TCP连接后发起http请求
   - 服务器响应http请求，浏览器得到html代码
   - 浏览器解析html代码，并请求html代码中的资源
   - 浏览器对页面进行渲染呈现给用户。
     

3. **TCP三次握手**

   1. **客户端发起连接请求：**
      - 客户端首先向服务器发送一个TCP报文，其中设置了SYN（同步）标志位，并选择一个初始序列号（ClientISN）。
   2. **服务器确认连接请求并发起连接：**
      - 服务器收到客户端的SYN报文后，会发送一个带有SYN和ACK（确认）标志位的TCP报文作为响应。
      - 服务器也会选择一个自己的初始序列号（ServerISN），并在ACK字段中确认客户端的初始序列号（ClientISN + 1）。
      - 同时服务器会将第二次握手的客户端加入到半连接队列。
   3. **客户端确认连接：**
      - 客户端收到服务器的响应后，向服务器发送一个带有ACK标志位的TCP报文，确认服务器的初始序列号（ServerISN + 1）。
      - 第三次握手可以数据
        
        

4. **为什么TCP三次握手，两次握手可以吗**

   三次握手是为了确保双方都有发送和接收数据的能力。两次握手不可以，第三次握手是为了防止历史失效连接再次请求，导致资源浪费。

5. **TCP四次挥手**

   1. **主动关闭方发送连接释放报文（FIN）：**
      - 主动关闭方（一般是客户端）首先发送一个TCP报文，其中设置了FIN标志位，表示它已经完成发送数据，希望关闭连接。表示已经没有数据要发送了。
      - 这个FIN报文中还包含一个序列号，用于标识主动关闭方的数据已经发送完毕的位置。

   2. **被动关闭方确认收到释放报文：**
      - 被动关闭方（一般是服务器）收到主动关闭方的FIN报文后，会向主动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了主动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认主动关闭方的序列号。

   3. **被动关闭方发送连接释放报文（FIN）：**
      - 被动关闭方在完成了自己的数据发送后，也会发送一个TCP报文，其中设置了FIN标志位，表示它希望关闭连接。
      - 这个FIN报文中也包含一个序列号，用于标识被动关闭方的数据已经发送完毕的位置。

   4. **主动关闭方确认收到释放报文：**
      - 主动关闭方收到被动关闭方的FIN报文后，向被动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了被动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认被动关闭方的序列号。

   5. **四次挥手的2MSL有什么用**

      ​	等戴2MSL作用防止历史报文发送到服务器产生混乱。也能让服务端正确关闭（若服务器迟迟没有收到第四次报文，会重发第三次报文）。

6. **TCP和UDP的区别，什么时候用tcp什么时候用udp？**

   **TCP：**面向连接一对一，可靠通信、字节流、有流量控制以及拥塞控制。

   **UDP**：无连接、不可靠、低延迟、可以一对多。

   对于文件完整性和可靠性有要求用TCP，如文件传输等等。对于时间要求使用UDP，如视频通话，游戏等等。

   

7. **udp丢包会有什么现象？**

   **数据丢失**

   **乱序**

   **延迟变化**

   

8. **http和https的区别**

   都是用于在网络上传输数据的协议，它们之间的主要区别在于安全性和加密。

   - **HTTP：** 传输的数据是明文的，不经过加密处理。
   - **HTTPS：** 使用SSL/TLS协议对数据进行加密，确保传输的数据在网络上是安全的。

   

9. **滑动窗口-流量控制作用**

   ​		用于流量控制。发送方和接收方都维护一个滑动窗口，表示可以发送或接收的数据帧的范围。发送方通过滑动窗口的机制动态调整发送的数据量，以保证在网络状况允许的情况下提高传输速度。

   

10. **拥塞控制**

    拥塞控制通过监测网络中的拥塞情况，采取一系列策略来调整数据流的速率，以避免网络过载。慢启动、拥塞避免、快速重传、快速恢复等。

    

11. **流量控制和拥塞控制差异**

    滑动窗口主要关注单个通信连接的数据流控制，而拥塞控制关注整个网络中的拥塞情况。
    

12. **服务端的socket接收缓冲区只剩10个字节，但是客户端发过来一个未经过分片的12个字节的报文。之后客户端和服务端分别会发生什么事情？如果服务端的接收窗口变为0会怎么样？**（看）

    ​		这个问题的答案可能取决于具体的**网络协议和阻塞模式**，但一般来说，可以参考以下的情况：

    ​		**TCP协议**，那么客户端发送的报文会被分片为两个TCP段，每个段的大小为6个字节。服务端会接收到第一个段，并将其存入接收缓冲区，然后向客户端发送一个ACK，表示已经收到了6个字节的数据。但是由于服务端的接收缓冲区已经满了，无法接收更多的数据，所以**服务端会丢弃第二段报文**，并向**客户端发送一个窗口大小为0的通知**，表示**暂时不能接收数据**。客户端收到窗口大小为0的通知后，**会停止发送数据**，并启动**重传定时器，等待服务端的窗口大小变大**。服务端在读取了接收缓冲区中的数据后，**会向客户端发送一个新的窗口大小**，表示可以接收数据了。
    ​	**UDP协议**，那么客户端发送的报文不会被分片，而是作为一个整体的UDP数据报发送出去。服务端会接收到这个数据报，但是由于接收缓冲区只有10个字节的空间，无法存放12个字节的数据，所以**服务端会丢弃这个数据报**，并向**客户端发送一个ICMP差错报文**，表示**目的地不可达**。客户端收到这个差错报文后，会知道数据没有被成功发送，但是**UDP协议并不提供重传机制**，所以客户端需要自己决定是否重新发送数据。服务端在读取了接收缓冲区中的其他数据后，会释放出空间，但是并不会主动通知客户端，所以客户端需要自己判断何时可以重新发送数据。

13. **TCP的keep-alive和HTTP的keep-alive有什么区别？**

    **TCP Keep-Alive：**于在长时间没有数据传输时保持 TCP 连接的活跃状态，以防止连接因为长时间的空闲而被中断。周期性地向对方发送一个小的探测包（Probe）来实现的。如果一定时间内没有收到对方的响应，就会认为连接已经失效，然后关闭连接。

    **HTTP 的 Keep-Alive：**用于在**一次 TCP 连接上发送多个 HTTP 请求**，而不是每次请求都建立一个新的 TCP 连接。这可以减少连接建立和断开的开销，提高性能。

​		

​		







## 四.算法数据结构篇

1. **DFS以及BFS的应用场景都有哪些？**

   两者都可以用: 图以及树的遍历、迷宫问题


   DFS:  回溯

   BFS: 最短路径、树的层序遍历

2. **红黑树性质**

   红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，通过一系列规则确保树的高度平衡，从而保持较为稳定的搜索、插入和删除性能。红黑树得名于节点上的颜色标记，每个节点都带有一个颜色属性，可以是红色或黑色。

   红黑树的性质包括以下五点：

   1. **节点颜色：** 每个节点要么是红色，要么是黑色。
   2. **根节点：** 根节点是黑色的。
   3. **叶子节点：** 叶子节点（NIL 或空节点）是黑色的。
   4. **相邻节点：** 相邻的两个节点不能同时为红色，即红色节点不能连续出现。
   5. **路径黑色节点数：** 对于树中的任意一条路径，从根节点到叶子节点经过的黑色节点数目相同。

3. **回溯的时间复杂度**

   ​	回溯本质就是暴力搜索，如果解空间为N，时间复杂度为N^2

4. **小顶堆取出顶部元素之后，下面的元素怎么更新？**

   在小顶堆中，当取出堆顶元素后，为了保持堆的性质，需要进行**堆的调整**，通常是将堆的最后一个元素移动到堆顶，然后通过一系列比较和交换操作，将其下沉到正确的位置，以满足小顶堆的性质。

5. 

6. 

7. 

8. 

## 五.数据库篇

1. MySQL索引底层数据结构，为啥不用二叉树，B树或者哈希表？

   **B+数。**多路平衡二叉树。叶子节点使用双向循环链表串联，方便遍历。

   **为啥不用二叉树：**二叉树分裂节点只有2，数据多的话会导致数的层数很深，需要增加访问磁盘的次数。

   **为啥不用B树：**B数每个非叶子节点存储了数据（或者指针），会导致相同大小非叶子存储分裂个数减少，会增加数的层数。并且对于范围搜索没有B+树方便。

   **为啥不用哈希表：**哈希表一般基于内存，访问比较快。但是不支持范围查询。

## 六.设计模式篇



## 七.网络服务器篇

1. **proactor和reactor模式**

   "Reactor" 和 "Proactor" ，通常用于描述事件驱动编程中的不同策略。它们分别表示了两种不同的并发模型。

   ​	**Reactor 模式：**

   ​		Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个单独的事件分发器（Dispatcher）负责监听和接受连接（通常称为 Reactor 线程），当有事件发生时，分发器将事件分发给相应的处理器（Handlers）进行处理。

   **Proactor 模式：**

   - Proactor 也是一种处理并发 I/O 操作的并发模型，与 Reactor 不同，Proactor 更加关注异步处理。
   - Proactor 负责启动异步操作，监听这些操作的完成，并在操作完成时通知相应的 Handler。
   - Proactor 模式更适合高并发环境，因为它允许应用程序继续执行其他任务，而不必等待 I/O 操作完成。

2. **五种IO模型**
   **阻塞（阻塞等待数据）、非阻塞（立即返回，但是得循环读取）、IO多路复用（select、poll、epoll的区别）、信号驱动（复杂）、异步**
   **信号驱动：**信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。
   **异步**：数据准备和数据读取部分都是不阻塞的，当有数据来，直接处理好通知应用程序去读

3. **阻塞、非阻塞、同步、异步的区别**
   网络IO有数据准备和数据读取两个部分。阻塞、非阻塞发生在数据准备部分，区别为数据没准备好时能否立即返回。同步异步为数据准备好了通知应用程序的方式，同步为等待操作完成才能进行下一步操作，异步为不需要等待操作完成，而是继续执行其他任务，当执行完之后操作系统会通知程序。

4. **epoll是同步还是异步的？**

   IO层面，epoll是同步的。从消息处理层面，epoll是异步的。
   
5. **线程池数量如何确定？**

   - 任务是否是 CPU 密集型（计算密集型）还是 I/O 密集型（例如，网络请求、文件操作）？
   - 如果是 CPU 密集型任务，线程池的大小通常设置为 **CPU 核心数**。
   - 如果是 I/O 密集型任务，可以使用更多的线程，因为线程在等待 I/O 操作完成时可以执行其他任务。

​		

6. **IO多路复用**

   **select：**把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。

   ​			缺点：1.fd set大小有限制。2.fd数组拷贝到了内核态仍然有开销 3.select并没有通知用户态哪一个socket有数据，需要用户遍历。

   **poll**：是select的改进版，但是性能提升不明显，将fd set换成链表。select中的两个缺点还是存在。监听FD越多，每次遍历消耗时间也越久，性能反而会下降。

   **epoll：**epoll底层是通过红黑树实现，增删节点只需要logn的时间复杂度。epoll内核中维护了一个**内核事件表**，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发**回调**，无需手动遍历。通过**共享内存**的方式，无需重复拷贝FD到内核空间。

   epoll主要函数：epoll_create , epoll_ctl , epoll_wait 

   **LT和ET模式**

   

7. **Reactor模式的单线程模型了解吗，介绍一下？有哪些常见的系统或者服务器用了这个**
   Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个事件分发器负责监听和接受连接（通常称为 Reactor 线程），而其他的操作（如读写数据、处理业务逻辑）由对应的业务处理完成。但是单线程在处理业务时候无法处理其他连接，容易遇到性能瓶颈。

   实现方式：

   1. **事件注册：** 应用程序将事件（例如，socket 的读写事件）注册到 Reactor 中。
   2. **事件监听：** Reactor 线程负责监听注册的事件。这个调用通常会阻塞，等待有事件发生时才会返回。
   3. **事件分发：** 当有事件发生时，Reactor 线程会触发事件分发，将事件分发给相应的事件处理器（Handler）。
   4. **事件处理：**事件处理器负责具体的事件处理，包括读写数据、业务逻辑的执行等。这些操作在一个单线程中依次执行。

   

   **Redis，Nginx**：因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上

8. **怎么实现异步，有哪些应用场景和函数？**

   异步编程是一种并发编程的方式，允许程序在等待某些操作完成的同时执行其他操作。

   实现方式：回调函数 ，当完成一个异步操作后执行对应的回调函数

   应用场景：网络编程、并发编程、文件IO等

   

9. **服务器有一个连接进来，到应用程序读取到数据，需要经过几次内核态/用户态切换？需要几次缓冲区数据的拷贝？**

   ​		从网卡到应用程序，一般需要经过**两次内核态/用户态切换**，**三次缓冲区数据的拷贝**。当然，这个过程还可以通过一些技术来优化，如**零拷贝**等。

   1.当网卡收到数据包后，会触发一个硬件中断，这是第一次内核态/用户态切换。

   2.将数据包从网卡缓冲区拷贝到内核空间的缓冲区，这是第一次缓冲区数据的拷贝。

   3.内核会将数据包从内核空间的缓冲区拷贝到用户空间的socket对应的接收队列。这是第二次缓冲区数据的拷贝。

   4.内核会通知用户进程有新的数据到达，用户进程可以通过read()或者recv()等函数从socket的接收队列中读取数据。这是第二次内核态/用户态切换，也是第三次缓冲区数据的拷贝。

10. **介绍一下零拷贝**

    零拷贝（Zero Copy）是一种读写优化技术，旨在减少数据在系统内部的复制操作，提高数据传输的效率。在零拷贝中，数据可以在不涉及用户态和内核态之间的拷贝的情况下在系统内部传递。

    零拷贝的实现方式有多种，常见的有以下几种：

    **内存映射：**利用虚拟内存的特性，将**内核缓冲区**和**用户缓冲区**映射到同一个**物理地址**，从而省去一次CPU拷贝。

    **sendfile：**利用内核提供的sendfile系统调用，将文件数据直接从**内核缓冲区**传输到**socket缓冲区**。

    **DMA：DMA控制器**将数据从内核缓冲区拷贝到**网卡设备**，从而省去一次CPU拷贝。DMA（Direct Memory Access，直接内存访问）是一种计算机系统中的**数据传输技术**，旨在减轻中央处理器（CPU）对内存访问和数据传输的负担。DMA 允许**外围设备直接访问系统内存**，而**无需 CPU 的直接参与**。这样可以提高数据传输的效率，减少 CPU 的占用率，同时允许 CPU 在数据传输过程中执行其他任务。

11. **缓存的作用**

    **提高性能：**通过缓存数据，处理器不必等待慢速设备（如磁盘或网络）传输数据，从而允许它继续执行其他任务。

    **平衡处理速度不匹配：**各个组件的处理速度可能不匹配。CPU 处理速度通常比磁盘或网络传输速度快得多。通过使用缓冲区，可以平衡这种速度不匹配。

12. 

## 八.linux篇

1. **Linux内存管理机制**

   1. **虚拟内存管理：**

      - Linux 使用虚拟内存来映射物理内存和磁盘空间，以提供更大的地址空间和更灵活的内存管理。
      - 虚拟内存通过页面（page）来进行管理，页面是内存和磁盘上的固定大小的块。

   2. **页面置换：**

      - 当系统内存不足时，Linux 会使用页面置换机制将不常用的页面从物理内存中置换到磁盘上，从而腾出空间供更紧急需要的页面使用。
      - 常见的页面置换算法包括最近最少使用（LRU）、时钟算法（Clock Algorithm）等。

   3. **内存压缩：**

      - 内存压缩是一种在内存不足时通过压缩内存页面来腾出空间的技术。

   4. **交换空间（Swap Space）：**

      - Linux 使用交换空间作为一种延伸内存的手段，将不活动的页面移动到交换空间中，从而腾出物理内存。

        

2. 

## 九.项目篇



## 十.其余篇

1. 构成一个计算机需要什么，各个组件做什么工作？

   1. **中央处理器（Central Processing Unit，CPU）：**
      - **功能：** 执行计算机程序中的指令。
      - **工作：** 从内存中获取指令，执行算术和逻辑操作，并控制其他硬件设备。
   2. **内存（Memory）：**
      - **功能：** 存储计算机程序和数据，供 CPU 快速访问。
      - **工作：** 包括随机访问存储器（RAM）和只读存储器（ROM），RAM 用于临时存储数据和程序，而 ROM 存储固化的不变的程序和数据。
   3. **存储设备（Storage Devices）：**
      - **功能：** 提供长期存储，用于保存操作系统、应用程序和用户数据。
      - **工作：** 包括硬盘驱动器（HDD）、固态硬盘（SSD）、光盘驱动器等。
   4. **输入输出设备**

2. 很多小文件（总量1T）想从一台主机传输到另外一台主机，保证速度的前提下设计一个方案

   **打包压缩：** 将小文件打包成压缩文件，然后进行传输。这样可以减少传输的文件数量，降低文件系统开销和网络开销。
   **并行传输：** 利用并行传输的方式提高传输速度。可以将文件分成多个部分，并同时传输这些部分。

3. 设计一个函数，这个函数没有任何输入，每次执行这个函数就会返回一个INT64的值，要保证返回的值是全局唯一的，也就是之前没有输出过的，怎么操作？

   定义全局静态变量。

4. 读一个大文件和读很多个小文件效率是一样的吗？假设小文件总量和大文件大小一致
     读取大文件时，文件内容通常在磁盘上是连续存储的，因此磁盘寻址时间相对较小。相比之下，读取许多小文件可能导致文件系统随机读取，磁盘寻址时间可能会增加。

5. 

## 十一.HR面试篇

1. 自我介绍




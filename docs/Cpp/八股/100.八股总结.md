# 面试问题总结

## 一.CPP篇

1. **const关键字？**

   **const 修饰基本类型数据类型：**表示类型为常量不可以修改

   加在**函数前**表示返回值为const，加在**函数后面**表示函数里的值不可修改（在成员函数中）。

   **const 修饰指针变量和引⽤变量：**const在\*左侧为底层cost，表示指向那个变量不可改变。const在*右侧为顶层cost，表示指针本身为不可变。

   **const 成员变量**：表示对象中不可变，对于整个类可变。

   **const 修饰类对象**：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

   

2. **C++的内存结构**，**什么情况下使用堆区什么情况使用栈区**
   由高到底地址分别为：
   **栈区：**由编译器管理分配和回收，效率很高，但是分配的内存容量有限。存放局部变量和函数参数。
   **堆区:** 由程序员管理，需要⼿动分配和回收，空间较大但可能会出现内存泄漏和空闲碎⽚的情况。动态内存分配的时候使用。
   **全局/静态存储区:**存储初始化和未初始化的**全局变量**和**静态变量**。
   **常量区:**存储常量，⼀般不允许修改。
   **代码区:** 存放程序的⼆进制代码。

   

3. **动态链接库静态链接库特点、区别**

   **静态链接：**链接器在**链接时**将库的内容加入到可执行程序中。运行环境的依赖性较小，但是**生成的程序比较大**，**库函数有了更新，必须重新编译应用程序**

   **动态链接：**连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序**运行时**才将所需资源调入可执行程序。

   - 在需要的时候才会调入对应的资源函数

   - 简化程序的升级；有着较小的程序体积

   - 实现进程之间的资源共享（避免重复拷贝）

   - 依赖动态库，不能独立运行

   - 动态库依赖版本问题严重

     

4. **static关键字作用**

   在**全局变量**或者**普通函数**上改变作用域为当前文件可以访问。

   在**局部变量**上，改变局部变量生命周期为程序结束，并且只初始化一次。

   在类中**成员变量**上，所有对象共享同一份变量，可以通过类名访问，初始化必须在类外。

   **static成员函数**，可以通过类名访问，不含this指针，只能操作对应的static成员变量。

   

5. **面向对象三大特性**

   **封装：**将（成员变量）和（成员函数）打包在一个单元中，形成一个类。封装提供了对类内部实现的隐藏，并提供访问权限，使得代码更加模块化和可维护。

   **继承：**一个类（子类或派生类）可以使用另一个类（父类或基类）的属性和行为，并且可以扩展或修改它们。

   **多态：**多态是指同一个接口可以被用于不同的数据类型。父类指针可以指向不同的子类对象。
   多态分为（静态多态）和（动态多态）。

   静态多态通过**函数重载**和**运算符重**载来实现的，允许一个接口有多个不同的实现，这称为静态绑定。

   动态多态是通过**虚函数**和**抽象类**实现的。在运行时，同一个函数调用可能会**根据对象的实际类型**执行不同的代码，这称为动态绑定。

6. **虚函数相关（虚函数表，虚函数指针），虚函数的实现原理**

   ​	基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。

   类中包含虚函数时，编译器会为该类⽣成⼀个**虚函数表**，保存该类中**虚函数的地址**（编译期 - 在静态全局区）。定义⼀个派⽣类对 象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个**虚函数指针**，指向该类型的虚函数表，这个虚函数指针的**初始化**是在**构造函数中完成的**。后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻 找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。函数地址的晚绑定。

   

7. **函数调用的过程中堆栈的变化情况**

   - 当一个函数被调用时，栈帧被压入堆栈。

   - 被调用函数的**参数**被压入栈帧。

   - 函数的**局部变量**在栈帧中被分配空间。

   - 函数的**返回地址被推入栈帧**。

   - 被调用函数的栈帧被弹出，栈帧中的局部变量和参数的空间被释放。

     

8. **栈帧是什么**

   在**函数调用**过程中存储相关信息的一块**内存区域**，它被压入堆栈（栈）以支持函数的调用和返回。**每个函数**调用都会创建**一个新的栈帧**，该栈帧包含了与函数调用相关的信息，如**局部变量**、**函数参数**、**返回地址**和其他必要的控制信息。

9. **什么是内存泄漏、如何防止**

   程序员申请的动态内存空间在使用完没有释放，会导致内存资源浪费甚至内存不足系统崩溃。	
   防止：申请和释放内存要成对出现、使用智能指针、使用Rall思想，在构造函数中申请，析构函数中释放内存。

   

10. **介绍智能指针**

    智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏。智能指针就是⼀个类，当超出作⽤域会⾃动 调⽤析构函数，析构函数会⾃动释放资源。

    **unique_ptr**：独占式指针，同⼀时间内只有⼀个智能指针可以指向该对象。不能拷贝，可以用move转移资源。

    **shared_ptr**：共享式拥有概念，多个智能指针可以指向相同对象。每多一个指针指向它，引用计数+1，析构一个引用计数-1，减到0的时候释放空间。

    **weak_ptr**：弱引用，不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象，不会改变引用计数。为了解决shared_ptr循环引用导致内存泄漏问题。还可以使用lock函数解决多线程中线程安全问题。

    

11. **讲一下shared_ptr的内部结构**

    计数器（reference count）、指针和控制块（control block）

    控制块：包含计数器和一些额外的信息。

    

12. **宏定义，typedef区别**

    执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；

    define 是宏定义，发⽣在预处理阶段， 不进⾏类型检查，只是进行简单的文本替换；

13. **c++ 11新特性**

    智能指针、Lambda表达式、unordered_set/unordered_map、初始化成员列表、右值引用、范围for循环等

14. **C++程序的时候如果进程崩了，怎么排查问题**

    **核心转储（Core Dump）：**启用核心转储功能，以便在程序崩溃时生成核心转储文件。核心转储文件包含了崩溃时的内存状态，可以通过它进行后续调试。

    **分析核心转储：**使用调试器（例如 GDB）分析核心转储文件。在终端中执行 `gdb <your_program> core`，然后可以使用 `bt`（backtrace）命令查看函数调用栈，以确定程序崩溃的位置。

    **查看错误信息：**核心转储文件中可能包含有关崩溃原因的信息，可以查看这些信息，例如段错误（Segmentation Fault）或空指针引用。

    

15. **C++中原子操作有哪些库函数，怎么实现的？**

    主要通过\<atomic\>库实现，atomic有个类模板实现各个基本类型的原子操作。

    atomic_load（加载原子变量的值）、atomic_store（存储新的值到原子变量）、atomic_fetch_add 、atomic_fetch_sub （这两个函数用于原子地执行加法和减法操作）、atomic_exchange （交换原子变量的值）

    这些实现会利用底层的**硬件原子操作指令**或操作系统提供的**原子操作机制**来实现。

16. **Mutex加锁底层怎么实现的？**

    **原子操作：** Mutex 的实现通常依赖于原子操作，确保对共享资源的访问是原子的，即不会被中断。

    **等待策略：**等待策略是指当一个线程或进程没有获取到锁时，应该采取什么样的行为
    					**自旋等待（spin-wait）：**自旋等待是指线程或进程不断地检查锁的状态，直到获取到锁为止。这种策略适用于锁的竞争不激烈，等待时间较短的情况，因为它可以避免上下文切换的开销，但是也会浪费CPU资源。
    					**阻塞等待（block-wait）：**阻塞等待是指线程或进程在获取不到锁时，主动让出CPU，进入等待队列，等待被唤醒。这种策略适用于锁的竞争较激烈，等待时间较长的情况，因为它可以节省CPU资源，但是也会增加上下文切换的开销。

    **自旋锁：** 在 Mutex 的实现中，可能会使用自旋锁（Spin Lock）。自旋锁是一种在获取锁失败时不立即进入睡眠状态，而是反复尝试获取锁的锁实现。在实现上，可以使用**原子操作**来更新锁的状态，例如设置锁的**标志位**。

17. **vector是如何做内存管理的**

    1. **动态内存分配：** 当你向 `std::vector` 中添加元素时，如果当前的容量不足以存储新元素，`std::vector` 就会分配一块新的内存区域，通常是原来容量的两倍，然后将原来的元素拷贝到新的内存中。这是为了避免每次添加元素都进行内存分配，提高性能。

       **一级空间配置器**：

       - 负责大块内存的分配和释放。
       - 使用 `malloc` 和 `free` 进行内存的分配和释放。
       - 一般情况下，分配的内存较大，用于处理较大的对象，例如数组。

       **第二级（二级配置器）**：

       - 负责小块内存的分配和释放。
       - 利用 memory pool（内存池）管理小块内存。
       - 内部采用多个 free lists，每个 free list 存储一组大小相等的内存块，用于快速分配和释放。
       - 当 free list 中无法满足需求时，会调用第一级配置器进行大块内存的分配。

    2. **内存释放：** 当你从 `std::vector` 中删除元素或者清空整个容器时，它会释放相应的内存。这确保了 `std::vector` 只占用实际存储的元素所需的内存空间。

    3. **迭代器稳定性：** `std::vector` 的迭代器在插入或删除元素时的行为是相对稳定的。也就是说，在插入或删除元素后，指向修改点之前的迭代器仍然有效，而指向修改点之后的迭代器可能会失效。

    4. **连续内存：** `std::vector` 保证其元素在内存中是连续存储的，这使得访问元素更加高效，因为可以通过指针算术运算直接访问内存。

    5. **预留空间：** 你可以使用 `reserve` 函数预留一定的空间，这样在添加元素时，不必每次都重新分配内存，提高了性能。

18. **C++左值和右值**，**移动语义**

    **右值：**无名字，无地址 （字面常量、临时对象、函数返回的临时值等都是右值。）

    **左值：**有名字，有地址（ 变量、对象、数组元素、引用等都是左值）

    **移动语义**：核心是移动构造函数，使用**右值引用**作为参数，实现**对象数据**的转移，而不是复制。

    **右值引用的特点：**通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。

    **右值拷贝（ move 构造函数）：**可以实现 move语义 ，即从右值中直接拿数据过来初始化 或修改左值， ⽽不需要重新构造左值后再析构右值。

    

19. **一个类有多个基类，内存中怎么虚函数表是怎么分布的？**

    对于多继承而言，每个**基类**都有自己的**虚函数表（vtable）**，而派生类会包含所有**基类的虚函数表**。
    
20. **怎么定位内存泄漏的位置？**

    使用专门的内存调试工具，如Valgrind（对于C/C++）。或者**自定义内存分配器**，手动记录分配情况。

21. **C++ shared_ptr如何保证线程安全？**

    c++11采用shared_timed_mutex，该互斥量可以用于对 `std::shared_ptr` 进行精细的线程安全控制。使用这个互斥量可以确保 `std::shared_ptr` 的引用计数操作是原子的。以及unique_lock分别用于共享和独占地锁定互斥量。

22. **C++如何解决线程安全问题？**

    **互斥锁（Mutex）**、**原子操作**、**条件变量（Condition Variable）**、**读写锁**

    条件变量：条件变量用于实现线程的等待和通知机制，以避免线程忙等。当某个条件不满足时，线程可以等待条件变量，而在条件满足时，其他线程可以通知等待的线程。

23. **C++派生类的构造和析构顺序是什么？为什么按照这种顺序？**

    1. **基类构造函数先于派生类构造函数调用**：

    2. **成员对象构造函数**

    3. **构造函数调用的顺序与继承层次一致**：

       - 如果有多层继承，构造函数的调用顺序与继承层次一致，从最顶层的基类开始逐级向下调用。

       **析构函数相反。**

       在构造过程中，派生类的构造函数需要调用基类的构造函数，而成员对象的构造函数则需要在它们所属的类的构造函数中调用。按照声明顺序调用这些构造函数可以确保依赖关系被正确建立。销毁按照反序可以确保资源在正确的时间点被获取和释放，避免资源泄漏。

24. **内存对齐有什么用？**

    经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，读取内存的时候是⼀块⼀块进⾏读取的。如果不对齐访存次数会增加，效率会较少。

25. **计算下⾯⼏个类的⼤⼩**

    ```cpp
    class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
    class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）
    class A{static int a; }; sizeof(A) = 1;
    class A{int a; }; sizeof(A) = 4;
    class A{static int a; int b; }; sizeof(A) = 4;
    ```

    

26. **介绍一下深拷贝与浅拷贝**

     **浅拷贝**是指将一个对象的数据复制到另一个对象中，但只复制对象本身和其所指向的所有指针，**而不复制指针所指向的内容**。因此，原对象和拷贝对象会共享同一块内存区域，其中的指针指向相同的数据。如果对象包含动态分配的资源（比如堆上的数组），两个对象的该资源将指向同一块内存。

     **深拷贝**是指将一个对象的数据复制到另一个对象中，不仅复制对象本身和其指针，还要**复制指针所指向的内容**。这样，原对象和拷贝对象拥有各自**独立的内存**，对一个对象的修改不会影响到另一个对象。
    
    
    
27. **说一下C++里面inline有什么用**

    **性能优化：** 减少函数调用的开销是 `inline` 最主要的目的之一，inline函数不会有函数压栈过程。

    **头文件中的函数定义：** 在头文件中定义函数时，通常需要使用 `inline`，以防止在多个编译单元中出现函数的多重定义错误。将函数定义放在头文件中，并标记为 `inline`，可以避免链接错误。

28. **讲一讲C++的new、delete和malloc、free的区别**

    都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。

    **执⾏ new 实际上执⾏两个过程：**

     1.分配未初始化的内存空间（malloc）；

     2.使⽤对象的**构造函数对空间进⾏初始 化**；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处 理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。

    **执⾏ delete 实际上也有两个过程：**

    1. 使⽤析构函数对对象进⾏析构；
    2. 回收内存空间（free）。

    

29. **emplace_back**

    可以就地构造对象，而不需要创建副本和频繁拷贝。这对于复杂的对象类型非常有用，可以避免不必要的对象复制和降低性能开销。

30. **C++ 中重载和重写，重定义的区别**

    **重载**：可以写不同参数列表的同名函数

    **重写**：派⽣类中重新定义⽗类中除了函数体外完全相同的**虚函数**。

    **重定义（隐藏）**：派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同。

31. **可变参数如何实现**

    va_list 

    ```cpp
    #include <iostream>
    #include <cstdarg>
    
    // 可变参数函数示例
    double average(int count, ...) {
        va_list args;
        va_start(args, count);
    
        double sum = 0;
        for (int i = 0; i < count; ++i) {
            sum += va_arg(args, double);
        }
    
        va_end(args);
    
        return sum / count;
    }
    
    int main() {
        std::cout << "Average: " << average(3, 1.2, 2.3, 3.4) << std::endl;
    
        return 0;
    }
    
    ```

32. **强制类型转换**

    C++ 的四种强制转换包括：**static_cast dynamic_cast const_cast reinterpret_cast**

    **static_cast：**明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；

    **dynamic_cast：**专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指 针，可能造成⾮法访问等问题。

    **const_cast：**专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个 可以操作常量的转换符。

    **reinterpret_cast：**不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解 释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。

33. **Main函数执行前发生了什么**

    **运行时环境初始化**：设置堆栈、初始化全局变量、静态变量、 如果程序中有全局或静态对象会在main函数之前调用

34. **为什么基类析构函数要求是虚函数**

    因为虚函数才能实现地址晚绑定的动态多态，继承的子类在执行析构时才能调用子类自己的析构函数。如果不为虚函数，就是静态多态，地址早绑定，子类析构调用的就是父类的析构，可能会导致内存泄漏。

35. **c++编译过程**

     预处理器→编译器→汇编器→链接器

    **预处理阶段：**写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如 #include 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件,删除注释。

    **编译阶段：**编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是**汇编语⾔程序**。⾼级语⾔是源程序。所以注意概 念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼ 级语⾔翻译的汇编语⾔相同。

    **汇编阶段：**汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀ 个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。

    **链接阶段：**⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个 名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得 到的是可执⾏⽬标⽂件。



36. **bss段是啥,有啥作用**

    在C语言中，BSS（Block Started by Symbol）段是可执行程序中的一部分，用于存储**未初始化的全局和静态变量**。bss段的数据在程序加载时由内核统一初始化为0，而不需要从磁盘或网络读取。提高加载速度。

    

37. **静态变量和全局变量的区别**

    **作用域：**全局变量作用域可能是全局，静态变量智能函数或者文件内访问。

    **生命周期：**全局变量为程序生命周期，静态变量为第一次定义到程序结束

    **初始化：**静态变量会在编译器初始化为0

38. **针对堆内存和栈内存怎么去获取呢**

    堆内存可以使用内存分析工具Valgrind。栈内存pstack 查看进程的栈信息。

39. **static对象第一次初始化在什么时候呢**

    **静态局部变量**：第一次执行

    **静态全局变量/成员变量：**程序启动时进行,早于main函数

40. **菱形继承了解吗**

    A(基类) 、 B（A的子类）、C(A的子类)、D()

    在多重继承的情况下，当一个类从两个不同的基类继承，并且这两个基类最终共同继承自同一个基类时，就会形成菱形继承结构。

    菱形继承带来的问题主要有两个：

    1. **二义性（Ambiguity）：** 由于 `D` 类有两个路径可以访问 `A` 类的成员函数，例如 `D` 是否应该使用来自 `B` 类的 `foo` 函数还是来自 `C` 类的 `foo` 函数，就会导致二义性。
    2. **资源浪费：** `D` 类中存在两个独立的 `A` 类子对象，这可能导致对相同资源的重复分配和浪费。

    为了解决菱形继承的问题，C++ 提供了**虚继承（Virtual Inheritance）**的机制。通过在继承关系中使用 `virtual` 关键字，可以确保**只有一个共享的基类子对象**，从而解决二义性和资源浪费问题。

    
    
41. **虚函数和纯虚函数的差别，使用场景**

    ​		虚函数是在**基类中声明并定义**的，函数前加**virtual**关键字，它可以被派生类重写或继承，也**可以直接使用**。

    ​		纯虚函数是在基类中**只声明而不定义**的，虚函数后加=0，它必须在**派生类中重写才能使用**，否则派生类也是抽象类。需要**实现接口才能被实例化**。

    当基类中的**某个函数**在**大多数情况下都**应该由**派生类提供个性化的实现**，但**基类也可以提供一个默认的实现时**，可以将该函数设计为**虚函数**

    当基类中的某个函数必须由**派生类提供个性化的实现**，而**基类无法提供一个合理的默认实现时**，可以将该函数设计为纯虚函数。例如，图形类中的面积函数，不同的图形有不同的面积计算方法，而基类无法给出一个通用的面积函数。

42. **虚函数表的一个顺序是怎么样的**，**存在内存哪个区域** 

    虚函数按照其在**类中的声明顺序**放在虚函数表中，越先**声明的虚函数越靠前**。

    **多继承：**如果有多个基类，那么按照**继承的顺序**依次放置各个基类的虚函数。

    **虚函数的覆盖：**如果一个派生类覆盖了基类的虚函数，那么它的虚函数表中会用**派生类的虚函数指针**替换**基类的虚函数指针**，而不会增加新的条目。

    **虚函数表存在内存的静态存储区**

43. **介绍一下STL容器**

    STL容器可以分为三大类：**顺序容器、关联容器和容器适配器**。

    **顺序容器**是将一组具有相同类型的元素以严格的线性形式组织起来，如**vector、deque、list、forward_list、array**等。顺序容器支持随机访问或双向访问，以及在任意位置进行插入和删除操作。
    **关联容器**是每一个元素都有一个键值和实值，根据键值的大小或哈希值进行排序或分组，如set、map、multiset、multimap、unordered_set、unordered_map等。关联容器**支持快速的查找和访问**，以及在任意**位置进行插入和删除操作**。
    **容器适配器**是封装了**序列容器**的一个类模板，提供了一些特定的功能，如**stack、queue、priority_queue**等。容器适配器只允许在容器的一端进行插入和删除操作，实现了先进先出或先进后出的原则。

    

44. **指针和引用的区别**

    1.指针是一个变量，它存储另一个变量的地址。引用是一个别名，它引用（绑定到）另一个变量。引用在声明时需要初始化。

    2. 指针可以改变指针的值（指向不同的地址）。引用与某个变量绑定，无法改变引用的目标。
    3. 指针可以是空指针（nullptr）。引用在声明时必须初始化，并且不能指向空值。
    4. 指针可以指向数组的第一个元素，并通过指针进行数组遍历。引用不能直接绑定到整个数组。

45. **如何销毁线程**

​	**join成员函数：**阻塞等待子线程执行完毕

​	**detach成员函数：**线程分离，使得线程独立运行

​	

46. **gdb工具使用运行报错如何通过core文件找到错误**

    见https://space.jace.asia/docs/Cpp/Cpp%E7%BC%96%E8%AF%91/gdb%E8%B0%83%E8%AF%95

47. **lambda函数，以及使用场景**

    ​		提供了⼀个类似匿名函数的特性， 其实lamdba 表达式产⽣的是**函数对象**。 lambda 表达式⼀般都是从⽅括号[]开始，中间可能会有小括号传递参数，然后结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了 lamdba 表 达式体。最前边的 [] 是 lambda 表达式的⼀个很重要的功能，就是 闭包， **闭包的⼀个强⼤之处是其可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量**，前⾯的⽅括号就是⽤来定义捕 捉模式以及变量。

    

    使用场景：**作为参数传递给算法函数**、**事件处理和回调函数**、线程函数等



48. **override关键字作用**

    override关键字是C++11中引入的一个新特性，它可以用来**修饰派生类中重写基类虚函数**的成员函数，表示该函数**必须是虚函数**，且必须和**基类函数具有相同的函数签名。**提高可读性和可维护性，静态类型检查（如果不匹配会编译错误）。

49. **类中有指针，维护和使用需要考虑哪些问题** 

    在析构时候需要**释放指针**对应的资源，避免内存泄漏。

    如果是有派生类，需要把**析构函数定义为虚函数**。

    对于拷贝构造和赋值运算需要**深拷贝**。

50. **C++的类中可以定义引用的数据成员吗** 

    可以，**必须在构造函数中进行初始化**，**引用成员不能重新绑定**。

51. **vector的底层实现** 

    ​		vector的底层实现是一个**连续的线性内存空间**，它使用**三个指针**（或迭代器）来**表示容器的状态**：

    _start指向容器的**起始位置**，也就是第**一个元素的地址**；
    _finish指向容器的**结束位置**，也就是**最后一个元素的下一个地址**；
    _end_of_storage**指向容器的末尾位置**，也就是**分配的内存空间的下一个地址**。
    通过这三个指针，vector可以轻松地实现各种操作，如获取容器的大小、容量、首尾元素、随机访问等。

    ​	当vector的大小达到容量时，如果要插入新的元素，vector就**需要扩容**。扩容的过程是：

    ​		申请一块更大的内存空间，一般是原来容量的1.5倍或2倍；
    ​		将原来的数据拷贝到新的内存空间中；
    ​		释放原来的内存空间；
    ​		更新三个指针的值。
    由于扩容会导致原来的内存空间被释放，所以指向原**vector的所有指针、引用和迭代器都会失效**。因此，使用vector时要注意避免这种情况，或者及时更新指针、引用和迭代器的值。

52. **清空vector有哪些方式** 

    **clear()函数，resize函数、erase函数：**不保证清理内存

    **swap函数：**因为它创建了一个临时的空 vector 并与原 vector 交换，释放内存。

53. **已经有指针为什么要引入迭代器**

    迭代器提供了一种抽象层次，隐藏了实现细节。防止了访问越界或者悬空指针问题，更安全。并且提供一致的接口方便使用。

54. **如何判断weakpointer失效** 

    weakPtr.expired()

55. 

## 二.操作系统篇

1. **进程和线程的区别**

   - 调度：线程是调度的基本单位（PC，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。

   - 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。

   - 系统开销：线程创建销毁只需要处理PC值，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁PCB结构以及相关资源，系统开销大。

     

2. **进程间的通信方式有哪些**

   - **管道：**
     
     - 无名管道（**内存文件**）：管道是一种**半双工的通信方式**，数据只能**单向流动**，而且只能在具有**亲缘关系的进程之间使用**。
     
     - 有名管道（FIFO文件，借助**文件系统**）：允许在没有亲缘关系的进程之间使用，管道是**先进先出**的通信方式。
     
       **缺点：单向流动、缓冲大小受限、只能数据流**
     
   - **共享内存：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

     - **优点是无需复制，速度块。缺点是要解决同步和互斥问题。**

   - **消息队列：**存放在内核中的队列，进程向队列添加或者读取消息，由系统调用实现同步。

     ​	优点是消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。缺点是消息队列需要额外的CPU时间，不适合操作频繁的场合。

   - **套接字：**适用于**不同机器间进程通信**，在本地也可作为两个进程通信的方式。

   - **信号：**是一种由**用户、系统或进程**发送给**目标进程的信息**，以**通知目标进**程某个状态的改变或系统异常。信号可以触发目标进程的**某些行为**，如终止、暂停、继续等。它的**优点**是可以实现**异步通知**，缺点是**传递的信息量少**，信号的处理方式有限。

   - **信号量：**信号量是一个**计数器**，可以用来控制多个进程对**共享资源的访问**。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

   

3. **介绍以下中断和异常的区别，以及中断处理步骤，有哪些中断？**

   **中断：**由**外部设备或其他处理器发起**的，用于通知 CPU 有一个事件需要处理，例如 I/O 完成，敲击键盘等。然后CPU识别中断来源并发送给内核。分为硬中断和软中断，硬中断为硬件发起，软中断通常是由操作系统内核中的代码生成的，用于执行一些系统级的任务。
   **异常：**由CPU发起的，如遇到缺页、除0、访问非法内存异常等等。发送给内核。

   **中断处理步骤：**

   1. **中断发生：** 外部设备或其他处理器发出中断信号，通知 CPU 有事件需要处理。
   2. **保存当前上下文：** CPU 会保存当前执行的程序计数器、寄存器状态和其他必要的信息，以便在中断处理完成后能够恢复执行。
   3. **中断服务例程（ISR）的调用：** CPU跳转到中断向量表（Interrupt Vector Table）中的相应入口，开始执行中断服务例程。
   4. **恢复现场：** 在中断服务例程执行完毕后，CPU 恢复之前保存的上下文信息，包括程序计数器、寄存器等。
   5. **中断返回：** 执行完中断服务例程后，CPU 返回到被中断的程序，继续执行。

   外部中断（键鼠等），内部中断（缺页，除0等），软中断（系统调用）

4. **内存映射和共享内存**

   **内存映射：**

   1. **映射方式：** 内存映射是将文件或其他对象映射到进程的地址空间，使得这些对象可以像内存一样被访问。这包括**文件映射**和**匿名映射**。
   2. **文件映射：** 主要用于将文件映射到内存，这样可以直接在内存中读取或写入文件数据，而无需通过传统的文件 I/O 操作。
   3. **匿名映射：** 创建一个与文件无关的映射，可以用于进程间通信或创建共享的内存区域。
   4. **使用场景：** 内存映射通常用于处理文件、数据库等大型数据集，或者用于多进程之间的通信。

   **共享内存：**

   1. **共享方式：** 共享内存是通过在不同的进程之间创建共享的内存区域，使得这些进程可以直接访问共享的内存段，而无需通过中间介质。
   2. **通信方式：** 共享内存主要用于进程间通信，允许多个进程之间快速、高效地共享数据。进程可以读取和写入共享内存中的数据，实现数据的共享。
   3. **使用场景：** 共享内存通常用于需要频繁交换大量数据的进程之间，以提高性能和效率。

   **区别总结：**

   1. **映射对象：** 内存映射主要涉及将文件或其他对象映射到进程的地址空间，而共享内存是直接在不同进程之间创建共享的内存区域。
   2. **用途：** 内存映射通常用于处理文件、数据库等数据集，而共享内存用于进程间通信，特别是需要频繁交换大量数据的情况。
   3. **实现机制：** 内存映射可以是文件映射或匿名映射，而共享内存是直接创建一块共享的内存区域。

5. **为啥要用虚拟内存，怎么实现？**

   虚拟内存通过内存和磁盘之间的映射，虚拟出来更大的内存空间，实现了隔离和保护机制。

   虚拟内存实现是基于分页或者分段实现，分页是将内存和磁盘分成大小相等的块，通过页面调度算法对页面进行换入和换出。通过页表对虚拟地址和逻辑地址的映射。分段是根据逻辑将进程分为数据段、代码段等，分配更灵活。

6. **自旋锁和互斥锁有什么区别？分别适合什么场景？**

   **自旋锁:**一种忙等待的锁,获取不到锁会CPU一直循环获取。适用于短时间内锁被占用的情况，并且并发量不大的情况，或者多CPU的情况。

   **互斥锁：**一种阻塞锁，获取不到锁会阻塞直到锁可用。互斥锁适用于长时间内锁被占用的情况，并发量大，或者单CPU的情况。

7. **为什么要设计内核态、用户态两种状态**，**怎么切换的**
        两种运行模式，应着不同的特权级和资源访问权限，用户态是普通的用户进程运行的模式，它只能访问有限的资源，比如用户空间的内存，用户栈，用户程序等。内核态是操作系统内核程序运行的模式，它可以访问所有的资源，比如内核空间的内存，内核栈，硬件设备，系统调用等。

   **安全性：** 分离内核态和用户态可以防止用户程序直接对系统资源进行不受控制的访问，从而提高系统的安全性。

   **资源隔离：** 通过将系统划分为内核态和用户态，可以实现资源的隔离，使得一个程序的错误不会直接影响其他程序和整个系统。

   **切换方式：系统调用（操作系统开放的调用接口）、异常、外设中断**

8. **线程同步**

   ​		在多线程编程中，确保多个线程按照一定的**顺序和协调执行**，以避免并发访问共享资源时可能引发的问题，如**数据竞争**、**死锁**等。线程同步的目标是保证程序的**正确性和稳定性**。

   **互斥锁（Mutex）**、**信号量（Semaphore）**、**条件变量（Condition Variable）**、**读写锁（Read-Write Lock）**、**原子操作（Atomic Operation）**

   

9. **说一下缺页中断**

   缺页中断（Page Fault）是计算机操作系统中的一种异常情况，发生在程序试图访问尚未调入内存的页面时。当程序**访问的页面不在主内存中**，操作系统会触发缺页中断，以便将相应的**页面调入内存**，然后重新执行导致缺页的指令。

   1. **访问缺页：** 当程序试图访问一个尚未在主内存中的页面时，例如由于页面被换出到磁盘或者是首次访问的页面，CPU会产生一个缺页异常。
   2. **触发中断：** 缺页异常导致CPU暂停当前执行的程序，并向操作系统发出一个中断请求，即缺页中断。
   3. **操作系统处理：** 操作系统的缺页中断处理程序被调用。该处理程序的任务是将所需的页面从磁盘或其他辅助存储器加载到主内存中。
   4. **更新页表：** 一旦页面被加载到主内存，操作系统更新页表，以便将虚拟地址与物理地址进行映射。
   5. **重新执行指令：** 缺页中断处理完毕后，CPU重新执行导致缺页的指令，这次访问将成功，因为所需的页面现在已经在主内存中了。

10. **介绍一下父子进程**

    父子进程是指在一个进程的基础上创建出另一个**独立的进程**，这个新进程就是子进程，原来的进程就是父进程。

    子进程是**父进程的副本**，拷贝了父进程的**数据空间、堆和栈**，但**不共享**这些资源，只**共享代码段**。
    子进程从父进程调用fork函数的下一条指令开始执行，fork函数在父子进程中返回不同的值，父进程返回子进程的PID，子进程返回0。
    父子进程各**自独立运行**，互不影响，但可以通过信号或管道等方式进行通信。
    父进程可以通过wait或waitpid函数**等待子进程的结束**，并**回收子进程的资源**，防止出现僵尸进程。
    如果父进程先于子进程结束，子进程会成为孤儿进程，由**init进程**接管并回收。

11. **页面置换算法有哪些**

    **最佳置换法(OPT)**：最理想的算法，每次选择以后最长时间不用的。无法实现。

    **先进先出置换算法(FIFO)**：淘汰的页面是最早进入内存的页面 ，用队列实现，可能出现Belady异常，物理块数增大时，缺页次数不减反增的异常现象。

    **最近最久未使用置换算法(LRU)**：淘汰最近最久未使用的页面 ，算法性能好，但是实现困难，开销大。

    **时钟置换算法(CLOCK)**：利用每个页面的访问位来记录其是否被访问过。它把所有的页面组织成一个环形链表，并维护一个指针指向最老的页面。当发生缺页中断时，它检查指针所指的**页面的访问位**，如果为0，就**淘汰该页面**；如果为1，就把**该位清零**，并把**指针后移一位**，直到找到一个**访问位为0**的页面。它的实现比较简单，但是可能会淘汰一些刚刚被访问过的页面

12. **如何实现读写锁，以及读写优先级**

    **基于信号量：**使用一个值记录读者数量，以及个信号量。一个信号量用与保护更新读者数量的互斥。另一个信号量，用于读写锁的互斥操作。

    ​	对于获取读锁，首先获取数量互斥锁，然后获取读写互斥锁，如果获取到，将读数量加一。读取完释放数量互斥锁，以及读写互斥锁。

    ​	对于写锁，直接获取读写互斥锁就行。

    **基于原子操作和自旋等待：**使用一个原子变量表示锁的状态，其中高位表示读者的数量，低位表示写者的标志。当一个线程想要获取读锁时，需要先检查是否有写者正在执行或等待，如果有，就自旋等待，否则就使用原子操作将高位加1，表示增加一个读者。当一个线程想要获取写锁时，需要先检查是否有读者或写者正在执行，如果有，就自旋等待，否则就使用原子操作将低位设置为1，表示设置一个写者。当一个线程释放读锁时，需要使用原子操作将高位减1，表示减少一个读者。当一个线程释放写锁时，需要使用原子操作将低位清零，表示清除一个写者


- 读者优先：当有读者请求读锁时，如果没有写者正在执行或等待，就立即给予读锁，否则就等待写者完成。这样可以提高读者的并发性，但可能导致写者饥饿。
- 写者优先：当有写者请求写锁时，如果没有读者或写者正在执行，就立即给予写锁，否则就等待读者或写者完成。这样可以提高写者的响应性，但可能导致读者饥饿。
- 读者-写者公平：当有读者或写者请求锁时，按照先来先服务的原则，给予锁。这样可以保证读者和写者之间的公平性，但可能降低读者的并发性。



13. **介绍一下死锁，怎么解决？**

    ​	死锁是指两个**（多个）线程相互等待对方数据的过程**，死锁的产生会**导致程序卡死**，不解锁程序将永远无法进行下去。

​			**四个原因：**

​				**互斥条件：**进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。

​				**不剥夺条件：**进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。

​				**请求和保持条件：**进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。

​				**循环等待条件：**存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

​		**解决方法：**

​				**鸵鸟策略**：解决死锁问题的代价很高，不采取任何措施。

​				**死锁检测与死锁恢复：**检测是否有死锁发生，恢复有3种，利用抢占式恢复、回滚恢复、杀死进程。

​				**死锁预防**：破环四个死锁的必要条件

​				**死锁避免：**采用银行家算法

14. **进程线程通信**有什么不同

    进程间的通信需要借助操作系统提供的**IPC机制**，如**管道、消息队列、信号量、信号、共享内存**等；
    线程间的通信可以**直接访问共享变量**，如**全局变量、静态变量**等，但需要注意同步和互斥的问题，也可以使用**信号量、事件**等机制

















## 三.计算机网络篇

1. **介绍一下OSI七层协议，各层协议都有哪些**

   1. **物理层（Physical Layer）：**
      - 功能：传输比特流，主要关注物理介质、电流、编码等。
      - 协议：没有特定的协议，主要涉及硬件标准（如Ethernet、Wi-Fi等）。
   2. **数据链路层（Data Link Layer）：**
      - 功能：负责将比特流组织成帧，进行错误检测和纠正。
      - 协议：ARP（Address Resolution Protocol）等。
   3. **网络层（Network Layer）：**

      - 功能：负责在不同网络之间进行路由和转发，实现端到端的数据传输。
      - 协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等。
   4. **传输层（Transport Layer）：**
      - 功能：提供端到端的通信，负责数据的可靠性、流量控制和错误恢复。
      - 协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。
   5. **会话层（Session Layer）：**

      - 功能：管理和协调会话，确保数据传输的正确顺序。
      - 协议：NetBIOS（Network Basic Input/Output System）等。
   6. **表示层（Presentation Layer）：**

      - 功能：处理数据的表示和格式，确保应用层能够解释数据。
      - 协议：JPEG、GIF、SSL/TLS（Secure Sockets Layer/Transport Layer Security）等。
   7. **应用层（Application Layer）：**

      - 功能：为用户提供网络服务，是网络应用程序的接口。
      - 协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、DNS（Domain Name System）等。
   
1. **介绍一下TCP/IP的四层模型**

   - **应用层：**这一层是直接为应用进程提供服务的，它包含了各种不同的应用协议，如HTTP、FTP、SMTP、DNS等。应用层的协议可以实现数据的格式化、加密、压缩等功能，以及与其他节点的联系的建立和解除。
   - **传输层：**这一层是为上层应用提供可靠或者高效的数据传输的，它包含了两个主要的协议：TCP和UDP。TCP协议可以保证数据的可靠传输，通过分段、重传、流量控制、拥塞控制等机制，实现端到端的连接和数据交换。UDP协议则是一种无连接的、简单的协议，它只负责将数据报发送给目的端，不保证数据的可靠性和顺序，但是速度较快，适合一些实时性要求高的应用。
   - **网络层：**这一层是负责在不同的网络之间进行数据包的传送的，它包含了IP协议和相关的协议，如ICMP、IGMP等。IP协议是实现**网络互连的核心协议**，它定义了网络地址的格式和分配，以及**路由选择的方法**。IP协议只负责将数据包发送到目的网络，不保证数据包的可靠传输。ICMP协议是用于传递网络控制信息的协议，如错误报告、路由重定向、回显请求等。IGMP协议是用于管理多播组的协议，它可以让主机加入或退出一个多播组，以接收或停止接收多播数据。
   - **网络接口层：**这一层是负责将数字信号在物理通道中准确传输的，它包含了数据链路层和物理层的功能。数据链路层负责在**相邻的节点之间建立逻辑连接，进行物理寻址**，以及错误检测和恢复。物理层负责在物理媒介上进行数据的编码、调制、发送和接收，以及同步等功能。
   
2. **输入一个网页，到出现页面，这中间发送了什么？**

   - 域名解析DNS
   - 发起TCP的3次握手
   - 建立TCP连接后发起http请求（https的话需要建立安全的会话层进行SSL/TLS握手）
   - 服务器响应http请求，浏览器得到html代码
   - 浏览器解析html代码，并请求html代码中的资源
   - 浏览器对页面进行渲染呈现给用户。
   
2. **假设浏览器访问网址，这四层分别会发生什么事情呢**

   **应用层：**构造一个**HTTP请求报文**，需要向**DNS服务器发送查询请求**，得到**IP地址**后，浏览器就可以通过**传输层的接口**将HTTP请求报文发送出去。
   **传输层：**与服务器**建立TCP连接**。TCP连接的建立需要经过**三次握手**的过程，交给网络层进行传输。
   **网络层：**封装成IP数据报，**加上源IP地址**和**目的IP地址**等信息，然后根据**路由表**选择**合适的路径**，将IP数据报转发给下一跳的路由器或目的端。
   **网络接口层：**网络接口层负责**将IP数据报转换成适合物理媒介的数据帧**，加上源**MAC地址**和目的MAC地址等信息，然后通过**物理层的接口发送出去**。在发送的过程中，可能需要进行**ARP查询**，即根据目的IP地址获取目的**MAC地址**，如果本地缓存中没有，就需要向本地网络广播ARP请求，得到ARP响应后，就可以将MAC地址写入数据帧。在接收的过程中，需要进行**CRC校验**，检查数据帧是否有错误，如果有错误，就丢弃数据帧，如果没有错误，就将数据帧交给网络层进行处理 。
   
3. **TCP三次握手**

   1. **客户端发起连接请求：**
      
      - 客户端首先向服务器发送一个TCP报文，其中设置了SYN（同步）标志位，并选择一个初始序列号（ClientISN）。
   2. **服务器确认连接请求并发起连接：**
      - 服务器收到客户端的SYN报文后，会发送一个带有SYN和ACK（确认）标志位的TCP报文作为响应。
      - 服务器也会选择一个自己的初始序列号（ServerISN），并在ACK字段中确认客户端的初始序列号（ClientISN + 1）。
      - 同时服务器会将第二次握手的客户端加入到半连接队列。
   3. **客户端确认连接：**
      - 客户端收到服务器的响应后，向服务器发送一个带有ACK标志位的TCP报文，确认服务器的初始序列号（ServerISN + 1）。
      - 第三次握手可以数据
        
        

4. **为什么TCP三次握手，两次握手可以吗**

   三次握手是为了确保双方都有发送和接收数据的能力。两次握手不可以，第三次握手是为了防止历史失效连接再次请求，导致资源浪费。

5. **TCP四次挥手**

   1. **主动关闭方发送连接释放报文（FIN）：**
      - 主动关闭方（一般是客户端）首先发送一个TCP报文，其中设置了FIN标志位，表示它已经完成发送数据，希望关闭连接。表示已经没有数据要发送了。
      - 这个FIN报文中还包含一个序列号，用于标识主动关闭方的数据已经发送完毕的位置。

   2. **被动关闭方确认收到释放报文：**
      - 被动关闭方（一般是服务器）收到主动关闭方的FIN报文后，会向主动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了主动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认主动关闭方的序列号。

   3. **被动关闭方发送连接释放报文（FIN）：**
      - 被动关闭方在完成了自己的数据发送后，也会发送一个TCP报文，其中设置了FIN标志位，表示它希望关闭连接。
      - 这个FIN报文中也包含一个序列号，用于标识被动关闭方的数据已经发送完毕的位置。

   4. **主动关闭方确认收到释放报文：**
      - 主动关闭方收到被动关闭方的FIN报文后，向被动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了被动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认被动关闭方的序列号。

   5. **四次挥手的2MSL有什么用**

      ​	等戴2MSL作用防止历史报文发送到服务器产生混乱。也能让服务端正确关闭（若服务器迟迟没有收到第四次报文，会重发第三次报文）。

6. **TCP和UDP的区别，什么时候用tcp什么时候用udp？**

   **TCP：**面向连接一对一，可靠通信、字节流、有流量控制以及拥塞控制。

   **UDP**：无连接、不可靠、低延迟、可以一对多。

   对于文件完整性和可靠性有要求用TCP，如文件传输等等。对于时间要求使用UDP，如视频通话，游戏等等。

   

7. **udp丢包会有什么现象？**

   **数据丢失**

   **乱序**

   **延迟变化**

   

8. **http和https的区别**

   都是用于在网络上传输数据的协议，它们之间的主要区别在于安全性和加密。

   - **HTTP：** 传输的数据是明文的，不经过加密处理。
   - **HTTPS：** 使用SSL/TLS协议对数据进行加密，确保传输的数据在网络上是安全的。

   

9. **滑动窗口-流量控制作用**

   ​		用于流量控制。发送方和接收方都维护一个滑动窗口，表示可以发送或接收的数据帧的范围。发送方通过滑动窗口的机制动态调整发送的数据量，以保证在网络状况允许的情况下提高传输速度。

   

10. **拥塞控制**

    拥塞控制通过监测网络中的拥塞情况，采取一系列策略来调整数据流的速率，以避免网络过载。慢启动、拥塞避免、快速重传、快速恢复等。

    

11. **流量控制和拥塞控制差异**

    滑动窗口主要关注单个通信连接的数据流控制，而拥塞控制关注整个网络中的拥塞情况。

    

12. **服务端的socket接收缓冲区只剩10个字节，但是客户端发过来一个未经过分片的12个字节的报文。之后客户端和服务端分别会发生什么事情？如果服务端的接收窗口变为0会怎么样？**（看）

    ​		这个问题的答案可能取决于具体的**网络协议和阻塞模式**，但一般来说，可以参考以下的情况：

    ​		**TCP协议**，那么客户端发送的报文会被分片为两个TCP段，每个段的大小为6个字节。服务端会接收到第一个段，并将其存入接收缓冲区，然后向客户端发送一个ACK，表示已经收到了6个字节的数据。但是由于服务端的接收缓冲区已经满了，无法接收更多的数据，所以**服务端会丢弃第二段报文**，并向**客户端发送一个窗口大小为0的通知**，表示**暂时不能接收数据**。客户端收到窗口大小为0的通知后，**会停止发送数据**，并启动**重传定时器，等待服务端的窗口大小变大**。服务端在读取了接收缓冲区中的数据后，**会向客户端发送一个新的窗口大小**，表示可以接收数据了。
    ​	**UDP协议**，那么客户端发送的报文不会被分片，而是作为一个整体的UDP数据报发送出去。服务端会接收到这个数据报，但是由于接收缓冲区只有10个字节的空间，无法存放12个字节的数据，所以**服务端会丢弃这个数据报**，并向**客户端发送一个ICMP差错报文**，表示**目的地不可达**。客户端收到这个差错报文后，会知道数据没有被成功发送，但是**UDP协议并不提供重传机制**，所以客户端需要自己决定是否重新发送数据。服务端在读取了接收缓冲区中的其他数据后，会释放出空间，但是并不会主动通知客户端，所以客户端需要自己判断何时可以重新发送数据。

    

13. **TCP的keep-alive和HTTP的keep-alive有什么区别？**

    **TCP Keep-Alive：**于在长时间没有数据传输时保持 TCP 连接的活跃状态，以防止连接因为长时间的空闲而被中断。周期性地向对方发送一个小的探测包（Probe）来实现的。如果一定时间内没有收到对方的响应，就会认为连接已经失效，然后关闭连接。

    **HTTP 的 Keep-Alive：**用于在**一次 TCP 连接上发送多个 HTTP 请求**，而不是每次请求都建立一个新的 TCP 连接。这可以减少连接建立和断开的开销，提高性能。
    
14. **udp不需要建立连接，那是不是所有人都可以向我发送数据**

​		由于UDP不涉及连接的建立和维护，发送方可以随时向接收方发送数据，而不需要进行握手等步骤。但是在应用层可以，使用加密来确保数据的机密性，或者使用其他手段验证数据的来源。

17. **网络IP地址转化流程，外网IP和内网IP是怎么转换的**

​		主要涉及到一种技术叫做**NAT（网络地址转换）**。NAT的作用是在内部网络和外部网络之间实现IP地址的转换，从而**节省公网IP地址资源**，提高网络安全性，以及解决不同网络之间的互联问题。

​		NAT的基本原理是，当**内网的主机**想要**访问外网**的时候，由**NAT设备**（通常是**路由器**（需要支持NAT的路由器设备）或防火墙）将**内网的私有IP地址转换为公网的IP地址**，并记录下转换的映射关系，然后将数据包发送给外网的目的主机。当外网的主机回复数据包的时候，由**NAT设备根据映射关系**，将公网的IP地址转换回内网的私有IP地址，并将数据包转发给内网的源主机。这样，内网的主机就可以通过一个或少量的公网IP地址与外网进行通信。

18. **ICMP协议介绍**

    主要用于网络设备之间**诊断网络通信问题**。ICMP可以用于确定数据**是否及时到达目的**地，以及**报告可能发生的错误**。

    ICMP的主要用途有两个：

    **错误报告：**当两个设备通过互联网连接时，如果**数据没有到达目的地**，ICMP会生成**错误消息**并发送给源设备。例如，如果一个数据包对于一个路由器来说太大，路由器会丢弃该数据包，并向源设备发送一个ICMP消息。
    **网络诊断：**常用的终端工具**traceroute和ping**都是利用ICMP实现的。traceroute工具用于显示两个互联网设备之间的**路由路径**，即数据包经过的路由器的物理路径。每经过一个路由器就称为一个“跳跃”，traceroute还会报告**每个跳跃所需的时间**。这对于确定网络延迟的原因很有用。ping工具是traceroute的简化版本，它用于**测试两个设备之间的连接速度**，并报告数据包到达目的地并返回源设备所需的时间。虽然ping不提供关于路由或跳跃的数据，但它仍然是衡量两个设备之间的延迟的一个很有用的指标。ICMP的回显请求和回显应答消息通常用于执行ping。

    



19. tim**ewait，closewait状态原因** 

    **TIME_WAIT 状态：**

    - **原因：** **主动关闭连接**一方**第四次**挥手后，连接会进入 `TIME_WAIT` 状态。在这个状态中，系统会等待**两倍的最大报文段寿命**（Maximum Segment Lifetime，MSL）时间，以确保远程端已经接收到关闭连接的通知，避免可能残留在网络中的延迟报文对新连接产生干扰。

    **CLOSE_WAIT 状态：**

    - **原因：** 被动关闭端第二次挥手后，即该端已经接收到对方发来的连接关闭请求，并已经发送了确认，但可能仍然有数据需要发送。

    ![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

20. **服务器有很多closewait状态是什么原因** 

    服务器程序迟迟没有对连接进行关闭操作。

​		









## 四.算法数据结构篇

1. **DFS以及BFS的应用场景都有哪些？**

   两者都可以用: 图以及树的遍历、迷宫问题


   DFS:  回溯

   BFS: 最短路径、树的层序遍历



2. **红黑树性质**

   红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，通过一系列规则确保树的高度平衡，从而保持较为稳定的搜索、插入和删除性能。红黑树得名于节点上的颜色标记，每个节点都带有一个颜色属性，可以是红色或黑色。

   红黑树的性质包括以下五点：

   1. **节点颜色：** 每个节点要么是红色，要么是黑色。

   2. **根节点：** 根节点是黑色的。

   3. **叶子节点：** 叶子节点（NIL 或空节点）是黑色的。

   4. **相邻节点：** 相邻的两个节点不能同时为红色，即红色节点不能连续出现。

   5. **路径黑色节点数：** 对于树中的任意一条路径，从根节点到叶子节点经过的黑色节点数目相同。

      

3. **回溯的时间复杂度**

   ​	回溯本质就是暴力搜索，如果解空间为N，时间复杂度为N^2

   

4. **小顶堆取出顶部元素之后，下面的元素怎么更新？**

   在小顶堆中，当取出堆顶元素后，为了保持堆的性质，需要进行**堆的调整**，通常是将堆的最后一个元素移动到堆顶，然后通过一系列比较和交换操作，将其下沉到正确的位置，以满足小顶堆的性质。

5. **哈希表，unordered_map，遇到冲突怎么办，分析一下时间复杂度**

   ​	它通过将关键字映射到表中的位置来实现快速的数据检索。哈希表通常用于实现集合、映射或关联数组等数据结构。

   ​	**链地址法（Separate Chaining）**：当发生冲突时，新键被追加到对应的链表上。

   ​	**开放寻址法（Open Addressing）**：当发生冲突时，会尝试寻找另一个空的哈希桶，直到找到一个空的位置为止。这可以通过线性探测、二次探测、双重散列等方法来实现。

   ​	**再哈希（Rehashing）**：当哈希表的负载因子（**已存储元素数量与哈希桶数量的比率**）过高时，可以选择重新调整哈希表的大小，增加桶的数量，并重新哈希所有的键值对。这样可以减少冲突的概率。

   

   **查找（Search）：**

   - 最坏情况：O(n)，当所有的键都散列到同一个桶上形成链表。
   - 平均情况：O(1 + α)，α 是负载因子，表示平均每个桶中的元素数量。

6. **动态规划、贪心和搜索这三个的区别**

   **动态规划：**动态规划将原问题拆解为子问题，要求子问题相互独立。

   **贪心**：局部最优可以推导出全局最优。

   **搜索：**需要遍历所有状态进行搜索。深搜、广搜、回溯。

7. **搜索的剪枝是什么呢**

   **减少搜索空间**以提高搜索效率。**排除**那些在问题的**解空间中没有意义**或**不可能包含最优解的部分**，从而缩小搜索范围，减少搜索时间。

8. **字典树，时间复杂度**

   一种**树形数据结构**（一棵多叉树），每个节点代表字符串的一个字符，用于**高效地存储**和检索**大量字符串**集合。主要优点在于它提供了高效的**字符串搜索和插入操作**，尤其适用于需要**快速查找**、**匹配和前缀匹**配的应用场景。
   **插入操作的复杂度：**假设字符串的平均长度为O*(*L)。

   

9. **游戏战力排行榜榜单用什么数据结构存储比较好** 
   **vector 的快排方法O(n):** 原来的数据已经有序，只需插入新的数据使得（左边小于右边大于），于是就自动有序了。

   **堆**O(n)：建立堆log(n)，遍历堆O(n)。

   **map红黑树:**同上

10. 

11. 

## 五.数据库篇

1. **MySQL索引底层数据结构，为啥不用二叉树，B树或者哈希表？**

   **B+数。**多路平衡二叉树。叶子节点使用双向循环链表串联，方便遍历。

   **为啥不用二叉树：**二叉树分裂节点只有2，数据多的话会导致数的层数很深，需要增加访问磁盘的次数。

   **为啥不用B树：**B数每个非叶子节点存储了数据（或者指针），会导致相同大小非叶子存储分裂个数减少，会增加数的层数。并且对于范围搜索没有B+树方便。

   **为啥不用哈希表：**哈希表一般基于内存，访问比较快。但是不支持范围查询。

   

2. **mysql为什么用可重复读而不用串行读、已提交读？**

   串行读：**性能与并发性会降低**、**锁的粒度会更小，性能开销大**

   已提交读：已提交读不能避免**不可重复读**的问题。确保不了数据一致性。

   

3. **MySQL的order by和group by会走索引吗？**

   取决于排序的字段是否有索引，如果包含函数、表达式或非索引列时，MySQL 可能无法使用索引来进行排序，导致全表扫描。

4. **说一下数据库事务**

   

   

   

   

   

   
   
   

## 六.设计模式篇

1**.单例模式**

（见）八股https://space.jace.asia/docs/Cpp/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F

​	单例模式就是在这个单例类确保**只有一个对象被创建**。也就是说这个类只能实例化一个对象。避免资源的重复占用。数据库连接池、内存池等。

​	**饿汉模式：**线程安全，静态成员函数，程序执行前创建。

​	**懒汉模式**：可能不是线程安全，第一次调用创建。需要判空-加锁-判空创建。或者C++11机制，局部静态变量是线程安全的。



2.**工厂模式**

（见）八股https://space.jace.asia/docs/Cpp/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F

将类的创建和执行分离开来，减少代码耦合。

**简单工厂：**通过工厂类，返回父类指针，指向的创建传入参数对应的创建的子类。

**工厂方法：**每个把工厂类抽象出来，实现对应的产品类的接口。用于类接口不同的创建。

**抽象工厂：**抽象工厂模式把一个**产品簇的产品**放在一个**工厂类中去创建**，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。

## 七.网络服务器篇

1. **proactor和reactor模式**

   "Reactor" 和 "Proactor" ，通常用于描述事件驱动编程中的不同策略。它们分别表示了两种不同的并发模型。

   ​	**Reactor 模式：**

   ​		Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个单独的事件分发器（Dispatcher）负责监听和接受连接（通常称为 Reactor 线程），当有事件发生时，分发器将事件分发给相应的处理器（Handlers）进行处理。

   **Proactor 模式：**

   - Proactor 也是一种处理并发 I/O 操作的并发模型，与 Reactor 不同，Proactor 更加关注异步处理。

   - Proactor 负责启动异步操作，监听这些操作的完成，并在操作完成时通知相应的 Handler。

   - Proactor 模式更适合高并发环境，因为它允许应用程序继续执行其他任务，而不必等待 I/O 操作完成。

     

2. **五种IO模型**
   **阻塞（阻塞等待数据）、非阻塞（立即返回，但是得循环读取）、IO多路复用（select、poll、epoll的区别）、信号驱动（复杂）、异步**
   **信号驱动：**信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。
   **异步**：数据准备和数据读取部分都是不阻塞的，当有数据来，直接处理好通知应用程序去读

   

3. **阻塞、非阻塞、同步、异步的区别**
   网络IO有数据准备和数据读取两个部分。阻塞、非阻塞发生在数据准备部分，区别为数据没准备好时能否立即返回。同步异步为数据准备好了通知应用程序的方式，同步为等待操作完成才能进行下一步操作，异步为不需要等待操作完成，而是继续执行其他任务，当执行完之后操作系统会通知程序。

   

4. **epoll是同步还是异步的？**

   IO层面，epoll是同步的。从消息处理层面，epoll是异步的。

   

5. **线程池数量如何确定？**

   - 任务是否是 CPU 密集型（计算密集型）还是 I/O 密集型（例如，网络请求、文件操作）？
   - 如果是 CPU 密集型任务，线程池的大小通常设置为 **CPU 核心数**。
   - 如果是 I/O 密集型任务，可以使用更多的线程，因为线程在等待 I/O 操作完成时可以执行其他任务。

​		

6. **IO多路复用**

   **select：**把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。

   ​			缺点：1.fd set大小有限制。2.fd数组拷贝到了内核态仍然有开销 3.select并没有通知用户态哪一个socket有数据，需要用户遍历。

   **poll**：是select的改进版，但是性能提升不明显，将fd set换成链表。select中的两个缺点还是存在。监听FD越多，每次遍历消耗时间也越久，性能反而会下降。

   **epoll：**epoll底层是通过红黑树实现，增删节点只需要logn的时间复杂度。epoll内核中维护了一个**内核事件表**，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发**回调**，无需手动遍历。通过**共享内存**的方式，无需重复拷贝FD到内核空间。

   epoll主要函数：epoll_create , epoll_ctl , epoll_wait 

   **LT和ET模式**

   

7. **Reactor模式的单线程模型了解吗，介绍一下？有哪些常见的系统或者服务器用了这个**
   Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个事件分发器负责监听和接受连接（通常称为 Reactor 线程），而其他的操作（如读写数据、处理业务逻辑）由对应的业务处理完成。但是单线程在处理业务时候无法处理其他连接，容易遇到性能瓶颈。

   实现方式：

   1. **事件注册：** 应用程序将事件（例如，socket 的读写事件）注册到 Reactor 中。
   2. **事件监听：** Reactor 线程负责监听注册的事件。这个调用通常会阻塞，等待有事件发生时才会返回。
   3. **事件分发：** 当有事件发生时，Reactor 线程会触发事件分发，将事件分发给相应的事件处理器（Handler）。
   4. **事件处理：**事件处理器负责具体的事件处理，包括读写数据、业务逻辑的执行等。这些操作在一个单线程中依次执行。

   

   **Redis，Nginx**：因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上

   
   
8. **怎么实现异步，有哪些应用场景和函数？**

   异步编程是一种并发编程的方式，允许程序在等待某些操作完成的同时执行其他操作。

   实现方式：回调函数 ，当完成一个异步操作后执行对应的回调函数

   应用场景：网络编程、并发编程、文件IO等

   

9. **服务器有一个连接进来，到应用程序读取到数据，需要经过几次内核态/用户态切换？需要几次缓冲区数据的拷贝？**

   ​		从网卡到应用程序，一般需要经过**两次内核态/用户态切换**，**三次缓冲区数据的拷贝**。当然，这个过程还可以通过一些技术来优化，如**零拷贝**等。

   1.当网卡收到数据包后，会触发一个硬件中断，这是第一次内核态/用户态切换。

   2.将数据包从网卡缓冲区拷贝到内核空间的缓冲区，这是第一次缓冲区数据的拷贝。

   3.内核会将数据包从内核空间的缓冲区拷贝到用户空间的socket对应的接收队列。这是第二次缓冲区数据的拷贝。

   4.内核会通知用户进程有新的数据到达，用户进程可以通过read()或者recv()等函数从socket的接收队列中读取数据。这是第二次内核态/用户态切换，也是第三次缓冲区数据的拷贝。

   

10. **介绍一下零拷贝**

    零拷贝（Zero Copy）是一种读写优化技术，旨在减少数据在系统内部的复制操作，提高数据传输的效率。在零拷贝中，数据可以在不涉及用户态和内核态之间的拷贝的情况下在系统内部传递。

    零拷贝的实现方式有多种，常见的有以下几种：

    **内存映射：**利用虚拟内存的特性，将**内核缓冲区**和**用户缓冲区**映射到同一个**物理地址**，从而省去一次CPU拷贝。

    **sendfile：**利用内核提供的sendfile系统调用，将文件数据直接从**内核缓冲区**传输到**socket缓冲区**。

    **DMA：DMA控制器**将数据从内核缓冲区拷贝到**网卡设备**，从而省去一次CPU拷贝。DMA（Direct Memory Access，直接内存访问）是一种计算机系统中的**数据传输技术**，旨在减轻中央处理器（CPU）对内存访问和数据传输的负担。DMA 允许**外围设备直接访问系统内存**，而**无需 CPU 的直接参与**。这样可以提高数据传输的效率，减少 CPU 的占用率，同时允许 CPU 在数据传输过程中执行其他任务。

    

11. **缓存的作用**

    **提高性能：**通过缓存数据，处理器不必等待慢速设备（如磁盘或网络）传输数据，从而允许它继续执行其他任务。

    **平衡处理速度不匹配：**各个组件的处理速度可能不匹配。CPU 处理速度通常比磁盘或网络传输速度快得多。通过使用缓冲区，可以平衡这种速度不匹配。

    

12. **epoll函数参数** 

    ```cpp
    int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
    ```

13. **搭建一个服务器需要做哪些工作？（socket api调用过程）** 

    创建套接字、绑定、监听、连接、读写数据

    

14. **长链接和短链接适用于哪些场景** 

    **长链接：**保持连接状态，适用于操作频繁、点对点的通信场景，例如**数据库连接**、**即时通讯**、**在线游戏**等。

    **短链接**：建立一次连接，任务结束就关闭。适用于**并发量大**、请求频率低的通信场景，例如**Web服务**、**电子商务**等。

15. 

## 八.linux篇

1. **Linux内存管理机制**

   1. **虚拟内存管理：**

      - Linux 使用虚拟内存来映射物理内存和磁盘空间，以提供更大的地址空间和更灵活的内存管理。
      - 虚拟内存通过页面（page）来进行管理，页面是内存和磁盘上的固定大小的块。

   2. **页面置换：**

      - 当系统内存不足时，Linux 会使用页面置换机制将不常用的页面从物理内存中置换到磁盘上，从而腾出空间供更紧急需要的页面使用。
      - 常见的页面置换算法包括最近最少使用（LRU）、时钟算法（Clock Algorithm）等。

   3. **内存压缩：**

      - 内存压缩是一种在内存不足时通过压缩内存页面来腾出空间的技术。

   4. **交换空间（Swap Space）：**

      - Linux 使用交换空间作为一种延伸内存的手段，将不活动的页面移动到交换空间中，从而腾出物理内存。

        

2. 

## 九.项目篇

1. 为什么要做这个项目？
2. 是**为了解决什么问题**？
3. 项目的性质是什么？
4. 有什么亮点？难点？
5. 运用了哪些技术?
6. 有什么收获？
7. Web服务器里怎么设计的IO复用
8. 是否有做压测
9. 请求是同时请求还是分开的
10. 你觉得现在一般大厂使用的支持百万千万并发的服务器与你这个项目是一个概念吗
11. 项目里用了线程池，线程池怎么建立起来的，为什么要用线程池
12. 那你从请求队列里取请求那不还是一个连接对应一个线程吗？
13. 然后就是各种解决问题的思路，难点，如何改进之类的了
14. Web服务器这个项目你用了线程池，线程池开多大的呢
15. 并发量你是怎么测试的
16. 怎么样进一步提高并发量呢
17. 为什么做一个web服务器，项目功能，改进点
18. 整个开发过程中有没有遇到困难，怎么解决的
19. 在实际场景中的效率或时间上的要求和提升嘛
20. 整个项目整个开发的一个环境是什么样的呢，实际环境以及算法运行下什么样的环境下
21. 能介绍一下在web服务器项目中做了什么样的测试和学习，有什么样的体会
22. 这个web服务器是运行在PC上还是嵌入式上
23. 比如说现在在多线程下调试会出现一些错误，可以说一下需要注意哪些地方，出错的原因一般在哪里
24. 多线程中出现的问题，一般通过什么途径进行debug呢
25. 在linux下还有进程，进程和线程有什么区别，为什么你选择采用线程
26. web服务器最主要的一个考量指标是并发处理能力，想问你为了提高并发量做了怎么样的操作



## 十.其余篇

1. **构成一个计算机需要什么，各个组件做什么工作？**

   1. **中央处理器（Central Processing Unit，CPU）：**
      - **功能：** 执行计算机程序中的指令。
      - **工作：** 从内存中获取指令，执行算术和逻辑操作，并控制其他硬件设备。

   2. **内存（Memory）：**
      - **功能：** 存储计算机程序和数据，供 CPU 快速访问。
      - **工作：** 包括随机访问存储器（RAM）和只读存储器（ROM），RAM 用于临时存储数据和程序，而 ROM 存储固化的不变的程序和数据。

   3. **存储设备（Storage Devices）：**
      - **功能：** 提供长期存储，用于保存操作系统、应用程序和用户数据。
      - **工作：** 包括硬盘驱动器（HDD）、固态硬盘（SSD）、光盘驱动器等。

   4. **输入输出设备**

      

2. **很多小文件（总量1T）想从一台主机传输到另外一台主机，保证速度的前提下设计一个方案**

   **打包压缩：** 将小文件打包成压缩文件，然后进行传输。这样可以减少传输的文件数量，降低文件系统开销和网络开销。
   **并行传输：** 利用并行传输的方式提高传输速度。可以将文件分成多个部分，并同时传输这些部分。

   

3. **设计一个函数，这个函数没有任何输入，每次执行这个函数就会返回一个INT64的值，要保证返回的值是全局唯一的，也就是之前没有输出过的，怎么操作？**

   定义全局静态变量。

   

4. **读一个大文件和读很多个小文件效率是一样的吗？假设小文件总量和大文件大小一致**
     读取大文件时，文件内容通常在磁盘上是连续存储的，因此磁盘寻址时间相对较小。相比之下，读取许多小文件可能导致文件系统随机读取，磁盘寻址时间可能会增加。

5. 

6. 

## 十一.HR面试篇

1. 有没有实习经历
2. 和导师做过什么项目
3. C++接触多长时间了
4. 做导师的项目是自己选择还是他分配的
5. 项目来源
6. 这两个项目哪个印象比较深刻，如果想聊我们聊哪个
7. 项目是自己完成还是团体参与，独立完成的时候有没有和其他同学讨论交流过
8. 在选择任务的技术路线时如何佐证你的方案是可行的
9. 组会讨论是什么形式，你期望的是什么样的反馈
10. 如果你的想法和大家的反馈有冲突怎么办
11. 当你的任务有做偏了的情况在哪一步去进行挽回
12. 别人给你的反馈不一定是正确的，你觉得自己的思路更好，这种情况怎么处理
13. 对于更具有权威性的人提出的建议你是怎么考虑的
14. 合作的项目彼此之间进度不一的情况怎么处理
15. 研究生规划
16. 你觉得自己是偏技术钻研方向还是偏向业务（社交、组织协调）
17. 工作城市的选择
18. 实习时间
19. 优势和不足的点
20. 项目大概做了多长时间
21. 对这个项目的时间周期满意吗
22. 面试表现:评价比较正面。
23. 如何评价自己？
24. 朋友同事如何评价自己？
25. 最自豪的事情？
26. 最大的优点？觉得自己有什么缺点？
27. 怎么选公司？
28. 跟别的候选人比有什么优势
29. 对云怎么理解
30. 工作中最自豪的事情
31. 工作中有没有遇到需要和别的组协调的工作
32. 怎么处理同事间的分歧
33. 介绍项目
34. 和同事领导的相处方式
35. 校园竞赛经历
36. 校园干部经历
37. 问最近一次的比赛，聊了比较久一个人工智能的竞赛，问到了深度学习里用了什么网络模型，自己做了什么贡献、如何更新模型，怎么开展的，识别出错怎么办，如果遇到恶意攻击怎么办（说了一个自己的方案）
38. 业余爱好，怎么拿的奖
39. 聊竞赛，所有的竞赛全部问了一遍，感觉是看竞赛中的参与程度
40. 你觉得你在这几轮面试中你的优势是什么，劣势是什么
41. 面试完之后会复盘吗
42. 为什么选择字节跳动
43. 说一下职业规划，看到简历偏后端一些，是否会并不喜欢客户端的方向呢？
44. 个人的优势与短板
45. 你说擅长团队协作是因为自己带队作为负责人参与了很多比赛吗
46. 说一下你带团队时会考虑哪些问题，一个团队的关键点是什么
47. 大概什么时间能够到岗，实习多久
48. 对于转正你有什么问题吗
49. 对于工作的城市有要求吗
50. 家里对于工作地点上有意见吗
51. 进入到字节跳动团队后，你希望从你的mentor得到哪些帮助
52. 当你遇到问题你会主动找他人问吗
53. 有过压力很大时候吗？
54. 是怎样克服这个压力
55. 还有其他公司在面试吗
56. 对于这边的团队有了解吗
57. 薪资问题，年总包期望多少
58. 其他offer情况，目前还在面试的原因
59. 怎么看待我们公司，你投递的这个岗位，之前有了解过我们公司吗
60. 有没有偏好的工作方向
61. 有没有参与什么竞赛
62. 英文自我介绍一下？
63. 如果发放offer，你有多大倾向来我们公司
64. 工作地点倾向
65. 你有华为的实习经历啊，实习的部门是哪个，四级部门呢
66. 实习的感受怎么样，能学到东西你觉得
67. 做的东西和你的兴趣相匹配嘛
68. 把实习阶段的工作稍微详细的介绍一下，工作内容，角色
69. 你在华为实习期间感受到华为的企业文化和价值观是什么
70. 你适应华为工作的强度嘛
71. 你是一个什么性格的人
72. 你自己觉得学习能力怎么样，举个例子，比如项目中有没有起过什么作用
73. 你的家乡在哪里
74. 在学校期间还担任过什么学生工作吗
75. 你的技能是偏软件一些是吗
76. 


# 面试问题总结

## 一.CPP篇

1. **const关键字？**

   **const 修饰基本类型数据类型：**表示类型为常量不可以修改

   加在**函数前**表示返回值为const，加在成员**函数后面**表示成员变量不可修改（在成员函数中）。

   **const 修饰指针变量和引⽤变量：**const在\*左侧为底层cost，表示指向那个变量不可改变。const在*右侧为顶层cost，表示指针本身为不可变。

   **const 成员变量**：表示对象中不可变，对于整个类可变。

   **const 修饰类对象**：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

   

2. **C++的内存结构**，**什么情况下使用堆区什么情况使用栈区**
   由高到底地址分别为：
   **栈区：**由编译器管理分配和回收，效率很高，但是分配的内存容量有限。存放局部变量和函数参数。
   **堆区:** 由程序员管理，需要⼿动分配和回收，空间较大但可能会出现内存泄漏和空闲碎⽚的情况。动态内存分配的时候使用。
   **全局/静态存储区:**存储初始化和未初始化的**全局变量**和**静态变量**。
   **常量区:**存储常量，⼀般不允许修改。
   **代码区:** 存放程序的⼆进制代码。

   

3. **动态链接库静态链接库特点、区别**

   **静态链接：**链接器在**链接时**将库的内容加入到可执行程序中。运行环境的依赖性较小，但是**生成的程序比较大**，**库函数有了更新，必须重新编译应用程序**

   **动态链接：**连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序**运行时**才将所需资源调入可执行程序。

   - 在需要的时候才会调入对应的资源函数

   - 简化程序的升级；有着较小的程序体积

   - 实现进程之间的资源共享（避免重复拷贝）

   - 依赖动态库，不能独立运行

   - 动态库依赖版本问题严重

     

4. **static关键字作用**

   在**全局变量**或者**普通函数**上改变作用域为当前文件可以访问。

   在**局部变量**上，改变局部变量生命周期为程序结束，并且只初始化一次。

   在类中**成员变量**上，所有对象共享同一份变量，可以通过类名访问，初始化必须在类外。

   **static成员函数**，可以通过类名访问，不含this指针，只能操作对应的static成员变量。

   

5. **面向对象三大特性**

   **封装：**将（成员变量）和（成员函数）打包在一个单元中，形成一个类。封装提供了对类内部实现的隐藏，并提供访问权限，使得代码更加模块化和可维护。

   **继承：**一个类（子类或派生类）可以使用另一个类（父类或基类）的属性和行为，并且可以扩展或修改它们。

   **多态：**多态是指同一个接口可以被用于不同的数据类型。父类指针可以指向不同的子类对象。
   多态分为（静态多态）和（动态多态）。

   静态多态通过**函数重载**和**运算符重**载来实现的，允许一个接口有多个不同的实现，这称为静态绑定。

   动态多态是通过**虚函数**和**抽象类**实现的。在运行时，同一个函数调用可能会**根据对象的实际类型**执行不同的代码，这称为动态绑定。

6. **虚函数相关（虚函数表，虚函数指针），虚函数的实现原理**

   ​	基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。

   类中包含虚函数时，编译器会为该类⽣成⼀个**虚函数表**（数组），保存该类中**虚函数的地址**（编译期 - 在静态全局区）。定义⼀个派⽣类对 象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个**虚函数指针**，指向该类型的虚函数表，这个虚函数指针的**初始化**是在**构造函数中完成的**。后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻 找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。函数地址的晚绑定。

   

7. **函数调用的过程中堆栈的变化情况**

   - 当一个函数被调用时，栈帧被压入堆栈。

   - 被调用函数的**参数**被压入栈帧。

   - 函数的**局部变量**在栈帧中被分配空间。

   - 函数的**返回地址被推入栈帧**。

   - 被调用函数的栈帧被弹出，栈帧中的局部变量和参数的空间被释放。

     

8. **栈帧是什么**

   在**函数调用**过程中存储相关信息的一块**内存区域**，它被压入堆栈（栈）以支持函数的调用和返回。**每个函数**调用都会创建**一个新的栈帧**，该栈帧包含了与函数调用相关的信息，如**局部变量**、**函数参数**、**返回地址**和其他必要的控制信息。

9. **什么是内存泄漏、如何防止**

   程序员申请的动态内存空间在使用完没有释放，会导致内存资源浪费甚至内存不足系统崩溃。	
   防止：申请和释放内存要成对出现、使用智能指针、使用Rall思想，在构造函数中申请，析构函数中释放内存。

   

10. **介绍智能指针**

    智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成**内存泄漏**。智能指针就是⼀个类，当超出作⽤域会⾃动 调⽤析构函数，析构函数会⾃动释放资源。

    **unique_ptr**：独占式指针，同⼀时间内只有⼀个智能指针可以指向该对象。不能拷贝，可以用move转移资源。

    **shared_ptr**：共享式拥有概念，多个智能指针可以指向相同对象。每多一个指针指向它，引用计数+1，析构一个引用计数-1，减到0的时候释放空间。

    **weak_ptr**：弱引用，不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象，不会改变引用计数。为了解决shared_ptr循环引用导致内存泄漏问题。

    

11. **讲一下shared_ptr的内部结构**

    计数器（reference count）、指针和控制块（control block）

    控制块：包含计数器和一些额外的信息。

    

12. **宏定义，typedef区别**

    执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；

    define 是宏定义，发⽣在预处理阶段， 不进⾏类型检查，只是进行简单的文本替换；

13. **c++ 11新特性**

    智能指针、Lambda表达式、unordered_set/unordered_map、初始化成员列表、右值引用、范围for循环等

14. **C++程序的时候如果进程崩了，怎么排查问题**

    **核心转储（Core Dump）：**启用核心转储功能，以便在程序崩溃时生成核心转储文件。核心转储文件包含了崩溃时（访问空指针、内存访问越界、除0等）的内存状态，可以通过它进行后续调试。

    **分析核心转储：**使用调试器（例如 GDB）分析核心转储文件。在终端中执行 `gdb <your_program> core`，然后可以使用 `bt`（backtrace）命令查看函数调用栈，以确定程序崩溃的位置。

    **查看错误信息：**核心转储文件中可能包含有关崩溃原因的信息，可以查看这些信息，例如段错误（Segmentation Fault）或空指针引用。

    

15. **C++中原子操作有哪些库函数，怎么实现的？**

    主要通过\<atomic\>库实现，atomic有个类模板实现各个基本类型的原子操作。

    atomic_load（加载原子变量的值）、atomic_store（存储新的值到原子变量）、atomic_fetch_add 、atomic_fetch_sub （这两个函数用于原子地执行加法和减法操作）、atomic_exchange （交换原子变量的值）

    这些实现会利用底层的**硬件原子操作指令**或操作系统提供的**原子操作机制**来实现。

16. **Mutex加锁底层怎么实现的？**

    **原子操作：** Mutex 的实现通常依赖于原子操作，确保对共享资源的访问是原子的，即不会被中断。

    **等待策略：**等待策略是指当一个线程或进程没有获取到锁时，应该采取什么样的行为
    					**自旋等待（spin-wait）：**自旋等待是指线程或进程不断地检查锁的状态，直到获取到锁为止。这种策略适用于锁的竞争不激烈，等待时间较短的情况，因为它可以避免上下文切换的开销，但是也会浪费CPU资源。
    					**阻塞等待（block-wait）：**阻塞等待是指线程或进程在获取不到锁时，主动让出CPU，进入等待队列，等待被唤醒。这种策略适用于锁的竞争较激烈，等待时间较长的情况，因为它可以节省CPU资源，但是也会增加上下文切换的开销。

    **自旋锁：** 在 Mutex 的实现中，可能会使用自旋锁（Spin Lock）。自旋锁是一种在获取锁失败时不立即进入睡眠状态，而是反复尝试获取锁的锁实现。在实现上，可以使用**原子操作**来更新锁的状态，例如设置锁的**标志位**。

17. **vector是如何做内存管理的**

    1. **动态内存分配：** 当你向 `std::vector` 中添加元素时，如果当前的容量不足以存储新元素，`std::vector` 就会分配一块新的内存区域，通常是原来容量的两倍，然后将原来的元素拷贝到新的内存中。这是为了避免每次添加元素都进行内存分配，提高性能。

       **一级空间配置器**：

       - 负责大块内存的分配和释放。
       - 使用 `malloc` 和 `free` 进行内存的分配和释放。
       - 一般情况下，分配的内存较大，用于处理较大的对象，例如数组。

       **第二级（二级配置器）**：

       - 负责小块内存的分配和释放。
       - 利用 memory pool（内存池）管理小块内存。
       - 内部采用多个 free lists，每个 free list 存储一组大小相等的内存块，用于快速分配和释放。
       - 当 free list 中无法满足需求时，会调用第一级配置器进行大块内存的分配。

    2. **内存释放：** 当你从 `std::vector` 中删除元素或者清空整个容器时，它会释放相应的内存。这确保了 `std::vector` 只占用实际存储的元素所需的内存空间。

    3. **迭代器稳定性：** `std::vector` 的迭代器在插入或删除元素时的行为是相对稳定的。也就是说，在插入或删除元素后，指向修改点之前的迭代器仍然有效，而指向修改点之后的迭代器可能会失效。

    4. **连续内存：** `std::vector` 保证其元素在内存中是连续存储的，这使得访问元素更加高效，因为可以通过指针算术运算直接访问内存。

    5. **预留空间：** 你可以使用 `reserve` 函数预留一定的空间，这样在添加元素时，不必每次都重新分配内存，提高了性能。

18. **C++左值和右值**，**移动语义**

    **右值：**无名字，无地址 （字面常量、临时对象、函数返回的临时值等都是右值。）

    **左值：**有名字，有地址（ 变量、对象、数组元素、引用等都是左值）

    **移动语义**：核心是移动构造函数，使用**右值引用**作为参数，实现**对象数据**的转移，而不是复制。

    **右值引用的特点：**通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。

    **右值拷贝（ move 构造函数）：**可以实现 move语义 ，即从右值中直接拿数据过来初始化 或修改左值， ⽽不需要重新构造左值后再析构右值。

    

19. **一个类有多个基类，内存中怎么虚函数表是怎么分布的？**

    对于多继承而言，每个**基类**都有自己的**虚函数表（vtable）**，而派生类会包含所有**基类的虚函数表**。
    
20. **怎么定位内存泄漏的位置？**

    使用专门的内存调试工具，如Valgrind（对于C/C++）。或者**自定义内存分配器**，手动记录分配情况。

    Valgrind工具检测内存泄漏的原理是，Valgrind实现一个**程序运行的虚拟环境**，待检测的应用程序在**Valgrind的虚拟环境中运行**，Valgrind能够实时监测程序中内存**申请、使用、释放**的情况，并记录一些**正常运行的有效信息和可能存在内存异常的信**息，输出到终端或者用户指定的文件中

21. **C++ shared_ptr如何保证线程安全？**

    c++11采用shared_timed_mutex，该互斥量可以用于对 `std::shared_ptr` 进行精细的线程安全控制。使用这个互斥量可以确保 `std::shared_ptr` 的引用计数操作是原子的。以及unique_lock分别用于共享和独占地锁定互斥量。

22. **C++如何解决线程安全问题？**

    **互斥锁（Mutex）**、**原子操作**、**条件变量（Condition Variable）**、**读写锁**

    条件变量：条件变量用于实现线程的等待和通知机制，以避免线程忙等。当某个条件不满足时，线程可以等待条件变量，而在条件满足时，其他线程可以通知等待的线程。

23. **C++派生类的构造和析构顺序是什么？为什么按照这种顺序？**

    1. **基类构造函数先于派生类构造函数调用**：

    2. **成员对象构造函数**

    3. **构造函数调用的顺序与继承层次一致**：

       - 如果有多层继承，构造函数的调用顺序与继承层次一致，从最顶层的基类开始逐级向下调用。

       **析构函数相反。**

       在构造过程中，派生类的构造函数需要调用基类的构造函数，而成员对象的构造函数则需要在它们所属的类的构造函数中调用。按照声明顺序调用这些构造函数可以确保依赖关系被正确建立。销毁按照反序可以确保资源在正确的时间点被获取和释放，避免资源泄漏。

24. **内存对齐有什么用，怎么实现？**

    经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，读取内存的时候是⼀块⼀块进⾏读取的。如果不对齐访存次数会增加，效率会较少。

    通过pragma pack(n)实现

    ```cpp
    #pragma pack(n)
    ```

    

25. **计算下⾯⼏个类的⼤⼩**

    ```cpp
    class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
    class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）
    class A{static int a; }; sizeof(A) = 1;
    class A{int a; }; sizeof(A) = 4;
    class A{static int a; int b; }; sizeof(A) = 4;
    ```

    

26. **介绍一下深拷贝与浅拷贝**

     **浅拷贝**是指将一个对象的数据复制到另一个对象中，但只复制对象本身和其所指向的所有指针，**而不复制指针所指向的内容**。因此，原对象和拷贝对象会共享同一块内存区域，其中的指针指向相同的数据。如果对象包含动态分配的资源（比如堆上的数组），两个对象的该资源将指向同一块内存。

     **深拷贝**是指将一个对象的数据复制到另一个对象中，不仅复制对象本身和其指针，还要**复制指针所指向的内容**。这样，原对象和拷贝对象拥有各自**独立的内存**，对一个对象的修改不会影响到另一个对象。
    
    
    
27. **说一下C++里面inline有什么用**

    **性能优化：** 减少函数调用的开销是 `inline` 最主要的目的之一，inline函数不会有函数压栈过程。

    **头文件中的函数定义：** 在头文件中定义函数时，通常需要使用 `inline`，以防止在多个编译单元中出现函数的多重定义错误。将函数定义放在头文件中，并标记为 `inline`，可以避免链接错误。

28. **讲一讲C++的new、delete和malloc、free的区别**

    都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。

    **执⾏ new 实际上执⾏两个过程：**

     1.分配未初始化的内存空间（malloc）；

     2.使⽤对象的**构造函数对空间进⾏初始 化**；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处 理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。

    **执⾏ delete 实际上也有两个过程：**

    1. 使⽤析构函数对对象进⾏析构；
    2. 回收内存空间（free）。

    

29. **emplace_back**

    可以就地构造对象，而不需要创建副本和频繁拷贝。这对于复杂的对象类型非常有用，可以避免不必要的对象复制和降低性能开销。

30. **C++ 中重载和重写，重定义的区别**

    **重载**：可以写不同参数列表的同名函数

    **重写**：派⽣类中重新定义⽗类中除了函数体外完全相同的**虚函数**。

    **重定义（隐藏）**：派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同。

31. **可变参数如何实现**

    va_list 

    ```cpp
    #include <iostream>
    #include <cstdarg>
    
    // 可变参数函数示例
    double average(int count, ...) {
        va_list args;
        va_start(args, count);
    
        double sum = 0;
        for (int i = 0; i < count; ++i) {
            sum += va_arg(args, double);
        }
    
        va_end(args);
    
        return sum / count;
    }
    
    int main() {
        std::cout << "Average: " << average(3, 1.2, 2.3, 3.4) << std::endl;
    
        return 0;
    }
    
    ```

32. **强制类型转换**

    C++ 的四种强制转换包括：**static_cast dynamic_cast const_cast reinterpret_cast**

    **static_cast：**明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；

    **dynamic_cast：**专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指 针，可能造成⾮法访问等问题。

    **const_cast：**专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个 可以操作常量的转换符。

    **reinterpret_cast：**不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解 释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。

33. **Main函数执行前发生了什么**

    **运行时环境初始化**：设置堆栈、初始化全局变量、静态变量、 如果程序中有全局或静态对象会在main函数之前调用

34. **为什么基类析构函数要求是虚函数**

    因为虚函数才能实现地址晚绑定的动态多态，继承的子类在执行析构时才能调用子类自己的析构函数。如果不为虚函数，就是静态多态，地址早绑定，子类析构调用的就是父类的析构，可能会导致内存泄漏。

35. **c++编译过程**

     预处理器→编译器→汇编器→链接器

    **预处理阶段：**写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如 #include 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件,删除注释。

    **编译阶段：**编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是**汇编语⾔程序**。⾼级语⾔是源程序。所以注意概 念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼ 级语⾔翻译的汇编语⾔相同。

    **汇编阶段：**汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀ 个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。

    **链接阶段：**⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个 名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得 到的是可执⾏⽬标⽂件。



36. **bss段是啥,有啥作用**

    在C语言中，BSS（Block Started by Symbol）段是可执行程序中的一部分，用于存储**未初始化的全局和静态变量**。bss段的数据在程序加载时由内核统一初始化为0，而不需要从磁盘或网络读取。提高加载速度。

    

37. **静态变量和全局变量的区别**

    **作用域：**全局变量作用域可能是全局，静态变量智能函数或者文件内访问。

    **生命周期：**全局变量为程序生命周期，静态变量为第一次定义到程序结束

    **初始化：**静态变量会在编译器初始化为0

38. **针对堆内存和栈内存怎么去获取呢**

    堆内存可以使用内存分析工具Valgrind。栈内存pstack 查看进程的栈信息。

39. **static对象第一次初始化在什么时候呢**

    **静态局部变量**：第一次执行

    **静态全局变量/成员变量：**程序启动时进行,早于main函数

40. **菱形继承了解吗**

    A(基类) 、 B（A的子类）、C(A的子类)、D(BC子类)

    在多重继承的情况下，当一个类从两个不同的基类继承，并且这两个基类最终共同继承自同一个基类时，就会形成菱形继承结构。

    菱形继承带来的问题主要有两个：

    1. **二义性（Ambiguity）：** 由于 `D` 类有两个路径可以访问 `A` 类的成员函数，例如 `D` 是否应该使用来自 `B` 类的 `foo` 函数还是来自 `C` 类的 `foo` 函数，就会导致二义性。
    2. **资源浪费：** `D` 类中存在两个独立的 `A` 类子对象，这可能导致对相同资源的重复分配和浪费。

    为了解决菱形继承的问题，C++ 提供了**虚继承（Virtual Inheritance）**的机制。通过在继承关系中使用 `virtual` 关键字，可以确保**只有一个共享的基类子对象**，从而解决二义性和资源浪费问题。

    
    
41. **虚函数和纯虚函数的差别，使用场景**

    ​		虚函数是在**基类中声明并定义**的，函数前加**virtual**关键字，它可以被派生类重写或继承，也**可以直接使用**。

    ​		纯虚函数是在基类中**只声明而不定义**的，虚函数后加=0，它必须在**派生类中重写才能使用**，否则派生类也是抽象类。需要**实现接口才能被实例化**。

    当基类中的**某个函数**在**大多数情况下都**应该由**派生类提供个性化的实现**，但**基类也可以提供一个默认的实现时**，可以将该函数设计为**虚函数**

    当基类中的某个函数必须由**派生类提供个性化的实现**，而**基类无法提供一个合理的默认实现时**，可以将该函数设计为纯虚函数。例如，图形类中的面积函数，不同的图形有不同的面积计算方法，而基类无法给出一个通用的面积函数。

42. **虚函数表的一个顺序是怎么样的**，**存在内存哪个区域** 

    虚函数按照其在**类中的声明顺序**放在虚函数表中，越先**声明的虚函数越靠前**。

    **多继承：**如果有多个基类，那么按照**继承的顺序**依次放置各个基类的虚函数。

    **虚函数的覆盖：**如果一个派生类覆盖了基类的虚函数，那么它的虚函数表中会用**派生类的虚函数指针**替换**基类的虚函数指针**，而不会增加新的条目。

    **虚函数表存在内存的静态存储区**

43. **介绍一下STL容器**

    STL容器可以分为三大类：**顺序容器、关联容器和容器适配器**。

    **顺序容器**是将一组具有相同类型的元素以严格的线性形式组织起来，如**vector、deque、list、forward_list、array**等。顺序容器支持随机访问或双向访问，以及在任意位置进行插入和删除操作。
    **关联容器**是每一个元素都有一个键值和实值，根据键值的大小或哈希值进行排序或分组，如set、map、multiset、multimap、unordered_set、unordered_map等。关联容器**支持快速的查找和访问**，以及在任意**位置进行插入和删除操作**。
    **容器适配器**是封装了**序列容器**的一个类模板，提供了一些特定的功能，如**stack、queue、priority_queue**等。容器适配器只允许在容器的一端进行插入和删除操作，实现了先进先出或先进后出的原则。

    

44. **指针和引用的区别**

    1.指针是一个变量，它存储另一个变量的地址。引用是一个别名，它引用（绑定到）另一个变量。引用在声明时需要初始化。

    2. 指针可以改变指针的值（指向不同的地址）。引用与某个变量绑定，无法改变引用的目标。
    3. 指针可以是空指针（nullptr）。引用在声明时必须初始化，并且不能指向空值。
    4. 指针可以指向数组的第一个元素，并通过指针进行数组遍历。引用不能直接绑定到整个数组。

45. **如何销毁线程**

​	**join成员函数：**阻塞等待子线程执行完毕

​	**detach成员函数：**线程分离，使得线程独立运行

​	

46. **gdb工具使用运行报错如何通过core文件找到错误**

    见https://space.jace.asia/docs/Cpp/Cpp%E7%BC%96%E8%AF%91/gdb%E8%B0%83%E8%AF%95

47. **lambda函数，以及使用场景**

    ​		提供了⼀个类似匿名函数的特性， 其实lamdba 表达式产⽣的是**函数对象**。 lambda 表达式⼀般都是从⽅括号[]开始，中间可能会有小括号传递参数，然后结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了 lamdba 表 达式体。最前边的 [] 是 lambda 表达式的⼀个很重要的功能，就是 闭包， **闭包的⼀个强⼤之处是其可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量**，前⾯的⽅括号就是⽤来定义捕 捉模式以及变量。

    

    使用场景：**作为参数传递给算法函数**、**事件处理和回调函数**、线程函数等



48. **override关键字作用**

    override关键字是C++11中引入的一个新特性，它可以用来**修饰派生类中重写基类虚函数**的成员函数，表示该函数**必须是虚函数**，且必须和**基类函数具有相同的函数签名。**提高可读性和可维护性，静态类型检查（如果不匹配会编译错误）。

49. **类中有指针，维护和使用需要考虑哪些问题** 

    在析构时候需要**释放指针**对应的资源，避免内存泄漏。

    如果是有派生类，需要把**析构函数定义为虚函数**。

    对于拷贝构造和赋值运算需要**深拷贝**。

50. **C++的类中可以定义引用的数据成员吗** 

    可以，**必须在构造函数中进行初始化**，**引用成员不能重新绑定**。

51. **vector的底层实现** 

    ​		vector的底层实现是一个**连续的线性内存空间**，它使用**三个指针**（或迭代器）来**表示容器的状态**：

    _start指向容器的**起始位置**，也就是第**一个元素的地址**；
    _finish指向容器的**结束位置**，也就是**最后一个元素的下一个地址**；
    _end_of_storage**指向容器的末尾位置**，也就是**分配的内存空间的下一个地址**。
    通过这三个指针，vector可以轻松地实现各种操作，如获取容器的大小、容量、首尾元素、随机访问等。

    ​	当vector的大小达到容量时，如果要插入新的元素，vector就**需要扩容**。扩容的过程是：

    ​		申请一块更大的内存空间，一般是原来容量的1.5倍或2倍；
    ​		将原来的数据拷贝到新的内存空间中；
    ​		释放原来的内存空间；
    ​		更新三个指针的值。
    由于扩容会导致原来的内存空间被释放，所以指向原**vector的所有指针、引用和迭代器都会失效**。因此，使用vector时要注意避免这种情况，或者及时更新指针、引用和迭代器的值。

52. **清空vector有哪些方式** 

    **clear()函数，resize函数、erase函数：**不保证清理内存

    **swap函数：**因为它创建了一个临时的空 vector 并与原 vector 交换，释放内存。

53. **已经有指针为什么要引入迭代器**

    迭代器提供了一种抽象层次，隐藏了实现细节。防止了访问越界或者悬空指针问题，更安全。并且提供一致的接口方便使用。

54. **如何判断weakpointer失效** 

    weakPtr.expired()

55. **c和C++的区别** 

    **面向对象编程（封装继承多态）、标准库模板（STL）、内存管理 - 引入new/delete关键字**

    

56. **如何设计一个不能继承的类** 

    利用final修饰类（加在类名后面）

57. **构造函数能否为虚函数** 

    ​       构造函数不能被声明为虚函数（virtual）。虚函数是用于**实现运行时多态性**的机制，它允许在基类和派生类之间进行动态绑定。然而，构造函数在**对象创建时被调**用，而在对象创建的过程中，还没有形成**对象的完整类型**，因此**不涉及运行时多态性**。

    ​       虚函数的工作机制基于对象的类型，而构造函数的调用是在对象类型已经确定的情况下进行的。

58. **空类包括什么** 

    空类对象的大小通常为1字节，确保每个对象都具有唯一的地址。

59. **拷贝构造函数与等号赋值的区别**

    **拷贝构造函数**：

    **触发时机：**对象通过值传递给函数（按值传参）。对象通过以值方式返回函数（按值返回）。通过显式调用拷贝构造函数来**创建一个新对象**。

    

    **等号赋值运算符（Copy Assignment Operator）**

    **触发时机**：**在对象已经存在的情况下**，使用等号（`=`）进行赋值。

60. **模板中typename和class有什么区别**

    在C++模板中，`typename` 和 `class` 在声明模板中的类型参数时是可以互换使用的，没有本质的区别。

    ```cpp
    template <typename T>
    void myFunction(T param) {
        // 函数体
    }
    
    template <class T>
    void myFunction(T param) {
        // 函数体
    }
    
    ```

    

61. **父类中有虚函数，数据，普通函数，子类继承父类，有自己的虚函数，数据，new一个子类对象，它的内存是如何排布的**
    - 子类对象的虚函数表指针，指向子类的虚函数表，其中包含子类重写或继承的虚函数的地址；
    - 子类对象继承自父类的数据成员，按照父类的顺序排列；
    - 子类对象自己的数据成员，按照声明的顺序排列；
    - 如果子类使用了虚继承，还会有虚基类指针，指向虚基类的子对象。
62. **介绍一下std::bind**

    std::bind 是一个**函数模板**，它可以根据一个**可调用对象**（如函数、函数对象或成员函数）**和一些参数**，生成一个**转发调用包装器**，将一些参数绑定到另一些参数上。它相当于用**绑定的参数调用可调用对象**，并且具有与原函数相同的签名。

63. **vector 和 list 的适用场景**

    **vector** 的底层实现是一个**动态数组**，它拥有一段**连续**的内存空间，可以高效地进行随机访问，时间复杂度为 O (1) 。但是，当 vector 的容量不足时，需要重新分配内存并复制元素，这会影响性能。同样，当在 vector 的中间位置插入或删除元素时，也需要移动后面的元素，时间复杂度为 O (N) 。

    **list** 的底层实现是一个**双向链表**，它的内存空间是不连续的，只能通过指针进行遍历，因此不支持随机访问，时间复杂度为 O (N) 。但是，由于链表的特点，list 可以在任意位置快速地插入或删除元素，时间复杂度为 O (1) 。

    因此，vector 和 list 的适用场景如下：

    如果需要频繁地随机访问元素，而不太关心插入和删除的效率，使用 vector ；
    如果需要频繁地在任意位置插入和删除元素，而不太关心随机访问的效率，使用 list ；

64. **vector 是怎么动态扩容的**
    - 当 vector 中的元素个数（size）等于它的容量（capacity）时，说明 vector 的空间已经满了，需要进行扩容。
    - vector 会申请一块新的内存空间，它的大小通常是原来空间的 1.5 倍或 2 倍，这样可以避免频繁扩容而影响性能，也可以避免过多浪费空间。
    - vector 会把原来空间中的所有元素复制或移动到新的空间中，这是一个比较耗时的操作，因为涉及到元素的构造和析构。
    - vector 会释放原来的空间，更新自己的指针和容量，完成扩容。

65. **move 和 forward 的作用**

    **move** 的作用是将一个左值转换为一个右值引用，从而可以触发**移动语义**，避免不必要的拷贝操作。

    **forward** 的作用是**完美转发**，即保持一个参数的**左值或右值属性不变**，从而可以在函数模板中正确地**转发参数给另一个函数**。

    

66. **自定义类时，C++的 STL库 sort 的使用**

    1.类中重载小于符号比较，可以使用默认从小到大排序

    2.使用仿函数或者普通函数传入参数

67. **new 可以重载吗**

    new运算符在创建对象时会调用operator new函数来分配内存，然后调用构造函数来初始化对象。我们可以通过重载operator new函数来改变内存分配的方式，例如使用内存池或者自定义的分配策略。

    

68. **自由内存和堆的区别**

    **堆**是操作系统维护的一块特殊内存，是一个物理概念，它提供了动态分配的功能，使用malloc()、free()等函数或系统调用来申请/释放内存。
    **自由内存**是C++中通过new和delete运算符动态分配和释放对象的抽象概念，是一个逻辑概念。
    基本上，所有的C++编译器默认使用**堆来实现自由内存**。也就是说，默认的全局运算符new和delete也许会使用malloc和free的方式申请和释放存储空间，这时自由存储区就位于堆上。
    
    

69. **C++中delete一个对象和数组有什么区别**

    delete数组要用delete[], 调用delete[]才能析构每个对象

70. **在已申请的内存中构造对象如何实现**

    使用定位 new 运算符（placement new）。定位 new 允许你在给定的地址上创建对象，而不是分配新的内存。这通常用于在预分配的内存块中构造对象，例如在某个特定的内存区域或缓冲区中。

    ```cpp
    const size_t bufferSize = sizeof(MyClass);  // 预分配的内存大小
    char buffer[bufferSize];  // 预分配的内存块
    
    // 使用定位 new 在已分配的内存中构造对象
    MyClass* myObject = new (buffer) MyClass();
    
    // 使用构造的对象
    myObject->printValue();
    
    // 显式调用析构函数
    myObject->~MyClass();
    ```

    

71. **内联函数**

    内联函数是直接**替换为函数体**的代码的机制。内联函数的目的是**提高程序执行的效率**，**减少函数调用的开销**。使用内联函数通常在函数定义前面加上 `inline` 关键字。适用于函数体较小、频繁调用且对性能要求较高的情况。

72. **c++比c语言多了哪些东西**

    面向对象编程、STL库、模板、引用、内存分配new/delete、运算符/函数重载

73.  **C++里面的动态类型和静态类型**
    1. **动态类型（Dynamic Type）：**
       - 动态类型是在**程序运行**时确定的类型，通常是指**实际对象**的类型。在多态性的情境下，基类的指针或引用可以在运行时指向派生类的对象，此时就涉及到动态类型。
    2. **静态类型（Static Type）：**
       - 静态类型是在**编译时确定的类型**，通常是指变量或表达式在编译时的已知类型。在强类型的语言中，所有的变量和表达式都有一个静态类型。
       - 静态类型是根据声明时的类型来确定的，不会随着程序的运行而改变。例如，如果有一个变量声明为 `int` 类型，那么它的静态类型就是 `int`。

```cpp
#include <iostream>

class Base {
public:
    virtual void print() const {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base {
public:
    void print() const override {
        std::cout << "Derived class" << std::endl;
    }
};

int main() {
    Base baseObj;
    Derived derivedObj;

    Base* ptr = &baseObj;  // 静态类型和动态类型都是 Base
    ptr->print();  // 输出 "Base class"

    ptr = &derivedObj;  // 静态类型是 Base，动态类型是 Derived
    ptr->print();  // 输出 "Derived class"

    return 0;
}

```

74. **子类没有重写虚函数，还会有虚表吗**

    是的，子类依旧会新建一个虚表，虚表里面存放的是父类的虚函数指针。这样可以保证通过父类指针调用子类对象时，能够正确地找到对应的虚函数。

75. **操作系统内存管理，free为什么能知道该释放多少内存，如果对malloc返回的指针进行改写，free还会知道该释放多少内存吗**

    ​    malloc函数在分配内存时，会在内存块的首地址前面记录该内存块的大小信息。free函数通过指针偏移和类型转换，就可以获取到这个大小信息，然后正确地回收系统资源。

    ​    如果对malloc返回的指针进行改写，free函数是否还能知道要释放多少内存，取决于改写的方式和程度。如果只是改写了指针指向的内存内容，而没有改变指针的值，那么free函数仍然能够正确地释放内存。但是如果改写了指针的值，使其不再指向原来的内存块，那么free函数就无法找到正确的大小信息，可能会导致内存泄漏或者崩溃。

76. **template编译时有什么特点**
    template是一种静态多态的机制，也就是说，template可以实现在编译期根据不同的类型选择不同的函数或类，而不需要使用虚函数或动态绑定。这样可以提高程序的灵活性和可扩展性。

77. **C++ 中的指针参数传递和引⽤参数传递**

    

## 二.操作系统篇

1. **进程和线程的区别**

   - 调度：线程是调度的基本单位（PC，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。

   - 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。

   - 系统开销：线程创建销毁只需要处理PC值，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁PCB结构以及相关资源，系统开销大。

     

2. **进程间的通信方式有哪些**

   - **管道：**
     
     - 无名管道（**内存文件**）：管道是一种**半双工的通信方式**，数据只能**单向流动**，而且只能在具有**亲缘关系的进程之间使用**。
     
     - 有名管道（FIFO文件，借助**文件系统**）：允许在没有亲缘关系的进程之间使用，管道是**先进先出**的通信方式。
     
       **缺点：单向流动、缓冲大小受限、只能数据流**
     
   - **共享内存：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。

     - **优点是无需复制，速度块。缺点是要解决同步和互斥问题。**

   - **消息队列：**存放在内核中的队列，进程向队列添加或者读取消息，由系统调用实现同步。

     ​	优点是消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。缺点是消息队列需要额外的CPU时间，不适合操作频繁的场合。

   - **套接字：**适用于**不同机器间进程通信**，在本地也可作为两个进程通信的方式。

   - **信号：**是一种由**用户、系统或进程**发送给**目标进程的信息**，以**通知目标进**程某个状态的改变或系统异常。信号可以触发目标进程的**某些行为**，如终止、暂停、继续等。它的**优点**是可以实现**异步通知**，缺点是**传递的信息量少**，信号的处理方式有限。

   - **信号量：**信号量是一个**计数器**，可以用来控制多个进程对**共享资源的访问**。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

   

3. **介绍以下中断和异常的区别，以及中断处理步骤，有哪些中断？**

   **中断：**由**外部设备或其他处理器发起**的，用于通知 CPU 有一个事件需要处理，例如 I/O 完成，敲击键盘等。然后CPU识别中断来源并发送给内核。分为硬中断和软中断，硬中断为硬件发起，软中断通常是由操作系统内核中的代码生成的，用于执行一些系统级的任务。
   **异常：**由CPU发起的，如遇到缺页、除0、访问非法内存异常等等。发送给内核。

   **中断处理步骤：**

   1. **中断发生：** 外部设备或其他处理器发出中断信号，通知 CPU 有事件需要处理。
   2. **保存当前上下文：** CPU 会保存当前执行的程序计数器、寄存器状态和其他必要的信息，以便在中断处理完成后能够恢复执行。
   3. **中断服务例程（ISR）的调用：** CPU跳转到中断向量表（Interrupt Vector Table）中的相应入口，开始执行中断服务例程。
   4. **恢复现场：** 在中断服务例程执行完毕后，CPU 恢复之前保存的上下文信息，包括程序计数器、寄存器等。
   5. **中断返回：** 执行完中断服务例程后，CPU 返回到被中断的程序，继续执行。

   外部中断（键鼠等），内部中断（缺页，除0等），软中断（系统调用）

4. **内存映射和共享内存**

   **内存映射：**

   1. **映射方式：** 内存映射是将文件或其他对象映射到进程的地址空间，使得这些对象可以像内存一样被访问。这包括**文件映射**和**匿名映射**。
   2. **文件映射：** 主要用于将文件映射到内存，这样可以直接在内存中读取或写入文件数据，而无需通过传统的文件 I/O 操作。
   3. **匿名映射：** 创建一个与文件无关的映射，可以用于进程间通信或创建共享的内存区域。
   4. **使用场景：** 内存映射通常用于处理文件、数据库等大型数据集，或者用于多进程之间的通信。

   **共享内存：**

   1. **共享方式：** 共享内存是通过在不同的进程之间创建共享的内存区域，使得这些进程可以直接访问共享的内存段，而无需通过中间介质。
   2. **通信方式：** 共享内存主要用于进程间通信，允许多个进程之间快速、高效地共享数据。进程可以读取和写入共享内存中的数据，实现数据的共享。
   3. **使用场景：** 共享内存通常用于需要频繁交换大量数据的进程之间，以提高性能和效率。

   **区别总结：**

   1. **映射对象：** 内存映射主要涉及将文件或其他对象映射到进程的地址空间，而共享内存是直接在不同进程之间创建共享的内存区域。
   2. **用途：** 内存映射通常用于处理文件、数据库等数据集，而共享内存用于进程间通信，特别是需要频繁交换大量数据的情况。
   3. **实现机制：** 内存映射可以是文件映射或匿名映射，而共享内存是直接创建一块共享的内存区域。

5. **说一下系统调用**

   ​	系统调用是操作系统提供给**用户程序和应用程序**的**一种接口**，通过这个接口，用户程序可以请求操作系统**执行特权操作**。文件操作、进程控制、网络通信等。

   ​	**用户程序发起系统调用**，**切换到内核态**，**执行系统调用**，**返回结果**，**切换回用户态**

   

5. **为啥要用虚拟内存，怎么实现？**

   虚拟内存通过内存和磁盘之间的映射，虚拟出来更大的内存空间，实现了隔离和保护机制。

   虚拟内存实现是基于分页或者分段实现，分页是将内存和磁盘分成大小相等的块，通过页面调度算法对页面进行换入和换出。通过页表对虚拟地址和逻辑地址的映射。分段是根据逻辑将进程分为数据段、代码段等，分配更灵活。

6. **自旋锁和互斥锁有什么区别？分别适合什么场景？**

   **自旋锁:**一种忙等待的锁,获取不到锁会CPU一直循环获取。适用于短时间内锁被占用的情况，并且并发量不大的情况，或者多CPU的情况。

   **互斥锁：**一种阻塞锁，获取不到锁会阻塞直到锁可用。互斥锁适用于长时间内锁被占用的情况，并发量大。

7. **为什么要设计内核态、用户态两种状态**，**怎么切换的**
        两种运行模式，应着不同的特权级和资源访问权限，用户态是普通的用户进程运行的模式，它只能访问有限的资源，比如用户空间的内存，用户栈，用户程序等。内核态是操作系统内核程序运行的模式，它可以访问所有的资源，比如内核空间的内存，内核栈，硬件设备，系统调用等。

   **安全性：** 分离内核态和用户态可以防止用户程序直接对系统资源进行不受控制的访问，从而提高系统的安全性。

   **资源隔离：** 通过将系统划分为内核态和用户态，可以实现资源的隔离，使得一个程序的错误不会直接影响其他程序和整个系统。

   **切换方式：系统调用（操作系统开放的调用接口）、异常、外设中断**

8. **线程同步**

   ​		在多线程编程中，确保多个线程按照一定的**顺序和协调执行**，以避免并发访问共享资源时可能引发的问题，如**数据竞争**、**死锁**等。线程同步的目标是保证程序的**正确性和稳定性**。

   **互斥锁（Mutex）**、**信号量（Semaphore）**、**条件变量（Condition Variable）**、**读写锁（Read-Write Lock）**、**原子操作（Atomic Operation）**

   

9. **说一下缺页中断**

   缺页中断（Page Fault）是计算机操作系统中的一种异常情况，发生在程序试图访问尚未调入内存的页面时。当程序**访问的页面不在主内存中**，操作系统会触发缺页中断，以便将相应的**页面调入内存**，然后重新执行导致缺页的指令。

   1. **访问缺页：** 当程序试图访问一个尚未在主内存中的页面时，例如由于页面被换出到磁盘或者是首次访问的页面，CPU会产生一个缺页异常。
   2. **触发中断：** 缺页异常导致CPU暂停当前执行的程序，并向操作系统发出一个中断请求，即缺页中断。
   3. **操作系统处理：** 操作系统的缺页中断处理程序被调用。该处理程序的任务是将所需的页面从磁盘或其他辅助存储器加载到主内存中。
   4. **更新页表：** 一旦页面被加载到主内存，操作系统更新页表，以便将虚拟地址与物理地址进行映射。
   5. **重新执行指令：** 缺页中断处理完毕后，CPU重新执行导致缺页的指令，这次访问将成功，因为所需的页面现在已经在主内存中了。

10. **介绍一下父子进程**

    父子进程是指在一个进程的基础上创建出另一个**独立的进程**，这个新进程就是子进程，原来的进程就是父进程。

    子进程是**父进程的副本**，拷贝了父进程的**数据空间、堆和栈**，但**不共享**这些资源，只**共享代码段**。
    子进程从父进程调用fork函数的下一条指令开始执行，fork函数在父子进程中返回不同的值，父进程返回子进程的PID，子进程返回0。
    父子进程各**自独立运行**，互不影响，但可以通过信号或管道等方式进行通信。
    父进程可以通过wait或waitpid函数**等待子进程的结束**，并**回收子进程的资源**，防止出现僵尸进程。
    如果父进程先于子进程结束，子进程会成为孤儿进程，由**init进程**接管并回收。

11. **页面置换算法有哪些**

    **最佳置换法(OPT)**：最理想的算法，每次选择以后最长时间不用的。无法实现。

    **先进先出置换算法(FIFO)**：淘汰的页面是最早进入内存的页面 ，用队列实现，可能出现Belady异常，物理块数增大时，缺页次数不减反增的异常现象。

    **最近最久未使用置换算法(LRU)**：淘汰最近最久未使用的页面 ，算法性能好，但是实现困难，开销大。

    **时钟置换算法(CLOCK)**：利用每个页面的访问位来记录其是否被访问过。它把所有的页面组织成一个环形链表，并维护一个指针指向最老的页面。当发生缺页中断时，它检查指针所指的**页面的访问位**，如果为0，就**淘汰该页面**；如果为1，就把**该位清零**，并把**指针后移一位**，直到找到一个**访问位为0**的页面。它的实现比较简单，但是可能会淘汰一些刚刚被访问过的页面

12. **如何实现读写锁，以及读写优先级**

    **基于信号量：**使用一个值记录读者数量，以及个信号量。一个信号量用与保护更新读者数量的互斥。另一个信号量，用于读写锁的互斥操作。

    ​	对于获取读锁，首先获取数量互斥锁，然后获取读写互斥锁，如果获取到，将读数量加一。读取完释放数量互斥锁，以及读写互斥锁。

    ​	对于写锁，直接获取读写互斥锁就行。

    **基于原子操作和自旋等待：**使用一个原子变量表示锁的状态，其中高位表示读者的数量，低位表示写者的标志。当一个线程想要获取读锁时，需要先检查是否有写者正在执行或等待，如果有，就自旋等待，否则就使用原子操作将高位加1，表示增加一个读者。当一个线程想要获取写锁时，需要先检查是否有读者或写者正在执行，如果有，就自旋等待，否则就使用原子操作将低位设置为1，表示设置一个写者。当一个线程释放读锁时，需要使用原子操作将高位减1，表示减少一个读者。当一个线程释放写锁时，需要使用原子操作将低位清零，表示清除一个写者


- 读者优先：当有读者请求读锁时，如果没有写者正在执行或等待，就立即给予读锁，否则就等待写者完成。这样可以提高读者的并发性，但可能导致写者饥饿。
- 写者优先：当有写者请求写锁时，如果没有读者或写者正在执行，就立即给予写锁，否则就等待读者或写者完成。这样可以提高写者的响应性，但可能导致读者饥饿。
- 读者-写者公平：当有读者或写者请求锁时，按照先来先服务的原则，给予锁。这样可以保证读者和写者之间的公平性，但可能降低读者的并发性。



13. **介绍一下死锁，怎么解决？**

    ​	死锁是指两个**（多个）线程相互等待对方数据的过程**，死锁的产生会**导致程序卡死**，不解锁程序将永远无法进行下去。

​			**四个原因：**

​				**互斥条件：**进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。

​				**不剥夺条件：**进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。

​				**请求和保持条件：**进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。

​				**循环等待条件：**存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。

​		**解决方法：**

​				**鸵鸟策略**：解决死锁问题的代价很高，不采取任何措施。

​				**死锁检测与死锁恢复：**检测是否有死锁发生，恢复有3种，利用抢占式恢复、回滚恢复、杀死进程。

​				**死锁预防**：破环四个死锁的必要条件

​				**死锁避免：**采用银行家算法

14. **进程线程通信**有什么不同

    进程间的通信需要借助操作系统提供的**IPC机制**，如**管道、消息队列、信号量、信号、共享内存**等；
    线程间的通信可以**直接访问共享变量**，如**全局变量、静态变量**等，但需要注意同步和互斥的问题，也可以使用**信号量、事件**等机制



15. **虚拟内存怎么变成物理内存（有快表）**

    1.CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。

    2.如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。

    3.如果没有找到匹配的页号，则需要**访问内存中的页表**，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。

    

​		

16. 









## 三.计算机网络篇

1. **介绍一下OSI七层协议，各层协议都有哪些**

   1. **物理层（Physical Layer）：**
      - 功能：传输比特流，主要关注物理介质、电流、编码等。
      - 协议：没有特定的协议，主要涉及硬件标准（如Ethernet、Wi-Fi等）。
   2. **数据链路层（Data Link Layer）：**
      - 功能：负责将比特流组织成帧，进行错误检测和纠正。
      - 协议：ARP（Address Resolution Protocol）等。
   3. **网络层（Network Layer）：**

      - 功能：负责在不同网络之间进行路由和转发，实现端到端的数据传输。
      - 协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等。
   4. **传输层（Transport Layer）：**
      - 功能：提供端到端的通信，负责数据的可靠性、流量控制和错误恢复。
      - 协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。
   5. **会话层（Session Layer）：**

      - 功能：管理和协调会话，确保数据传输的正确顺序。
      - 协议：NetBIOS（Network Basic Input/Output System）等。
   6. **表示层（Presentation Layer）：**

      - 功能：处理数据的表示和格式，确保应用层能够解释数据。
      - 协议：JPEG、GIF、SSL/TLS（Secure Sockets Layer/Transport Layer Security）等。
   7. **应用层（Application Layer）：**

      - 功能：为用户提供网络服务，是网络应用程序的接口。
      - 协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、DNS（Domain Name System）等。

2. **介绍一下TCP/IP的四层模型**

   - **应用层：**这一层是直接为应用进程提供服务的，它包含了各种不同的应用协议，如HTTP、FTP、SMTP、DNS等。应用层的协议可以实现数据的格式化、加密、压缩等功能，以及与其他节点的联系的建立和解除。
   - **传输层：**这一层是为上层应用提供可靠或者高效的数据传输的，它包含了两个主要的协议：TCP和UDP。TCP协议可以保证数据的可靠传输，通过分段、重传、流量控制、拥塞控制等机制，实现端到端的连接和数据交换。UDP协议则是一种无连接的、简单的协议，它只负责将数据报发送给目的端，不保证数据的可靠性和顺序，但是速度较快，适合一些实时性要求高的应用。
   - **网络层：**这一层是负责在不同的网络之间进行数据包的传送的，它包含了IP协议和相关的协议，如ICMP、IGMP等。IP协议是实现**网络互连的核心协议**，它定义了网络地址的格式和分配，以及**路由选择的方法**。IP协议只负责将数据包发送到目的网络，不保证数据包的可靠传输。ICMP协议是用于传递网络控制信息的协议，如错误报告、路由重定向、回显请求等。IGMP协议是用于管理多播组的协议，它可以让主机加入或退出一个多播组，以接收或停止接收多播数据。
   - **网络接口层：**这一层是负责将数字信号在物理通道中准确传输的，它包含了数据链路层和物理层的功能。数据链路层负责在**相邻的节点之间建立逻辑连接，进行物理寻址**，以及错误检测和恢复。物理层负责在物理媒介上进行数据的编码、调制、发送和接收，以及同步等功能。

3. **输入一个网页，到出现页面，这中间发送了什么？**

   - 域名解析DNS
   - 发起TCP的3次握手
   - 建立TCP连接后发起http请求（https的话需要建立安全的会话层进行SSL/TLS握手）
   - 服务器响应http请求，浏览器得到html代码
   - 浏览器解析html代码，并请求html代码中的资源
   - 浏览器对页面进行渲染呈现给用户。

4. **假设浏览器访问网址，这四层分别会发生什么事情呢**

   **应用层：**构造一个**HTTP请求报文**，需要向**DNS服务器发送查询请求**，得到**IP地址**后，浏览器就可以通过**传输层的接口**将HTTP请求报文发送出去。
   **传输层：**与服务器**建立TCP连接**。TCP连接的建立需要经过**三次握手**的过程，交给网络层进行传输。
   **网络层：**封装成IP数据报，**加上源IP地址**和**目的IP地址**等信息，然后根据**路由表**选择**合适的路径**，将IP数据报转发给下一跳的路由器或目的端。
   **网络接口层：**网络接口层负责**将IP数据报转换成适合物理媒介的数据帧**，加上源**MAC地址**和目的MAC地址等信息，然后通过**物理层的接口发送出去**。在发送的过程中，可能需要进行**ARP查询**，即根据目的IP地址获取目的**MAC地址**，如果本地缓存中没有，就需要向本地网络广播ARP请求，得到ARP响应后，就可以将MAC地址写入数据帧。在接收的过程中，需要进行**CRC校验**，检查数据帧是否有错误，如果有错误，就丢弃数据帧，如果没有错误，就将数据帧交给网络层进行处理 。

5. **TCP三次握手**

   ![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

   1. **客户端发起连接请求：**
      
      - 客户端首先向服务器发送一个TCP报文，其中设置了SYN（同步）标志位，并选择一个初始序列号（ClientISN）。
   2. **服务器确认连接请求并发起连接：**
      - 服务器收到客户端的SYN报文后，会发送一个带有SYN和ACK（确认）标志位的TCP报文作为响应。
      - 服务器也会选择一个自己的初始序列号（ServerISN），并在ACK字段中确认客户端的初始序列号（ClientISN + 1）。
      - 同时服务器会将第二次握手的客户端加入到半连接队列。
   3. **客户端确认连接：**
      - 客户端收到服务器的响应后，向服务器发送一个带有ACK标志位的TCP报文，确认服务器的初始序列号（ServerISN + 1）。
      - 第三次握手可以携带数据
        
        

6. **为什么TCP三次握手，两次握手可以吗**

   三次握手是为了确保双方都有发送和接收数据的能力。两次握手不可以，第三次握手是为了防止历史失效连接再次请求，导致资源浪费。

7. **TCP四次挥手**

   ![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

   1. **主动关闭方发送连接释放报文（FIN）：**
      - 主动关闭方（一般是客户端）首先发送一个TCP报文，其中设置了FIN标志位，表示它已经完成发送数据，希望关闭连接。表示已经没有数据要发送了。
      - 这个FIN报文中还包含一个序列号，用于标识主动关闭方的数据已经发送完毕的位置。

   2. **被动关闭方确认收到释放报文：**
      - 被动关闭方（一般是服务器）收到主动关闭方的FIN报文后，会向主动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了主动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认主动关闭方的序列号。

   3. **被动关闭方发送连接释放报文（FIN）：**
      - 被动关闭方在完成了自己的数据发送后，也会发送一个TCP报文，其中设置了FIN标志位，表示它希望关闭连接。
      - 这个FIN报文中也包含一个序列号，用于标识被动关闭方的数据已经发送完毕的位置。

   4. **主动关闭方确认收到释放报文：**
      - 主动关闭方收到被动关闭方的FIN报文后，向被动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了被动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认被动关闭方的序列号。

   5. **四次挥手的2MSL有什么用**

      ​	等戴2MSL作用防止历史报文发送到服务器产生混乱。也能让服务端正确关闭（若服务器迟迟没有收到第四次报文，会重发第三次报文）。

8. **TCP和UDP的区别，什么时候用tcp什么时候用udp？**

   **TCP：**面向连接一对一，可靠通信、字节流、有流量控制以及拥塞控制。

   **UDP**：无连接、不可靠、低延迟、可以一对多。

   对于文件完整性和可靠性有要求用TCP，如文件传输等等。对于时间要求使用UDP，如视频通话，游戏等等。

   

9. **udp丢包会有什么现象？**

   **数据丢失**

   **乱序**

   **延迟变化**

   

10. **http和https的区别**

   都是用于在网络上传输数据的协议，它们之间的主要区别在于安全性和加密。

   - **HTTP：** 传输的数据是明文的，不经过加密处理。
   - **HTTPS：** 使用SSL/TLS协议对数据进行加密，确保传输的数据在网络上是安全的。

   

11. **滑动窗口-流量控制作用**

    ​		用于流量控制。发送方和接收方都维护一个滑动窗口，表示可以发送或接收的数据帧的范围。发送方通过滑动窗口的机制动态调整发送的数据量，以保证在网络状况允许的情况下提高传输速度。

    

12. **拥塞控制**

    拥塞控制通过监测网络中的拥塞情况，采取一系列策略来调整数据流的速率，以避免网络过载。慢启动、拥塞避免、快速重传、快速恢复等。

    

13. **流量控制和拥塞控制差异**

    滑动窗口主要关注单个通信连接的数据流控制，而拥塞控制关注整个网络中的拥塞情况。

    

14. **服务端的socket接收缓冲区只剩10个字节，但是客户端发过来一个未经过分片的12个字节的报文。之后客户端和服务端分别会发生什么事情？如果服务端的接收窗口变为0会怎么样？**（看）

    ​		这个问题的答案可能取决于具体的**网络协议和阻塞模式**，但一般来说，可以参考以下的情况：

    ​		**TCP协议**，那么客户端发送的报文会被分片为两个TCP段，每个段的大小为6个字节。服务端会接收到第一个段，并将其存入接收缓冲区，然后向客户端发送一个ACK，表示已经收到了6个字节的数据。但是由于服务端的接收缓冲区已经满了，无法接收更多的数据，所以**服务端会丢弃第二段报文**，并向**客户端发送一个窗口大小为0的通知**，表示**暂时不能接收数据**。客户端收到窗口大小为0的通知后，**会停止发送数据**，并启动**重传定时器，等待服务端的窗口大小变大**。服务端在读取了接收缓冲区中的数据后，**会向客户端发送一个新的窗口大小**，表示可以接收数据了。
    ​	**UDP协议**，那么客户端发送的报文不会被分片，而是作为一个整体的UDP数据报发送出去。服务端会接收到这个数据报，但是由于接收缓冲区只有10个字节的空间，无法存放12个字节的数据，所以**服务端会丢弃这个数据报**，并向**客户端发送一个ICMP差错报文**，表示**目的地不可达**。客户端收到这个差错报文后，会知道数据没有被成功发送，但是**UDP协议并不提供重传机制**，所以客户端需要自己决定是否重新发送数据。服务端在读取了接收缓冲区中的其他数据后，会释放出空间，但是并不会主动通知客户端，所以客户端需要自己判断何时可以重新发送数据。

    

15. **TCP的keep-alive和HTTP的keep-alive有什么区别？**

    **TCP Keep-Alive：**于在长时间没有数据传输时保持 TCP 连接的活跃状态，以防止连接因为长时间的空闲而被中断。周期性地向对方发送一个小的探测包（Probe）来实现的。如果一定时间内没有收到对方的响应，就会认为连接已经失效，然后关闭连接。

    **HTTP 的 Keep-Alive：**用于在**一次 TCP 连接上发送多个 HTTP 请求**，而不是每次请求都建立一个新的 TCP 连接。这可以减少连接建立和断开的开销，提高性能。

16. **udp不需要建立连接，那是不是所有人都可以向我发送数据**

​		由于UDP不涉及连接的建立和维护，发送方可以随时向接收方发送数据，而不需要进行握手等步骤。但是在应用层可以，使用加密来确保数据的机密性，或者使用其他手段验证数据的来源。

17. **网络IP地址转化流程，外网IP和内网IP是怎么转换的**

​		主要涉及到一种技术叫做**NAT（网络地址转换）**。NAT的作用是在内部网络和外部网络之间实现IP地址的转换，从而**节省公网IP地址资源**，提高网络安全性，以及解决不同网络之间的互联问题。

​		NAT的基本原理是，当**内网的主机**想要**访问外网**的时候，由**NAT设备**（通常是**路由器**（需要支持NAT的路由器设备）或防火墙）将**内网的私有IP地址转换为公网的IP地址**，并记录下转换的映射关系，然后将数据包发送给外网的目的主机。当外网的主机回复数据包的时候，由**NAT设备根据映射关系**，将公网的IP地址转换回内网的私有IP地址，并将数据包转发给内网的源主机。这样，内网的主机就可以通过一个或少量的公网IP地址与外网进行通信。

18. **ICMP协议介绍**

    主要用于网络设备之间**诊断网络通信问题**。ICMP可以用于确定数据**是否及时到达目的**地，以及**报告可能发生的错误**。

    ICMP的主要用途有两个：

    **错误报告：**当两个设备通过互联网连接时，如果**数据没有到达目的地**，ICMP会生成**错误消息**并发送给源设备。例如，如果一个数据包对于一个路由器来说太大，路由器会丢弃该数据包，并向源设备发送一个ICMP消息。
    **网络诊断：**常用的终端工具**traceroute和ping**都是利用ICMP实现的。traceroute工具用于显示两个互联网设备之间的**路由路径**，即数据包经过的路由器的物理路径。每经过一个路由器就称为一个“跳跃”，traceroute还会报告**每个跳跃所需的时间**。这对于确定网络延迟的原因很有用。ping工具是traceroute的简化版本，它用于**测试两个设备之间的连接速度**，并报告数据包到达目的地并返回源设备所需的时间。虽然ping不提供关于路由或跳跃的数据，但它仍然是衡量两个设备之间的延迟的一个很有用的指标。ICMP的回显请求和回显应答消息通常用于执行ping。

    



19. tim**ewait，closewait状态原因** 

    **TIME_WAIT 状态：**

    - **原因：** **主动关闭连接**一方**第四次**挥手后，连接会进入 `TIME_WAIT` 状态。在这个状态中，系统会等待**两倍的最大报文段寿命**（Maximum Segment Lifetime，MSL）时间，以确保远程端已经接收到关闭连接的通知，避免可能残留在网络中的延迟报文对新连接产生干扰。

    **CLOSE_WAIT 状态：**

    - **原因：** 被动关闭端第二次挥手后，即该端已经接收到对方发来的连接关闭请求，并已经发送了确认，但可能仍然有数据需要发送。

    ![客户端主动关闭连接 —— TCP 四次挥手](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png)

20. **服务器有很多closewait状态是什么原因** 

    服务器程序迟迟没有对连接进行关闭操作。

​		

21. **乐观锁和悲观锁本质的区别是什么**

    **悲观锁：**悲观锁的基本思想是在**访问共享资源之前**，先获取锁，以保证在整个访问期间资源不会被其他线程修改。当一个线程获得了悲观锁之后，其他线程将被阻塞，直到持有锁的线程释放锁。适用于对数据修改操作频繁，且并发冲突概率较高的情况。

    **乐观锁：**在实际**修改共享资源之前**，先检查资源的版本号等信息，确保在修改时资源没有被其他线程修改。如果检查发现资源被修改，那么乐观锁会进行回滚或重试，以确保在修改时资源是一致的。适用于对数据的读操作频繁，且并发冲突概率较低的情况。

22. **TCP的可靠性是怎么保证的**

    1. **确认和重传机制：** TCP使用确认和重传机制来确保数据的可靠传输。当发送方发送数据后，接收方会给发送方发送一个确认（ACK）表示成功接收到数据。如果发送方在一定时间内未收到确认，它会认为数据丢失，然后重新发送数据。这确保了数据的正确到达。
    2. **序号和确认号：** TCP使用序号和确认号来追踪发送和接收的数据。每个TCP报文段都有一个序号，表示报文段的第一个字节在数据流中的位置。接收方使用确认号来指示期望接收的下一个字节的序号。通过序号和确认号的配对，TCP可以正确地组装和追踪数据流。
    3. **流量控制：** TCP使用流量控制机制来防止发送方发送速度过快而导致接收方无法及时处理数据的情况。通过窗口大小的调整，接收方可以通知发送方自己的接收缓冲区还有多少可用空间，从而实现流控制。
    4. **拥塞控制：** TCP使用拥塞控制来防止网络拥塞。通过动态调整发送速率和拥塞窗口大小，TCP可以适应网络的变化，防止拥塞的发生，从而提高整体网络的性能和可靠性。
    5. **超时重传：** TCP在发送数据后设置一个**定时器**，如果在定时器超时之前没有收到确认，就认为数据可能丢失，触发超时重传机制。发送方会重新发送未确认的数据，确保数据的可靠传输。

23. **tcp如果序列号不同步会产生什么情况**

    数据乱序、数据重复、数据丢失、连接中断
    
    

24. **服务端如何探测客户端是连接还是断开（Keep-Alive）**

    Keep-Alive 是一种 TCP 协议的机制，它可以让服务端和客户端在一定时间内**重用同一个 TCP 连接**，从而减少创建和关闭连接的开销。

    如果服务端在发送了多次探测包后，仍然没有收到客户端的回应，就认为客户端已经断开连接，从而关闭 TCP 连接。



25. **HTTP报文格式**

    报文头部（Headers）和报文主体（Body）。

    ```
    #发送报文
    [Method] [Request-URI] [HTTP-Version]
    [Headers]
    
    [Message Body]
    
    #响应报文
    [HTTP-Version] [Status Code] [Reason Phrase]
    [Headers]
    
    [Message Body]
    
    
    eg：
    HTTP/1.1 200 OK
    Date: Tue, 15 Dec 2023 12:00:00 GMT
    Server: Apache/2.4.38 (Unix)
    Content-Length: 1234 #表示报文主体的长度，以字节为单位
    Content-Type: text/html; charset=utf-8
    ```

    - **Method（方法）：** 指定HTTP请求的方法，常见的有 GET、POST、PUT、DELETE 等。
    - **Request-URI（请求资源标识符）：** 指定请求的资源路径，例如 `/path/to/resource`。
    - **HTTP-Version（HTTP协议版本）：** 指定所使用的HTTP协议的版本，常见的有 HTTP/1.0、HTTP/1.1、HTTP/2.0。
    - **Headers（报文头部）：** 包含了关于请求的各种信息，如主机、用户代理、内容类型等。每个头部字段以 `HeaderName: HeaderValue` 的格式表示。
    - **Message Body（消息主体）：** 可选项，包含发送给服务器的数据，通常在 POST 请求中使用。

26. **SSL的过程**

    1. **客户端发起握手请求：**
       - 客户端向服务器发送一个客户端Hello消息，该消息包含支持的SSL/TLS版本、加密算法、压缩算法等信息。
    2. **服务器响应：**
       - 服务器收到客户端Hello消息后，选择一个SSL/TLS版本，并从客户端提供的加密算法中选择一个。服务器向客户端发送一个服务器Hello消息，包含服务器选择的SSL/TLS版本和加密算法。
    3. **认证过程：**
       - 服务器将自己的**数字证书发送给客户端**。该证书包含**服务器的公钥**以及其他信息。客户端使用服务器的**证书验证服务器**的身份。客户端可能还发送一个证书链，其中包含根证书颁发机构（CA）的**公钥**。
    4. **密钥协商：**
       - 客户端生成一个随机的**对称密钥**（称为Pre-master Secret），使用服务器的公钥进行加密，然后将加密后的Pre-master Secret发送给服务器。服务器使用其**私钥解密**这个消息，得到Pre-master Secret。
    5. **生成会话密钥：**
       - 客户端和服务器使用协商得到的Pre-master Secret计算出一个共享的主密钥（Master Secret）。这个Master Secret被用来生成加密密钥、MAC密钥和初始化向量。
    6. **完成握手：**
       - 客户端和服务器分别发送Finished消息，用来验证握手是否成功完成。如果验证通过，握手过程就结束了。
    7. **加密通信：**
       - 客户端和服务器使用协商得到的密钥来加密和解密通信的数据。加密算法、MAC算法等都是在握手阶段协商确定的。

    整个握手过程确保了通信双方的身份验证、密钥协商的安全性，以及后续通信的机密性和完整性。握手完成后，客户端和服务器就可以开始安全地交换数据了。



27. **HTTPS是什么，TLS怎么实现的，证书是什么，公钥私钥干啥用的，发送端利用公钥加密后发送数据给对端，那对端通过什么加密？为什么前面要非对称后面要对称加密（从性能，复杂度进行解释）**

    **HTTPS是什么：**HTTPS是一种安全的网络传输协议，它在HTTP的基础上增加了SSL/TLS的加密层，用于保护数据的安全和完整性。
    **TLS怎么实现的：**TLS是传输层安全协议，它使用非对称加密和对称加密的结合，来建立安全的通信信道。
    **证书是什么：**证书是一种数字文件，它包含了网站的身份信息和公钥，由CA机构颁发，用于验证网站的真实性和防止中间人攻击。
    **公钥私钥：**公钥和私钥是非对称加密的两个密钥，公钥可以公开，用于加密数据或验证签名，私钥要保密，用于解密数据或生成签名。
    **发送端利用公钥加密**后发送数据给对端，那**对端就可以用私钥解密数据**，这样就保证了数据的机密性。
    **为什么前面要非对称后面要对称加密，**主要是因为非对称加密的效率比较低，而对称加密的效率比较高。所以通常的做法是，先用非对称加密协商出一个对称密钥，然后用对称密钥进行数据的加密和解密。

28. **cookie和session的区别**

29. **GET请求和POST请求的区别**

30. **HTTP返回状态码**

31. 



## 四.算法数据结构篇

1. **DFS以及BFS的应用场景都有哪些？**

   两者都可以用: 图以及树的遍历、迷宫问题


   DFS:  回溯

   BFS: 最短路径、树的层序遍历



2. **红黑树性质**

   红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，通过一系列规则确保树的高度平衡，从而保持较为稳定的搜索、插入和删除性能。红黑树得名于节点上的颜色标记，每个节点都带有一个颜色属性，可以是红色或黑色。

   红黑树的性质包括以下五点：

   1. **节点颜色：** 每个节点要么是红色，要么是黑色。

   2. **根节点：** 根节点是黑色的。

   3. **叶子节点：** 叶子节点（NIL 或空节点）是黑色的。

   4. **相邻节点：** 相邻的两个节点不能同时为红色，即红色节点不能连续出现。

   5. **路径黑色节点数：** 对于树中的任意一条路径，从根节点到叶子节点经过的黑色节点数目相同。

      

3. **回溯的时间复杂度**

   ​	回溯本质就是暴力搜索，如果解空间为N，时间复杂度为N^2

   

4. **小顶堆取出顶部元素之后，下面的元素怎么更新？**

   在小顶堆中，当取出堆顶元素后，为了保持堆的性质，需要进行**堆的调整**，通常是将堆的最后一个元素移动到堆顶，然后通过一系列比较和交换操作，将其下沉到正确的位置，以满足小顶堆的性质。

5. **哈希表，unordered_map，遇到冲突怎么办，分析一下时间复杂度**

   ​	它通过将关键字映射到表中的位置来实现快速的数据检索。哈希表通常用于实现集合、映射或关联数组等数据结构。

   ​	**链地址法（Separate Chaining）**：当发生冲突时，新键被追加到对应的链表上。

   ​	**开放寻址法（Open Addressing）**：当发生冲突时，会尝试寻找另一个空的哈希桶，直到找到一个空的位置为止。这可以通过线性探测、二次探测、双重散列等方法来实现。

   ​	**再哈希（Rehashing）**：当哈希表的负载因子（**已存储元素数量与哈希桶数量的比率**）过高时，可以选择重新调整哈希表的大小，增加桶的数量，并重新哈希所有的键值对。这样可以减少冲突的概率。

   

   **查找（Search）：**

   - 最坏情况：O(n)，当所有的键都散列到同一个桶上形成链表。
   - 平均情况：O(1 + α)，α 是负载因子，表示平均每个桶中的元素数量。

6. **动态规划、贪心和搜索这三个的区别**

   **动态规划：**动态规划将原问题拆解为子问题，要求子问题相互独立。

   **贪心**：局部最优可以推导出全局最优。

   **搜索：**需要遍历所有状态进行搜索。深搜、广搜、回溯。

7. **搜索的剪枝是什么呢**

   **减少搜索空间**以提高搜索效率。**排除**那些在问题的**解空间中没有意义**或**不可能包含最优解的部分**，从而缩小搜索范围，减少搜索时间。

8. **字典树，时间复杂度**

   一种**树形数据结构**（一棵多叉树），每个节点代表字符串的一个字符，用于**高效地存储**和检索**大量字符串**集合。主要优点在于它提供了高效的**字符串搜索和插入操作**，尤其适用于需要**快速查找**、**匹配和前缀匹**配的应用场景。
   **插入操作的复杂度：**假设字符串的平均长度为O*(*L)。

   

9. **游戏战力排行榜榜单用什么数据结构存储比较好** 
   **vector 的快排方法O(n):** 原来的数据已经有序，只需插入新的数据使得（左边小于右边大于），于是就自动有序了。

   **堆**O(n)：建立堆log(n)，遍历堆O(n)。

   **map红黑树:**同上

10. **跳表和一般链表的区别**

    跳表（Skip List）是一种数据结构，它基于**有序链表**并使用一些**额外的指针来允许快速的搜索、插入和删除操作**。它与普通链表的主要区别在于它具有多层结构，并且允许快速跳过不必要的节点，从而提高了搜索的效率。跳表是多层结构，除了包含向后指向下一个节点的指针外，还具有**额外的向前跳跃**到更远节点的**指针**。这些额外的指针使得跳表可以快速跳过多个节点，提高搜索效率。

    跳表通过多层的指针结构，可以进行类似二分查找的方式快速定位到目标节点。平均情况下，搜索的时间**复杂度为 O(log n)**，其中 n 是元素数量。

    

11. **快排的最好和最差时间复杂度，即使为什么最差的情况快排也比冒泡快**

    ​    快排的最好时间复杂度是O (nlogn)，最差时间复杂度是O (n^2)，平均时间复杂度是O (nlogn)。

    ​	即使在最差的情况下，快排也比冒泡快，这是因为快排的比较次数和冒泡相同，但是快排的交换次数要少于冒泡。冒泡排序每次比较后，如果发现**逆序**，就要进行一次**交换**，而快排**只有在一趟排序结束后**，才进行一次交换，将枢轴元素插入到正确的位置。**交换操作的时间开销要大于比较操作**，所以快排的效率要高于冒泡。

    

## 五.数据库篇

1. **MySQL索引底层数据结构，为啥不用二叉树，B树或者哈希表？**

   **B+数。**多路平衡二叉树。叶子节点使用双向循环链表串联，方便遍历。

   **为啥不用二叉树：**二叉树分裂节点只有2，数据多的话会导致数的层数很深，需要增加访问磁盘的次数。

   **为啥不用B树：**B数每个非叶子节点存储了数据（或者指针），会导致相同大小非叶子存储分裂个数减少，会增加数的层数。并且对于范围搜索没有B+树方便。

   **为啥不用哈希表：**哈希表一般基于内存，访问比较快。但是不支持范围查询。

   

2. **mysql为什么用可重复读而不用串行读、已提交读？**

   串行读：**性能与并发性会降低**、**锁的粒度会更小，性能开销大**

   已提交读：已提交读不能避免**不可重复读**的问题。确保不了数据一致性。

   

3. **MySQL的order by和group by会走索引吗？**

   取决于排序的字段是否有索引，如果包含函数、表达式或非索引列时，MySQL 可能无法使用索引来进行排序，导致全表扫描。

4. **说一下数据库事务**

5. **说一下MySql死锁怎么产生的**

6. **如何打破MySql死锁**

7. **MySql聚簇索引的实现是什么**

8. **B+树相比于B树的优势**

9. **MVCC机制说一下**

   

   

   

   

   

## 六.设计模式篇

1**.单例模式**

（见）八股https://space.jace.asia/docs/Cpp/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F

​	单例模式就是在这个单例类确保**只有一个对象被创建**。也就是说这个类只能实例化一个对象。避免资源的重复占用。数据库连接池、内存池等。

​	**饿汉模式：**线程安全，静态成员函数，程序执行前创建。

​	**懒汉模式**：可能不是线程安全，第一次调用创建。需要判空-加锁-判空创建。或者C++11机制，局部静态变量是线程安全的。

2. **懒汉式单例模式中线程安全需要两次判空，目的是什么**
   第一次判空是为了防止锁竞争，第二次判空是为了防止二次创建（两个线程同时进入第一次判空，则会创建2个对象）
3. 

2.**工厂模式**

（见）八股https://space.jace.asia/docs/Cpp/%E5%85%AB%E8%82%A1/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F

将类的创建和执行分离开来，减少代码耦合。

**简单工厂：**通过工厂类，返回父类指针，指向的创建传入参数对应的创建的子类。

**工厂方法：**每个把工厂类抽象出来，实现对应的产品类的接口。用于类接口不同的创建。

**抽象工厂：**抽象工厂模式把一个**产品簇的产品**放在一个**工厂类中去创建**，不仅大大减少了工厂类的个数，更符合现实中工厂生产产品的模式。

## 七.网络服务器篇

1. **proactor和reactor模式**

   "Reactor" 和 "Proactor" ，通常用于描述事件驱动编程中的不同策略。它们分别表示了两种不同的并发模型。

   ​	**Reactor 模式：**

   ​		Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个单独的事件分发器（Dispatcher）负责监听和接受连接（通常称为 Reactor 线程），当有事件发生时，分发器将事件分发给相应的处理器（Handlers）进行处理。

   **Proactor 模式：**

   - Proactor 也是一种处理并发 I/O 操作的并发模型，与 Reactor 不同，Proactor 更加关注异步处理。

   - Proactor 负责启动异步操作，监听这些操作的完成，并在操作完成时通知相应的 Handler。

   - Proactor 模式更适合高并发环境，因为它允许应用程序继续执行其他任务，而不必等待 I/O 操作完成。

     

2. **五种IO模型**
   **阻塞（阻塞等待数据）、非阻塞（立即返回，但是得循环读取）、IO多路复用（select、poll、epoll的区别）、信号驱动（复杂）、异步**
   **信号驱动：**信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。
   **异步**：数据准备和数据读取部分都是不阻塞的，当有数据来，直接处理好通知应用程序去读

   

3. **阻塞、非阻塞、同步、异步的区别**
   网络IO有数据准备和数据读取两个部分。阻塞、非阻塞发生在数据准备部分，区别为数据没准备好时能否立即返回。同步异步为数据准备好了通知应用程序的方式，同步为等待操作完成才能进行下一步操作，异步为不需要等待操作完成，而是继续执行其他任务，当执行完之后操作系统会通知程序。

   

4. **epoll是同步还是异步的？**

   IO层面，epoll是同步的。从消息处理层面，epoll是异步的。

   

5. **线程池数量如何确定？**

   - 任务是否是 CPU 密集型（计算密集型）还是 I/O 密集型（例如，网络请求、文件操作）？
   - 如果是 CPU 密集型任务，线程池的大小通常设置为 **CPU 核心数**。
   - 如果是 I/O 密集型任务，可以使用更多的线程，因为线程在等待 I/O 操作完成时可以执行其他任务。

​		

6. **IO多路复用**

   I/O多路复用的核心思想是使用一个**系统调用同时监听多个I/O事件**，当任何一个事件发生时，就通过**事件驱动**的方式进行**处理**。

   **select：**把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。

   ​			缺点：1.fd set大小有限制。2.fd数组拷贝到了内核态仍然有开销 3.select并没有通知用户态哪一个socket有数据，需要用户遍历。

   **poll**：是select的改进版，但是性能提升不明显，将fd set换成链表。select中的两个缺点还是存在。监听FD越多，每次遍历消耗时间也越久，性能反而会下降。

   **epoll：**epoll底层是通过红黑树实现，增删节点只需要logn的时间复杂度。epoll内核中维护了一个**内核事件表**，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发**回调**，无需手动遍历。通过**共享内存**的方式，无需重复拷贝FD到内核空间。

   epoll主要函数：epoll_create , epoll_ctl , epoll_wait 

   **LT和ET模式**

   

7. **Reactor模式的单线程模型了解吗，介绍一下？有哪些常见的系统或者服务器用了这个**
   Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个事件分发器负责监听和接受连接（通常称为 Reactor 线程），而其他的操作（如读写数据、处理业务逻辑）由对应的业务处理完成。但是单线程在处理业务时候无法处理其他连接，容易遇到性能瓶颈。

   实现方式：

   1. **事件注册：** 应用程序将事件（例如，socket 的读写事件）注册到 Reactor 中。
   2. **事件监听：** Reactor 线程负责监听注册的事件。这个调用通常会阻塞，等待有事件发生时才会返回。
   3. **事件分发：** 当有事件发生时，Reactor 线程会触发事件分发，将事件分发给相应的事件处理器（Handler）。
   4. **事件处理：**事件处理器负责具体的事件处理，包括读写数据、业务逻辑的执行等。这些操作在一个单线程中依次执行。

   

   **Redis，Nginx**：因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上

   
   
8. **怎么实现异步，有哪些应用场景和函数？**

   异步编程是一种并发编程的方式，允许程序在等待某些操作完成的同时执行其他操作。

   实现方式：回调函数 ，当完成一个异步操作后执行对应的回调函数

   应用场景：网络编程、并发编程、文件IO等

   

9. **服务器有一个连接进来，到应用程序读取到数据，需要经过几次内核态/用户态切换？需要几次缓冲区数据的拷贝？**

   ​		从网卡到应用程序，一般需要经过**两次内核态/用户态切换**，**三次缓冲区数据的拷贝**。当然，这个过程还可以通过一些技术来优化，如**零拷贝**等。

   1.当网卡收到数据包后，会触发一个硬件中断，这是第一次内核态/用户态切换。

   2.将数据包从网卡缓冲区拷贝到内核空间的缓冲区，这是第一次缓冲区数据的拷贝。

   3.内核会将数据包从内核空间的缓冲区拷贝到用户空间的socket对应的接收队列。这是第二次缓冲区数据的拷贝。

   4.内核会通知用户进程有新的数据到达，用户进程可以通过read()或者recv()等函数从socket的接收队列中读取数据。这是第二次内核态/用户态切换，也是第三次缓冲区数据的拷贝。

   

10. **介绍一下零拷贝**

    零拷贝（Zero Copy）是一种读写优化技术，旨在减少数据在系统内部的复制操作，提高数据传输的效率。在零拷贝中，数据可以在不涉及用户态和内核态之间的拷贝的情况下在系统内部传递。

    零拷贝的实现方式有多种，常见的有以下几种：

    **内存映射：**利用虚拟内存的特性，将**内核缓冲区**和**用户缓冲区**映射到同一个**物理地址**，从而省去一次CPU拷贝。

    **sendfile：**利用内核提供的sendfile系统调用，将文件数据直接从**内核缓冲区**传输到**socket缓冲区**。

    **DMA：DMA控制器**将数据从内核缓冲区拷贝到**网卡设备**，从而省去一次CPU拷贝。DMA（Direct Memory Access，直接内存访问）是一种计算机系统中的**数据传输技术**，旨在减轻中央处理器（CPU）对内存访问和数据传输的负担。DMA 允许**外围设备直接访问系统内存**，而**无需 CPU 的直接参与**。这样可以提高数据传输的效率，减少 CPU 的占用率，同时允许 CPU 在数据传输过程中执行其他任务。

    

11. **缓存的作用**

    **提高性能：**通过缓存数据，处理器不必等待慢速设备（如磁盘或网络）传输数据，从而允许它继续执行其他任务。

    **平衡处理速度不匹配：**各个组件的处理速度可能不匹配。CPU 处理速度通常比磁盘或网络传输速度快得多。通过使用缓冲区，可以平衡这种速度不匹配。

    

12. **epoll函数参数** 

    ```cpp
    int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
    ```

13. **搭建一个服务器需要做哪些工作？（socket api调用过程）** 

    创建套接字、绑定、监听、连接、读写数据

    

14. **长链接和短链接适用于哪些场景** 

    **长链接：**保持连接状态，适用于操作频繁、点对点的通信场景，例如**数据库连接**、**即时通讯**、**在线游戏**等。

    **短链接**：建立一次连接，任务结束就关闭。适用于**并发量大**、请求频率低的通信场景，例如**Web服务**、**电子商务**等。

15. **服务端出现异常如何告诉所有客户端** 

    使用 **try-catch** 语句来**捕获和处理异常**，然后通过某种**通信机制**（如websocket 、 **HTTP**、**TCP** 等）向客户端发送**错误信息或状态码**。如http状态码 **5xx**就是服务器端问题。

16. **异步IO与IO多路复用有什么区别**

    1. **调用方式：**
       - **异步I/O：** 在异步I/O中，当一个I/O操作被启动后，程序可以继续执行其他任务，而不需要等待I/O操作的完成。当I/O操作完成时，系统通知程序，然后程序再去处理已完成的I/O操作。
       - **I/O多路复用：** I/O多路复用是一种同步的机制，程序在调用I/O多路复用函数（如`select`、`poll`、`epoll`）时会被阻塞，直到其中任何一个文件描述符发生变化。
    2. **处理方式：**
       - **异步I/O：** 异步I/O使用**回调函数**或事件通知机制来处理I/O操作的完成。程序需要提供一个回调函数，在I/O完成时被调用。
       - **I/O多路复用：** I/O多路复用通过**轮询**或**事件驱动方式**检查多个文件描述符的状态变化，然后通知程序哪些文件描述符可以进行读取或写入操作。

    

    17. **粘包问题如何解决**

         粘包的问题出现是因为不知道一个用户**消息的边界在哪**。

        - 固定长度的消息；
        - 特殊字符作为边界； -- http
        - 自定义消息结构，消息头。

    

    18. **epoll 是如何实现的，内部的文件描述符表分别用的数据结构**

        epoll是Linux下的一种高效的**I/O多路复用机制**，它可以让**一个进程**监视**多个文件描述符**（fd），并在某个fd就绪时通知程序进行相应的操作。

        epoll的实现机制是通过**内核与用户空间**共享一个**事件表**，这个事件表中存放着所有需要监控的fd以及它们的状态，当**fd的状态发生变化时**，内核会将这个**事件通知给用户空间**，用户空间再根据事件类型进行相应的处理。

        

        epoll的内部数据结构主要有以下几个：
    
        eventpoll：这是epoll的核心结构，它包含了一个**红黑树**和一个就绪链表。红黑树用于存储所有**被监控**的**fd的节点数据**，就绪链表用于**存储就绪的fd**的节点数据。
        epitem：这是红黑树的节点结构，它包含了一个fd和一个epoll_event结构，epoll_event结构用于指定要监听的事件类型和用户数据。
        eppoll_entry：这是就绪链表的节点结构，它包含了一个epitem指针和一个双向链表的指针。
        epwaitqueue：这是epoll的等待队列结构，它用于将epoll_wait的调用者加入到等待队列中，当有事件就绪时，内核会唤醒等待队列中的进程。
    
    
    
    
    
    
    
    

## 八.linux篇

1. **Linux内存管理机制**

   1. **虚拟内存管理：**

      - Linux 使用虚拟内存来映射物理内存和磁盘空间，以提供更大的地址空间和更灵活的内存管理。
      - 虚拟内存通过页面（page）来进行管理，页面是内存和磁盘上的固定大小的块。

   2. **页面置换：**

      - 当系统内存不足时，Linux 会使用页面置换机制将不常用的页面从物理内存中置换到磁盘上，从而腾出空间供更紧急需要的页面使用。
      - 常见的页面置换算法包括最近最少使用（LRU）、时钟算法（Clock Algorithm）等。

   3. **内存压缩：**

      - 内存压缩是一种在内存不足时通过压缩内存页面来腾出空间的技术。

   4. **交换空间（Swap Space）：**

      - Linux 使用交换空间作为一种延伸内存的手段，将不活动的页面移动到交换空间中，从而腾出物理内存。

        

2. **Linux命令篇**

   **top：**top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。

   **scp**：用于不同linux主机之间复制文件的

   ```sh
   scp -P XXX local_file    remote_username@remote_ip:remote_file 
   ```

   **find**： Linux 和类Unix系统中用于查找文件和目录的命令。

   ```sh
   find [路径] [表达式]
   find /path/to/directory -name "filename*" #查找特定文件或目录
   find /path/to/directory -type f #查找所有普通文件 f ，目录 d
   find /path/to/directory -size +1M #大于 lM，小于1k -1k
   ```

   **grep：**在文本中搜索指定模式的强大命令。

   ```sh
   grep "pattern" filename #在文件中搜索特定字符串
   grep -r "pattern" /path/to/directory #递归地在目录及其子目录中搜索
   ```

   **tar**：打包解包命令

   **df** -h：用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。（-h表示用MDT显示）

   **ps：**查看进程占用

3. 

4. 

## 九.项目篇

1. 为什么要做这个项目？
2. 是**为了解决什么问题**？
3. 项目的性质是什么？
4. 有什么亮点？难点？
5. 运用了哪些技术?
6. 有什么收获？
7. Web服务器里怎么设计的IO复用
8. 是否有做压测
9. 请求是同时请求还是分开的
10. 你觉得现在一般大厂使用的支持百万千万并发的服务器与你这个项目是一个概念吗
11. 项目里用了线程池，线程池怎么建立起来的，为什么要用线程池
12. 那你从请求队列里取请求那不还是一个连接对应一个线程吗？
13. 然后就是各种解决问题的思路，难点，如何改进之类的了
14. Web服务器这个项目你用了线程池，线程池开多大的呢
15. 并发量你是怎么测试的
16. 怎么样进一步提高并发量呢
17. 为什么做一个web服务器，项目功能，改进点
18. 整个开发过程中有没有遇到困难，怎么解决的
19. 在实际场景中的效率或时间上的要求和提升嘛
20. 整个项目整个开发的一个环境是什么样的呢，实际环境以及算法运行下什么样的环境下
21. 能介绍一下在web服务器项目中做了什么样的测试和学习，有什么样的体会
22. 这个web服务器是运行在PC上还是嵌入式上
23. 比如说现在在多线程下调试会出现一些错误，可以说一下需要注意哪些地方，出错的原因一般在哪里
24. 多线程中出现的问题，一般通过什么途径进行debug呢
25. 在linux下还有进程，进程和线程有什么区别，为什么你选择采用线程
26. web服务器最主要的一个考量指标是并发处理能力，想问你为了提高并发量做了怎么样的操作
27. 什么是跳表 
28. 为什么不用哈希算法 
29. 跳表的数据结构 
30. 跳表具体做了什么，新增的东西 
31. 项目多少个文件，C++写的还是C写的 
32. 有哪些class 
33. 它的数据存储方式 
34. webserver项目最有价值的地方 
35. 介绍一下有代表性的项目
36. 介绍一下项目难点（动态线程池，小顶堆管理定时器）
37. 如何判断线程池任务队列上有没有等待线程
38. 动态线程池线程数达到最大后没有任务到来会不会销毁线程
39. epoll的优势是什么
40. 线程池中每个线程处理的任务都否一致
41. 开放题，如果一个线程池要处理多个不同的任务，怎么解决（读取任务后先判断任务类型，调用不同函数）
42. 为什么做跳表数据库而不用其他数据结构
43. 如何编译C代码
44. 项目中有几个文件
45. 多线程是如何处理的
46. 为什么采用模拟preator模型而不使用reactor模型
47. muduo 网络库中事件分发器的功能，是怎样设计的（muduo有时间深入去了解  一下）
48. 项目中用到了线程池分配线程具体来实现哪些功能
49. 介绍一下跳表数据库项目和跳表数据结构
50. 定期删除过期键值对如何实现的
51. 定期删除如何确定删除多少键值对
52. 说一下你认为你的项目中比较有难点的地方（动态线程池）
53. 这个线程池有没有和存在的开源项目比较呢
54. 多个线程同时访问LRU链表需要注意什么



## 十.其余篇

1. **构成一个计算机需要什么，各个组件做什么工作？**

   1. **中央处理器（Central Processing Unit，CPU）：**
      
      - **功能：** 执行计算机程序中的指令。
      - **工作：** 从内存中获取指令，执行算术和逻辑操作，并控制其他硬件设备。
      
   2. **内存（Memory）：**
      - **功能：** 存储计算机程序和数据，供 CPU 快速访问。
      - **工作：** 包括随机访问存储器（RAM）和只读存储器（ROM），RAM 用于临时存储数据和程序，而 ROM 存储固化的不变的程序和数据。

   3. **存储设备（Storage Devices）：**
      - **功能：** 提供长期存储，用于保存操作系统、应用程序和用户数据。
      - **工作：** 包括硬盘驱动器（HDD）、固态硬盘（SSD）、光盘驱动器等。

   4. **输入输出设备**

      

2. **很多小文件（总量1T）想从一台主机传输到另外一台主机，保证速度的前提下设计一个方案**

   **打包压缩：** 将小文件打包成压缩文件，然后进行传输。这样可以减少传输的文件数量，降低文件系统开销和网络开销。
   **并行传输：** 利用并行传输的方式提高传输速度。可以将文件分成多个部分，并同时传输这些部分。

   

3. **设计一个函数，这个函数没有任何输入，每次执行这个函数就会返回一个INT64的值，要保证返回的值是全局唯一的，也就是之前没有输出过的，怎么操作？**

   定义全局静态变量。

   

4. **读一个大文件和读很多个小文件效率是一样的吗？假设小文件总量和大文件大小一致**
     读取大文件时，文件内容通常在磁盘上是连续存储的，因此磁盘寻址时间相对较小。相比之下，读取许多小文件可能导致文件系统随机读取，磁盘寻址时间可能会增加。

5. **用现代C++语言写一个线程池**

6. 

## 十一.HR面试篇

1. 有没有实习经历
2. 和导师做过什么项目
3. C++接触多长时间了
4. 做导师的项目是自己选择还是他分配的
5. 项目来源
6. 这两个项目哪个印象比较深刻，如果想聊我们聊哪个
7. 项目是自己完成还是团体参与，独立完成的时候有没有和其他同学讨论交流过
8. 在选择任务的技术路线时如何佐证你的方案是可行的
9. 组会讨论是什么形式，你期望的是什么样的反馈
10. 如果你的想法和大家的反馈有冲突怎么办
11. 当你的任务有做偏了的情况在哪一步去进行挽回
12. 别人给你的反馈不一定是正确的，你觉得自己的思路更好，这种情况怎么处理
13. 对于更具有权威性的人提出的建议你是怎么考虑的
14. 合作的项目彼此之间进度不一的情况怎么处理
15. 研究生规划
16. 你觉得自己是偏技术钻研方向还是偏向业务（社交、组织协调）
17. 工作城市的选择
18. 实习时间
19. 优势和不足的点
20. 项目大概做了多长时间
21. 对这个项目的时间周期满意吗
22. 面试表现:评价比较正面。
23. 如何评价自己？
24. 朋友同事如何评价自己？
25. 最自豪的事情？
26. 最大的优点？觉得自己有什么缺点？
27. 怎么选公司？
28. 跟别的候选人比有什么优势
29. 对云怎么理解
30. 工作中最自豪的事情
31. 工作中有没有遇到需要和别的组协调的工作
32. 怎么处理同事间的分歧
33. 介绍项目
34. 和同事领导的相处方式
35. 校园竞赛经历
36. 校园干部经历
37. 问最近一次的比赛，聊了比较久一个人工智能的竞赛，问到了深度学习里用了什么网络模型，自己做了什么贡献、如何更新模型，怎么开展的，识别出错怎么办，如果遇到恶意攻击怎么办（说了一个自己的方案）
38. 业余爱好，怎么拿的奖
39. 聊竞赛，所有的竞赛全部问了一遍，感觉是看竞赛中的参与程度
40. 你觉得你在这几轮面试中你的优势是什么，劣势是什么
41. 面试完之后会复盘吗
42. 为什么选择字节跳动
43. 说一下职业规划，看到简历偏后端一些，是否会并不喜欢客户端的方向呢？
44. 个人的优势与短板
45. 你说擅长团队协作是因为自己带队作为负责人参与了很多比赛吗
46. 说一下你带团队时会考虑哪些问题，一个团队的关键点是什么
47. 大概什么时间能够到岗，实习多久
48. 对于转正你有什么问题吗
49. 对于工作的城市有要求吗
50. 家里对于工作地点上有意见吗
51. 进入到字节跳动团队后，你希望从你的mentor得到哪些帮助
52. 当你遇到问题你会主动找他人问吗
53. 有过压力很大时候吗？
54. 是怎样克服这个压力
55. 还有其他公司在面试吗
56. 对于这边的团队有了解吗
57. 薪资问题，年总包期望多少
58. 其他offer情况，目前还在面试的原因
59. 怎么看待我们公司，你投递的这个岗位，之前有了解过我们公司吗
60. 有没有偏好的工作方向
61. 有没有参与什么竞赛
62. 英文自我介绍一下？
63. 如果发放offer，你有多大倾向来我们公司
64. 工作地点倾向
65. 你有华为的实习经历啊，实习的部门是哪个，四级部门呢
66. 实习的感受怎么样，能学到东西你觉得
67. 做的东西和你的兴趣相匹配嘛
68. 把实习阶段的工作稍微详细的介绍一下，工作内容，角色
69. 你在华为实习期间感受到华为的企业文化和价值观是什么
70. 你适应华为工作的强度嘛
71. 你是一个什么性格的人
72. 你自己觉得学习能力怎么样，举个例子，比如项目中有没有起过什么作用
73. 你的家乡在哪里
74. 在学校期间还担任过什么学生工作吗
75. 你的技能是偏软件一些是吗
76. 考大学最大的困难 
77. 你认为你在学习能力方面怎么样 
78. 你印象比较深的学习且有成果的经历是什么 
79. 你认为科研对找工作有帮助吗 
80. 对工作的期望 
81. 收入期望 
82. 要北京户口 
83. 你对加班有什么看法 
84. 你有哪些优点和缺点 
85. 自我驱动力强的例子 
86. 你平时和谁在一起 
87. 实验室的同学对你的评价 
88. 你对舍友的评价
89. 实验室做什么方向
90. 为什么不走学术打算找工作
91. 研究生为什么选这个专业
92. 实验室其他人找的什么工作方向
93. 平时科研用到C++吗
94. 你了解大数据方向吗
95. 老家是哪里的
96. 对于未来工作城市是怎么考虑的
97. 哪些城市投递比较多
98. 实验室有打卡制度吗
99. 晚上一般会待到几点
100. 导师管理风格是宽松还是严格呢
101. 项目是自己学习的还是实验室的
102. 期望薪资是多少呢
103. 手上有面试进度比较快的公司吗
104. 期望薪资是怎样考虑的
105. 相同岗位杭州和一线城市薪资差距多少是可以接受的
106. 科研项目主要应用场景有哪些地方
107. 科研项目装置性能怎么样
108. 做科研项目时遇到的最大的困难是什么
109. 你遇到问题一般的解决方法是什么
110. 导师一般会给出有价值的建议吗
111. 遇到问题会焦虑吗，如何缓解
112. 你总结过汇报问题，解决问题的方法吗
113. 如何提升汇报问题的能力
114. 在新环境中如何做去融入环境
115. 假如你被分配了一项很困难的工作，自己无法完成你会怎么做呢
116. 做web服务器的体会是什么
117. web服务器能支持多少并发
118. 自我介绍
119. 硕士期间主要做哪些方面的研究
120. 选择一个项目详细介绍
121. 做这个项目的背景
122. 为什么想做软件开发
123. 你的项目是团队合作的项目吗
124. 合作时与其他人想法不一样会怎么做
125. 你坚持自己的想法的时候多还是参考其他人意见的时候多
126. 科研项目的创新点是什么
127. 整个项目中你承担了哪些责任
128. 什么样的人是你合作人不太想遇到的
129. 和其他人合作是你更关注他的性格还是能力
130. 为什么不找本专业的工作
131. 工作地点有哪些考虑
132. 有哪些在面试的企业
133. 你的工作意向地点有哪些
134. 你父母工作是什么
135. 你有女朋友吗
136. 对中兴你了解多少
137. 你师兄师姐有在天津工作的吗
138. 期望薪资是多少
139. 最近有找其他工作吗
140. 你对工作的期望是什么
141. 你平时的兴趣爱好
142. 举例子说明自学能力强，自我驱动能力强
143. 遇到了困难怎么解决
144. 你和同时对一件事意见不一致，怎么处理
145. 

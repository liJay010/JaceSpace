# 面试问题总结

## 一.CPP篇

1. **const关键字？**

   **const 修饰基本类型数据类型：**表示类型为常量不可以修改

   加在**函数前**表示返回值为const，加在**函数后面**表示函数里的值不可修改（在成员函数中）。

   **const 修饰指针变量和引⽤变量：**const在\*左侧为底层cost，表示指向那个变量不可改变。const在*右侧为顶层cost，表示指针本身为不可变。

   **const 成员变量**：表示对象中不可变，对于整个类可变。

   **const 修饰类对象**：常量对象只能调⽤常量函数，别的成员函数都不能调⽤。

   

2. **C++的内存结构**，**什么情况下使用堆区什么情况使用栈区**
   由高到底地址分别为：
   **栈区：**由编译器管理分配和回收，效率很高，但是分配的内存容量有限。存放局部变量和函数参数。
   **堆区:** 由程序员管理，需要⼿动分配和回收，空间较大但可能会出现内存泄漏和空闲碎⽚的情况。动态内存分配的时候使用。
   **全局/静态存储区:**存储初始化和未初始化的**全局变量**和**静态变量**。
   **常量区:**存储常量，⼀般不允许修改。
   **代码区:** 存放程序的⼆进制代码。

   

3. **动态链接库静态链接库特点、区别**

   **静态链接：**链接器在链接时将库的内容加入到可执行程序中。运行环境的依赖性较小，但是**生成的程序比较大**，**库函数有了更新，必须重新编译应用程序**

   **动态链接：**连接器在链接时仅仅建立与所需库函数的之间的链接关系，在程序运行时才将所需资源调入可执行程序。

   - 在需要的时候才会调入对应的资源函数

   - 简化程序的升级；有着较小的程序体积

   - 实现进程之间的资源共享（避免重复拷贝）

   - 依赖动态库，不能独立运行

   - 动态库依赖版本问题严重

     

4. **static关键字作用**

   在**全局变量**或者**普通函数**上改变作用域为当前文件可以访问。

   在**局部变量**上，改变局部变量生命周期为程序结束，并且只初始化一次。

   在类中**成员变量**上，所有对象共享同一份变量，可以通过类名访问，初始化必须在类外。

   **static成员函数**，可以通过类名访问，不含this指针，只能操作对应的static成员变量。

   

5. **面向对象三大特性**

   **封装：**将（成员变量）和（成员函数）打包在一个单元中，形成一个类。封装提供了对类内部实现的隐藏，使得代码更加模块化和可维护。

   **继承：**一个类（子类或派生类）可以使用另一个类（父类或基类）的属性和行为，并且可以扩展或修改它们。

   **多态：**多态是指同一个接口可以被用于不同的数据类型。父类指针可以指向不同的子类对象。
   多态分为（静态多态）和（动态多态）。

   静态多态通过**函数重载**和**运算符重**载来实现的，允许一个接口有多个不同的实现，这称为静态绑定。

   动态多态是通过**虚函数**和**抽象类**实现的。在运行时，同一个函数调用可能会**根据对象的实际类型**执行不同的代码，这称为动态绑定。

6. **虚函数相关（虚函数表，虚函数指针），虚函数的实现原理**

   ​	基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。

   类中包含虚函数时，编译器会为该类⽣成⼀个**虚函数表**，保存该类中**虚函数的地址**（编译期 - 在静态全局区）。定义⼀个派⽣类对 象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个**虚函数指针**，指向该类型的虚函数表，这个虚函数指针的**初始化**是在**构造函数中完成的**。后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻 找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。函数地址的晚绑定。

   

7. **函数调用的过程中堆栈的变化情况**

   - 当一个函数被调用时，栈帧被压入堆栈。

   - 被调用函数的**参数**被压入栈帧。

   - 函数的**局部变量**在栈帧中被分配空间。

   - 函数的**返回地址被推入栈帧**。

   - 被调用函数的栈帧被弹出，栈帧中的局部变量和参数的空间被释放。

     

8. **栈帧是什么**

   在**函数调用**过程中存储相关信息的一块**内存区域**，它被压入堆栈（栈）以支持函数的调用和返回。**每个函数**调用都会创建**一个新的栈帧**，该栈帧包含了与函数调用相关的信息，如**局部变量**、**函数参数**、**返回地址**和其他必要的控制信息。

9. **什么是内存泄漏、如何防止**

   程序员申请的动态内存空间在使用完没有释放，会导致内存资源浪费甚至内存不足系统崩溃。	
   防止：申请和释放内存要成对出现、使用智能指针、使用Rall思想，在构造函数中申请，析构函数中释放内存。

   

10. **介绍智能指针**

    智能指针其作⽤是管理⼀个指针，避免程序员申请的空间在函数结束时忘记释放，造成内存泄漏。智能指针就是⼀个类，当超出作⽤域会⾃动 调⽤析构函数，析构函数会⾃动释放资源。

    **unique_ptr**：独占式指针，同⼀时间内只有⼀个智能指针可以指向该对象。不能拷贝，可以用move转移资源。

    **shared_ptr**：共享式拥有概念，多个智能指针可以指向相同对象。每多一个指针指向它，引用计数+1，析构一个引用计数-1，减到0的时候释放空间。

    **weak_ptr**：弱引用，不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象，不会改变引用计数。为了解决shared_ptr循环引用导致内存泄漏问题。还可以使用lock函数解决多线程中线程安全问题。

    

11. **讲一下shared_ptr的内部结构**

    计数器（reference count）、指针和控制块（control block）

    控制块：包含计数器和一些额外的信息。

    

12. **宏定义，typedef区别**

    执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；

    define 是宏定义，发⽣在预处理阶段， 不进⾏类型检查，只是进行简单的文本替换；

13. **c++ 11新特性**

    智能指针、Lambda表达式、unordered_set/unordered_map、初始化成员列表、右值引用、范围for循环等

14. **C++程序的时候如果进程崩了，怎么排查问题**

    **核心转储（Core Dump）：**启用核心转储功能，以便在程序崩溃时生成核心转储文件。核心转储文件包含了崩溃时的内存状态，可以通过它进行后续调试。

    **分析核心转储：**使用调试器（例如 GDB）分析核心转储文件。在终端中执行 `gdb <your_program> core`，然后可以使用 `bt`（backtrace）命令查看函数调用栈，以确定程序崩溃的位置。

    **查看错误信息：**核心转储文件中可能包含有关崩溃原因的信息，可以查看这些信息，例如段错误（Segmentation Fault）或空指针引用。

    

15. **C++中原子操作有哪些库函数，怎么实现的？**

    主要通过\<atomic\>库实现，atomic有个类模板实现各个基本类型的原子操作。

    atomic_load（加载原子变量的值）、atomic_store（存储新的值到原子变量）、atomic_fetch_add 、atomic_fetch_sub （这两个函数用于原子地执行加法和减法操作）、atomic_exchange （交换原子变量的值）

    这些实现会利用底层的**硬件原子操作指令**或操作系统提供的**原子操作机制**来实现。

16. **Mutex加锁底层怎么实现的？**

    **原子操作：** Mutex 的实现通常依赖于原子操作，确保对共享资源的访问是原子的，即不会被中断。

    **等待策略：**等待策略是指当一个线程或进程没有获取到锁时，应该采取什么样的行为
    					**自旋等待（spin-wait）：**自旋等待是指线程或进程不断地检查锁的状态，直到获取到锁为止。这种策略适用于锁的竞争不激烈，等待时间较短的情况，因为它可以避免上下文切换的开销，但是也会浪费CPU资源。
    					**阻塞等待（block-wait）：**阻塞等待是指线程或进程在获取不到锁时，主动让出CPU，进入等待队列，等待被唤醒。这种策略适用于锁的竞争较激烈，等待时间较长的情况，因为它可以节省CPU资源，但是也会增加上下文切换的开销。

    **自旋锁：** 在 Mutex 的实现中，可能会使用自旋锁（Spin Lock）。自旋锁是一种在获取锁失败时不立即进入睡眠状态，而是反复尝试获取锁的锁实现。在实现上，可以使用**原子操作**来更新锁的状态，例如设置锁的**标志位**。

17. **vector是如何做内存管理的**

    1. **动态内存分配：** 当你向 `std::vector` 中添加元素时，如果当前的容量不足以存储新元素，`std::vector` 就会分配一块新的内存区域，通常是原来容量的两倍，然后将原来的元素拷贝到新的内存中。这是为了避免每次添加元素都进行内存分配，提高性能。

       **一级空间配置器**：

       - 负责大块内存的分配和释放。
       - 使用 `malloc` 和 `free` 进行内存的分配和释放。
       - 一般情况下，分配的内存较大，用于处理较大的对象，例如数组。

       **第二级（二级配置器）**：

       - 负责小块内存的分配和释放。
       - 利用 memory pool（内存池）管理小块内存。
       - 内部采用多个 free lists，每个 free list 存储一组大小相等的内存块，用于快速分配和释放。
       - 当 free list 中无法满足需求时，会调用第一级配置器进行大块内存的分配。

    2. **内存释放：** 当你从 `std::vector` 中删除元素或者清空整个容器时，它会释放相应的内存。这确保了 `std::vector` 只占用实际存储的元素所需的内存空间。

    3. **迭代器稳定性：** `std::vector` 的迭代器在插入或删除元素时的行为是相对稳定的。也就是说，在插入或删除元素后，指向修改点之前的迭代器仍然有效，而指向修改点之后的迭代器可能会失效。

    4. **连续内存：** `std::vector` 保证其元素在内存中是连续存储的，这使得访问元素更加高效，因为可以通过指针算术运算直接访问内存。

    5. **预留空间：** 你可以使用 `reserve` 函数预留一定的空间，这样在添加元素时，不必每次都重新分配内存，提高了性能。

18. **C++左值和右值**

    **右值：**无名字，无地址 （字面常量、临时对象、函数返回的临时值等都是右值。）

    **左值：**有名字，有地址（ 变量、对象、数组元素、引用等都是左值）

    **右值引用的特点：**通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。

    **右值拷贝（ move 构造函数）：**可以实现 move语义 ，即从右值中直接拿数据过来初始化 或修改左值， ⽽不需要重新构造左值后再析构右值。⼀个 move 构造函数是这样声明的。

    

19. **一个类有多个基类，内存中怎么虚函数表是怎么分布的？**

    对于多继承而言，每个**基类**都有自己的**虚函数表（vtable）**，而派生类会包含所有**基类的虚函数表**。
    

20. **怎么定位内存泄漏的位置？**

    使用专门的内存调试工具，如Valgrind（对于C/C++）。或者**自定义内存分配器**，手动记录分配情况。

21. **C++ shared_ptr如何保证线程安全？**

    c++11采用shared_timed_mutex，该互斥量可以用于对 `std::shared_ptr` 进行精细的线程安全控制。使用这个互斥量可以确保 `std::shared_ptr` 的引用计数操作是原子的。以及unique_lock分别用于共享和独占地锁定互斥量。

22. **C++如何解决线程安全问题？**

    **互斥锁（Mutex）**、**原子操作**、**条件变量（Condition Variable）**、**读写锁**

    条件变量：条件变量用于实现线程的等待和通知机制，以避免线程忙等。当某个条件不满足时，线程可以等待条件变量，而在条件满足时，其他线程可以通知等待的线程。

23. **C++派生类的构造和析构顺序是什么？为什么按照这种顺序？**

    1. **基类构造函数先于派生类构造函数调用**：

    2. **成员对象构造函数**

    3. **构造函数调用的顺序与继承层次一致**：

       - 如果有多层继承，构造函数的调用顺序与继承层次一致，从最顶层的基类开始逐级向下调用。

       **析构函数相反。**

       在构造过程中，派生类的构造函数需要调用基类的构造函数，而成员对象的构造函数则需要在它们所属的类的构造函数中调用。按照声明顺序调用这些构造函数可以确保依赖关系被正确建立。销毁按照反序可以确保资源在正确的时间点被获取和释放，避免资源泄漏。

24. **内存对齐有什么用？**

    经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，读取内存的时候是⼀块⼀块进⾏读取的。如果不对齐访存次数会增加，效率会较少。

25. **计算下⾯⼏个类的⼤⼩**

    ```cpp
    class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
    class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）
    class A{static int a; }; sizeof(A) = 1;
    class A{int a; }; sizeof(A) = 4;
    class A{static int a; int b; }; sizeof(A) = 4;
    ```

    

26. **介绍一下深拷贝与浅拷贝**

     **浅拷贝**是指将一个对象的数据复制到另一个对象中，但只复制对象本身和其所指向的所有指针，**而不复制指针所指向的内容**。因此，原对象和拷贝对象会共享同一块内存区域，其中的指针指向相同的数据。如果对象包含动态分配的资源（比如堆上的数组），两个对象的该资源将指向同一块内存。

     **深拷贝**是指将一个对象的数据复制到另一个对象中，不仅复制对象本身和其指针，还要**复制指针所指向的内容**。这样，原对象和拷贝对象拥有各自**独立的内存**，对一个对象的修改不会影响到另一个对象。
    

    

27. **说一下C++里面inline有什么用**

    **性能优化：** 减少函数调用的开销是 `inline` 最主要的目的之一，inline函数不会有函数压栈过程。

    **头文件中的函数定义：** 在头文件中定义函数时，通常需要使用 `inline`，以防止在多个编译单元中出现函数的多重定义错误。将函数定义放在头文件中，并标记为 `inline`，可以避免链接错误。

28. **讲一讲C++的new、delete和malloc、free的区别**

    都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。

    **执⾏ new 实际上执⾏两个过程：**

     1.分配未初始化的内存空间（malloc）；

     2.使⽤对象的**构造函数对空间进⾏初始 化**；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处 理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。

    **执⾏ delete 实际上也有两个过程：**

    1. 使⽤析构函数对对象进⾏析构；
    2. 回收内存空间（free）。

    

29. **emplace_back**

    可以就地构造对象，而不需要创建副本和频繁拷贝。这对于复杂的对象类型非常有用，可以避免不必要的对象复制和降低性能开销。

30. **C++ 中重载和重写，重定义的区别**

    **重载**：可以写不同参数列表的同名函数

    **重写**：派⽣类中重新定义⽗类中除了函数体外完全相同的**虚函数**。

    **重定义（隐藏）**：派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同。

31. **可变参数如何实现**

    va_list 

    ```cpp
    #include <iostream>
    #include <cstdarg>
    
    // 可变参数函数示例
    double average(int count, ...) {
        va_list args;
        va_start(args, count);
    
        double sum = 0;
        for (int i = 0; i < count; ++i) {
            sum += va_arg(args, double);
        }
    
        va_end(args);
    
        return sum / count;
    }
    
    int main() {
        std::cout << "Average: " << average(3, 1.2, 2.3, 3.4) << std::endl;
    
        return 0;
    }
    
    ```

32. **强制类型转换**

    C++ 的四种强制转换包括：**static_cast dynamic_cast const_cast reinterpret_cast**

    **static_cast：**明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类->基类）安全，下⾏转换（基类->派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；

    **dynamic_cast：**专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指 针，可能造成⾮法访问等问题。

    **const_cast：**专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个 可以操作常量的转换符。

    **reinterpret_cast：**不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解 释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。

33. **Main函数执行前发生了什么**

    **运行时环境初始化**：设置堆栈、初始化全局变量、静态变量、 如果程序中有全局或静态对象会在main函数之前调用

34. **为什么基类析构函数要求是虚函数**

    因为虚函数才能实现地址晚绑定的动态多态，继承的子类在执行析构时才能调用子类自己的析构函数。如果不为虚函数，就是静态多态，地址早绑定，子类析构调用的就是父类的析构，可能会导致内存泄漏。

35. **c++编译过程**

     预处理器→编译器→汇编器→链接器

    **预处理阶段：**写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如 #include 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件,删除注释。

    **编译阶段：**编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是**汇编语⾔程序**。⾼级语⾔是源程序。所以注意概 念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼ 级语⾔翻译的汇编语⾔相同。

    **汇编阶段：**汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀ 个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。

    **链接阶段：**⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个 名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得 到的是可执⾏⽬标⽂件。



36. **bss段是啥,有啥作用**

    在C语言中，BSS（Block Started by Symbol）段是可执行程序中的一部分，用于存储**未初始化的全局和静态变量**。bss段的数据在程序加载时由内核统一初始化为0，而不需要从磁盘或网络读取。提高加载速度。

    

37. 





## 二.操作系统篇

1. **进程和线程的区别**

   - 调度：线程是调度的基本单位（PC，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。

   - 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。

   - 系统开销：线程创建销毁只需要处理PC值，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁PCB结构以及相关资源，系统开销大。

     

2. **进程间的通信方式有哪些**

   - **管道：**
     - 无名管道（**内存文件**）：管道是一种**半双工的通信方式**，数据只能**单向流动**，而且只能在具有**亲缘关系的进程之间使用**。
     - 有名管道（FIFO文件，借助**文件系统**）：允许在没有亲缘关系的进程之间使用，管道是**先进先出**的通信方式。
   - **共享内存：**共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。
   - **消息队列：**存放在内核中并由**消息队列标识符标识**。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
   - **套接字：**适用于**不同机器间进程通信**，在本地也可作为两个进程通信的方式。
   - **信号：**用于通知接收**进程某个事件已经发生**，比如按下ctrl + C就是信号。
   - **信号量：**信号量是一个计数器，可以用来控制多个进程对**共享资源的访问**。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。

   

3. **介绍以下中断和异常的区别，以及中断处理步骤？**

   **中断：**由**外部设备或其他处理器发起**的，用于通知 CPU 有一个事件需要处理，例如 I/O 完成，敲击键盘等。然后CPU识别中断来源并发送给内核。分为硬中断和软中断，硬中断为硬件发起，软中断通常是由操作系统内核中的代码生成的，用于执行一些系统级的任务。
   **异常：**由CPU发起的，如遇到缺页、除0、访问非法内存异常等等。发送给内核。

   **中断处理步骤：**

   1. **中断发生：** 外部设备或其他处理器发出中断信号，通知 CPU 有事件需要处理。
   2. **保存当前上下文：** CPU 会保存当前执行的程序计数器、寄存器状态和其他必要的信息，以便在中断处理完成后能够恢复执行。
   3. **中断服务例程（ISR）的调用：** CPU跳转到中断向量表（Interrupt Vector Table）中的相应入口，开始执行中断服务例程。
   4. **恢复现场：** 在中断服务例程执行完毕后，CPU 恢复之前保存的上下文信息，包括程序计数器、寄存器等。
   5. **中断返回：** 执行完中断服务例程后，CPU 返回到被中断的程序，继续执行。

   

4. **内存映射和共享内存**

   **内存映射：**

   1. **映射方式：** 内存映射是将文件或其他对象映射到进程的地址空间，使得这些对象可以像内存一样被访问。这包括**文件映射**和**匿名映射**。
   2. **文件映射：** 主要用于将文件映射到内存，这样可以直接在内存中读取或写入文件数据，而无需通过传统的文件 I/O 操作。
   3. **匿名映射：** 创建一个与文件无关的映射，可以用于进程间通信或创建共享的内存区域。
   4. **使用场景：** 内存映射通常用于处理文件、数据库等大型数据集，或者用于多进程之间的通信。

   **共享内存：**

   1. **共享方式：** 共享内存是通过在不同的进程之间创建共享的内存区域，使得这些进程可以直接访问共享的内存段，而无需通过中间介质。
   2. **通信方式：** 共享内存主要用于进程间通信，允许多个进程之间快速、高效地共享数据。进程可以读取和写入共享内存中的数据，实现数据的共享。
   3. **使用场景：** 共享内存通常用于需要频繁交换大量数据的进程之间，以提高性能和效率。

   **区别总结：**

   1. **映射对象：** 内存映射主要涉及将文件或其他对象映射到进程的地址空间，而共享内存是直接在不同进程之间创建共享的内存区域。
   2. **用途：** 内存映射通常用于处理文件、数据库等数据集，而共享内存用于进程间通信，特别是需要频繁交换大量数据的情况。
   3. **实现机制：** 内存映射可以是文件映射或匿名映射，而共享内存是直接创建一块共享的内存区域。

5. **为啥要用虚拟内存，怎么实现？**

   虚拟内存通过内存和磁盘之间的映射，虚拟出来更大的内存空间，实现了隔离和保护机制。

   虚拟内存实现是基于分页或者分段实现，分页是将内存和磁盘分成大小相等的块，通过页面调度算法对页面进行换入和换出。通过页表对虚拟地址和逻辑地址的映射。分段是根据逻辑将进程分为数据段、代码段等，分配更灵活。

6. **自旋锁和互斥锁有什么区别？分别适合什么场景？**

   **自旋锁:**一种忙等待的锁,获取不到锁会CPU一直循环获取。适用于短时间内锁被占用的情况，并且并发量不大的情况，或者多CPU的情况。

   **互斥锁：**一种阻塞锁，获取不到锁会阻塞直到锁可用。互斥锁适用于长时间内锁被占用的情况，并发量大，或者单CPU的情况。

7. **为什么要设计内核态、用户态两种状态**

   **安全性：** 分离内核态和用户态可以防止用户程序直接对系统资源进行不受控制的访问，从而提高系统的安全性。

   **资源隔离：** 通过将系统划分为内核态和用户态，可以实现资源的隔离，使得一个程序的错误不会直接影响其他程序和整个系统。

8. **线程同步**

   ​		在多线程编程中，确保多个线程按照一定的**顺序和协调执行**，以避免并发访问共享资源时可能引发的问题，如**数据竞争**、**死锁**等。线程同步的目标是保证程序的**正确性和稳定性**。

   **互斥锁（Mutex）**、**信号量（Semaphore）**、**条件变量（Condition Variable）**、**读写锁（Read-Write Lock）**、**原子操作（Atomic Operation）**

   

9. **说一下缺页中断**

   缺页中断（Page Fault）是计算机操作系统中的一种异常情况，发生在程序试图访问尚未调入内存的页面时。当程序**访问的页面不在主内存中**，操作系统会触发缺页中断，以便将相应的**页面调入内存**，然后重新执行导致缺页的指令。

   1. **访问缺页：** 当程序试图访问一个尚未在主内存中的页面时，例如由于页面被换出到磁盘或者是首次访问的页面，CPU会产生一个缺页异常。
   2. **触发中断：** 缺页异常导致CPU暂停当前执行的程序，并向操作系统发出一个中断请求，即缺页中断。
   3. **操作系统处理：** 操作系统的缺页中断处理程序被调用。该处理程序的任务是将所需的页面从磁盘或其他辅助存储器加载到主内存中。
   4. **更新页表：** 一旦页面被加载到主内存，操作系统更新页表，以便将虚拟地址与物理地址进行映射。
   5. **重新执行指令：** 缺页中断处理完毕后，CPU重新执行导致缺页的指令，这次访问将成功，因为所需的页面现在已经在主内存中了。

10. 

    

    

    

    

    

    

    

    

    

## 三.计算机网络篇

1. **介绍一下OSI七层协议，各层协议都有哪些**

   1. **物理层（Physical Layer）：**
      - 功能：传输比特流，主要关注物理介质、电流、编码等。
      - 协议：没有特定的协议，主要涉及硬件标准（如Ethernet、Wi-Fi等）。
   2. **数据链路层（Data Link Layer）：**
      - 功能：负责将比特流组织成帧，进行错误检测和纠正。
      - 协议：ARP（Address Resolution Protocol）等。
   3. **网络层（Network Layer）：**

      - 功能：负责在不同网络之间进行路由和转发，实现端到端的数据传输。
      - 协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等。
   4. **传输层（Transport Layer）：**
      - 功能：提供端到端的通信，负责数据的可靠性、流量控制和错误恢复。
      - 协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。
   5. **会话层（Session Layer）：**

      - 功能：管理和协调会话，确保数据传输的正确顺序。
      - 协议：NetBIOS（Network Basic Input/Output System）等。
   6. **表示层（Presentation Layer）：**

      - 功能：处理数据的表示和格式，确保应用层能够解释数据。
      - 协议：JPEG、GIF、SSL/TLS（Secure Sockets Layer/Transport Layer Security）等。
   7. **应用层（Application Layer）：**

      - 功能：为用户提供网络服务，是网络应用程序的接口。
      - 协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、DNS（Domain Name System）等。
        

2. **输入一个网页，到出现页面，这中间发送了什么？**

   - 域名解析DNS
   - 发起TCP的3次握手
   - 建立TCP连接后发起http请求
   - 服务器响应http请求，浏览器得到html代码
   - 浏览器解析html代码，并请求html代码中的资源
   - 浏览器对页面进行渲染呈现给用户。
     

3. **TCP三次握手**

   1. **客户端发起连接请求：**
      
      - 客户端首先向服务器发送一个TCP报文，其中设置了SYN（同步）标志位，并选择一个初始序列号（ClientISN）。
   2. **服务器确认连接请求并发起连接：**
      - 服务器收到客户端的SYN报文后，会发送一个带有SYN和ACK（确认）标志位的TCP报文作为响应。
      - 服务器也会选择一个自己的初始序列号（ServerISN），并在ACK字段中确认客户端的初始序列号（ClientISN + 1）。
      - 同时服务器会将第二次握手的客户端加入到半连接队列。
   3. **客户端确认连接：**
      - 客户端收到服务器的响应后，向服务器发送一个带有ACK标志位的TCP报文，确认服务器的初始序列号（ServerISN + 1）。
      - 第三次握手可以数据
        
        

4. **为什么TCP三次握手，两次握手可以吗**

   三次握手是为了确保双方都有发送和接收数据的能力。两次握手不可以，第三次握手是为了防止历史失效连接再次请求，导致资源浪费。

5. **TCP四次挥手**

   1. **主动关闭方发送连接释放报文（FIN）：**
      - 主动关闭方（一般是客户端）首先发送一个TCP报文，其中设置了FIN标志位，表示它已经完成发送数据，希望关闭连接。表示已经没有数据要发送了。
      - 这个FIN报文中还包含一个序列号，用于标识主动关闭方的数据已经发送完毕的位置。

   2. **被动关闭方确认收到释放报文：**
      - 被动关闭方（一般是服务器）收到主动关闭方的FIN报文后，会向主动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了主动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认主动关闭方的序列号。

   3. **被动关闭方发送连接释放报文（FIN）：**
      - 被动关闭方在完成了自己的数据发送后，也会发送一个TCP报文，其中设置了FIN标志位，表示它希望关闭连接。
      - 这个FIN报文中也包含一个序列号，用于标识被动关闭方的数据已经发送完毕的位置。

   4. **主动关闭方确认收到释放报文：**
      - 主动关闭方收到被动关闭方的FIN报文后，向被动关闭方发送一个确认报文，其中设置了ACK标志位，表示已经收到了被动关闭方的释放请求。
      - 这个确认报文中包含一个序列号，用于确认被动关闭方的序列号。

   5. **四次挥手的2MSL有什么用**

      ​	等戴2MSL作用防止历史报文发送到服务器产生混乱。也能让服务端正确关闭（若服务器迟迟没有收到第四次报文，会重发第三次报文）。

6. **TCP和UDP的区别，什么时候用tcp什么时候用udp？**

   **TCP：**面向连接一对一，可靠通信、字节流、有流量控制以及拥塞控制。

   **UDP**：无连接、不可靠、低延迟、可以一对多。

   对于文件完整性和可靠性有要求用TCP，如文件传输等等。对于时间要求使用UDP，如视频通话，游戏等等。

   

7. **udp丢包会有什么现象？**

   **数据丢失**

   **乱序**

   **延迟变化**

   

8. **http和https的区别**

   都是用于在网络上传输数据的协议，它们之间的主要区别在于安全性和加密。

   - **HTTP：** 传输的数据是明文的，不经过加密处理。
   - **HTTPS：** 使用SSL/TLS协议对数据进行加密，确保传输的数据在网络上是安全的。

   

9. **滑动窗口-流量控制作用**

   ​		用于流量控制。发送方和接收方都维护一个滑动窗口，表示可以发送或接收的数据帧的范围。发送方通过滑动窗口的机制动态调整发送的数据量，以保证在网络状况允许的情况下提高传输速度。

   

10. **拥塞控制**

    拥塞控制通过监测网络中的拥塞情况，采取一系列策略来调整数据流的速率，以避免网络过载。慢启动、拥塞避免、快速重传、快速恢复等。

    

11. **流量控制和拥塞控制差异**

    滑动窗口主要关注单个通信连接的数据流控制，而拥塞控制关注整个网络中的拥塞情况。

    

12. **服务端的socket接收缓冲区只剩10个字节，但是客户端发过来一个未经过分片的12个字节的报文。之后客户端和服务端分别会发生什么事情？如果服务端的接收窗口变为0会怎么样？**（看）

    ​		这个问题的答案可能取决于具体的**网络协议和阻塞模式**，但一般来说，可以参考以下的情况：

    ​		**TCP协议**，那么客户端发送的报文会被分片为两个TCP段，每个段的大小为6个字节。服务端会接收到第一个段，并将其存入接收缓冲区，然后向客户端发送一个ACK，表示已经收到了6个字节的数据。但是由于服务端的接收缓冲区已经满了，无法接收更多的数据，所以**服务端会丢弃第二段报文**，并向**客户端发送一个窗口大小为0的通知**，表示**暂时不能接收数据**。客户端收到窗口大小为0的通知后，**会停止发送数据**，并启动**重传定时器，等待服务端的窗口大小变大**。服务端在读取了接收缓冲区中的数据后，**会向客户端发送一个新的窗口大小**，表示可以接收数据了。
    ​	**UDP协议**，那么客户端发送的报文不会被分片，而是作为一个整体的UDP数据报发送出去。服务端会接收到这个数据报，但是由于接收缓冲区只有10个字节的空间，无法存放12个字节的数据，所以**服务端会丢弃这个数据报**，并向**客户端发送一个ICMP差错报文**，表示**目的地不可达**。客户端收到这个差错报文后，会知道数据没有被成功发送，但是**UDP协议并不提供重传机制**，所以客户端需要自己决定是否重新发送数据。服务端在读取了接收缓冲区中的其他数据后，会释放出空间，但是并不会主动通知客户端，所以客户端需要自己判断何时可以重新发送数据。

    

13. **TCP的keep-alive和HTTP的keep-alive有什么区别？**

    **TCP Keep-Alive：**于在长时间没有数据传输时保持 TCP 连接的活跃状态，以防止连接因为长时间的空闲而被中断。周期性地向对方发送一个小的探测包（Probe）来实现的。如果一定时间内没有收到对方的响应，就会认为连接已经失效，然后关闭连接。

    **HTTP 的 Keep-Alive：**用于在**一次 TCP 连接上发送多个 HTTP 请求**，而不是每次请求都建立一个新的 TCP 连接。这可以减少连接建立和断开的开销，提高性能。
    
14. **udp不需要建立连接，那是不是所有人都可以向我发送数据**

​		由于UDP不涉及连接的建立和维护，发送方可以随时向接收方发送数据，而不需要进行握手等步骤。但是在应用层可以，使用加密来确保数据的机密性，或者使用其他手段验证数据的来源。

15. **如何实现读写锁，以及读写优先级**

    **基于信号量：**使用一个值记录读者数量，以及个信号量。一个信号量用与保护更新读者数量的互斥。另一个信号量，用于读写锁的互斥操作。

    ​	对于获取读锁，首先获取数量互斥锁，然后获取读写互斥锁，如果获取到，将读数量加一。读取完释放数量互斥锁，以及读写互斥锁。

    ​	对于写锁，直接获取读写互斥锁就行。


    **基于原子操作和自旋等待：**使用一个原子变量表示锁的状态，其中高位表示读者的数量，低位表示写者的标志。当一个线程想要获取读锁时，需要先检查是否有写者正在执行或等待，如果有，就自旋等待，否则就使用原子操作将高位加1，表示增加一个读者。当一个线程想要获取写锁时，需要先检查是否有读者或写者正在执行，如果有，就自旋等待，否则就使用原子操作将低位设置为1，表示设置一个写者。当一个线程释放读锁时，需要使用原子操作将高位减1，表示减少一个读者。当一个线程释放写锁时，需要使用原子操作将低位清零，表示清除一个写者

- 读者优先：当有读者请求读锁时，如果没有写者正在执行或等待，就立即给予读锁，否则就等待写者完成。这样可以提高读者的并发性，但可能导致写者饥饿。
- 写者优先：当有写者请求写锁时，如果没有读者或写者正在执行，就立即给予写锁，否则就等待读者或写者完成。这样可以提高写者的响应性，但可能导致读者饥饿。
- 读者-写者公平：当有读者或写者请求锁时，按照先来先服务的原则，给予锁。这样可以保证读者和写者之间的公平性，但可能降低读者的并发性。











​		







## 四.算法数据结构篇

1. **DFS以及BFS的应用场景都有哪些？**

   两者都可以用: 图以及树的遍历、迷宫问题


   DFS:  回溯

   BFS: 最短路径、树的层序遍历



2. **红黑树性质**

   红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，通过一系列规则确保树的高度平衡，从而保持较为稳定的搜索、插入和删除性能。红黑树得名于节点上的颜色标记，每个节点都带有一个颜色属性，可以是红色或黑色。

   红黑树的性质包括以下五点：

   1. **节点颜色：** 每个节点要么是红色，要么是黑色。

   2. **根节点：** 根节点是黑色的。

   3. **叶子节点：** 叶子节点（NIL 或空节点）是黑色的。

   4. **相邻节点：** 相邻的两个节点不能同时为红色，即红色节点不能连续出现。

   5. **路径黑色节点数：** 对于树中的任意一条路径，从根节点到叶子节点经过的黑色节点数目相同。

      

3. **回溯的时间复杂度**

   ​	回溯本质就是暴力搜索，如果解空间为N，时间复杂度为N^2

   

4. **小顶堆取出顶部元素之后，下面的元素怎么更新？**

   在小顶堆中，当取出堆顶元素后，为了保持堆的性质，需要进行**堆的调整**，通常是将堆的最后一个元素移动到堆顶，然后通过一系列比较和交换操作，将其下沉到正确的位置，以满足小顶堆的性质。

5. **哈希表，unordered_map，遇到冲突怎么办，分析一下时间复杂度**

   ​	它通过将关键字映射到表中的位置来实现快速的数据检索。哈希表通常用于实现集合、映射或关联数组等数据结构。

   ​	**链地址法（Separate Chaining）**：当发生冲突时，新键被追加到对应的链表上。

   ​	**开放寻址法（Open Addressing）**：当发生冲突时，会尝试寻找另一个空的哈希桶，直到找到一个空的位置为止。这可以通过线性探测、二次探测、双重散列等方法来实现。

   ​	**再哈希（Rehashing）**：当哈希表的负载因子（**已存储元素数量与哈希桶数量的比率**）过高时，可以选择重新调整哈希表的大小，增加桶的数量，并重新哈希所有的键值对。这样可以减少冲突的概率。

   

   **查找（Search）：**

   - 最坏情况：O(n)，当所有的键都散列到同一个桶上形成链表。
   - 平均情况：O(1 + α)，α 是负载因子，表示平均每个桶中的元素数量。

6. 

7. 

8. 

## 五.数据库篇

1. **MySQL索引底层数据结构，为啥不用二叉树，B树或者哈希表？**

   **B+数。**多路平衡二叉树。叶子节点使用双向循环链表串联，方便遍历。

   **为啥不用二叉树：**二叉树分裂节点只有2，数据多的话会导致数的层数很深，需要增加访问磁盘的次数。

   **为啥不用B树：**B数每个非叶子节点存储了数据（或者指针），会导致相同大小非叶子存储分裂个数减少，会增加数的层数。并且对于范围搜索没有B+树方便。

   **为啥不用哈希表：**哈希表一般基于内存，访问比较快。但是不支持范围查询。

   

2. **mysql为什么用可重复读而不用串行读、已提交读？**

   串行读：**性能与并发性会降低**、**锁的粒度会更小，性能开销大**

   已提交读：已提交读不能避免**不可重复读**的问题。确保不了数据一致性。

   

3. **MySQL的order by和group by会走索引吗？**

   取决于排序的字段是否有索引，如果包含函数、表达式或非索引列时，MySQL 可能无法使用索引来进行排序，导致全表扫描。

4. 

   

   

   

   

   

   

## 六.设计模式篇



## 七.网络服务器篇

1. **proactor和reactor模式**

   "Reactor" 和 "Proactor" ，通常用于描述事件驱动编程中的不同策略。它们分别表示了两种不同的并发模型。

   ​	**Reactor 模式：**

   ​		Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个单独的事件分发器（Dispatcher）负责监听和接受连接（通常称为 Reactor 线程），当有事件发生时，分发器将事件分发给相应的处理器（Handlers）进行处理。

   **Proactor 模式：**

   - Proactor 也是一种处理并发 I/O 操作的并发模型，与 Reactor 不同，Proactor 更加关注异步处理。

   - Proactor 负责启动异步操作，监听这些操作的完成，并在操作完成时通知相应的 Handler。

   - Proactor 模式更适合高并发环境，因为它允许应用程序继续执行其他任务，而不必等待 I/O 操作完成。

     

2. **五种IO模型**
   **阻塞（阻塞等待数据）、非阻塞（立即返回，但是得循环读取）、IO多路复用（select、poll、epoll的区别）、信号驱动（复杂）、异步**
   **信号驱动：**信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。
   **异步**：数据准备和数据读取部分都是不阻塞的，当有数据来，直接处理好通知应用程序去读

   

3. **阻塞、非阻塞、同步、异步的区别**
   网络IO有数据准备和数据读取两个部分。阻塞、非阻塞发生在数据准备部分，区别为数据没准备好时能否立即返回。同步异步为数据准备好了通知应用程序的方式，同步为等待操作完成才能进行下一步操作，异步为不需要等待操作完成，而是继续执行其他任务，当执行完之后操作系统会通知程序。

   

4. **epoll是同步还是异步的？**

   IO层面，epoll是同步的。从消息处理层面，epoll是异步的。

   

5. **线程池数量如何确定？**

   - 任务是否是 CPU 密集型（计算密集型）还是 I/O 密集型（例如，网络请求、文件操作）？
   - 如果是 CPU 密集型任务，线程池的大小通常设置为 **CPU 核心数**。
   - 如果是 I/O 密集型任务，可以使用更多的线程，因为线程在等待 I/O 操作完成时可以执行其他任务。

​		

6. **IO多路复用**

   **select：**把需要轮询的fd集合复制到内核空间，然后由内核来负责轮询，这样就避免了用户态和内核态之间的切换，也避免了轮询的效率低下的问题。

   ​			缺点：1.fd set大小有限制。2.fd数组拷贝到了内核态仍然有开销 3.select并没有通知用户态哪一个socket有数据，需要用户遍历。

   **poll**：是select的改进版，但是性能提升不明显，将fd set换成链表。select中的两个缺点还是存在。监听FD越多，每次遍历消耗时间也越久，性能反而会下降。

   **epoll：**epoll底层是通过红黑树实现，增删节点只需要logn的时间复杂度。epoll内核中维护了一个**内核事件表**，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发**回调**，无需手动遍历。通过**共享内存**的方式，无需重复拷贝FD到内核空间。

   epoll主要函数：epoll_create , epoll_ctl , epoll_wait 

   **LT和ET模式**

   

7. **Reactor模式的单线程模型了解吗，介绍一下？有哪些常见的系统或者服务器用了这个**
   Reactor 模式是一种事件驱动编程模型，用于处理并发 I/O 操作。在 Reactor 模式中，有一个事件分发器负责监听和接受连接（通常称为 Reactor 线程），而其他的操作（如读写数据、处理业务逻辑）由对应的业务处理完成。但是单线程在处理业务时候无法处理其他连接，容易遇到性能瓶颈。

   实现方式：

   1. **事件注册：** 应用程序将事件（例如，socket 的读写事件）注册到 Reactor 中。
   2. **事件监听：** Reactor 线程负责监听注册的事件。这个调用通常会阻塞，等待有事件发生时才会返回。
   3. **事件分发：** 当有事件发生时，Reactor 线程会触发事件分发，将事件分发给相应的事件处理器（Handler）。
   4. **事件处理：**事件处理器负责具体的事件处理，包括读写数据、业务逻辑的执行等。这些操作在一个单线程中依次执行。

   

   **Redis，Nginx**：因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上

   
   
8. **怎么实现异步，有哪些应用场景和函数？**

   异步编程是一种并发编程的方式，允许程序在等待某些操作完成的同时执行其他操作。

   实现方式：回调函数 ，当完成一个异步操作后执行对应的回调函数

   应用场景：网络编程、并发编程、文件IO等

   

9. **服务器有一个连接进来，到应用程序读取到数据，需要经过几次内核态/用户态切换？需要几次缓冲区数据的拷贝？**

   ​		从网卡到应用程序，一般需要经过**两次内核态/用户态切换**，**三次缓冲区数据的拷贝**。当然，这个过程还可以通过一些技术来优化，如**零拷贝**等。

   1.当网卡收到数据包后，会触发一个硬件中断，这是第一次内核态/用户态切换。

   2.将数据包从网卡缓冲区拷贝到内核空间的缓冲区，这是第一次缓冲区数据的拷贝。

   3.内核会将数据包从内核空间的缓冲区拷贝到用户空间的socket对应的接收队列。这是第二次缓冲区数据的拷贝。

   4.内核会通知用户进程有新的数据到达，用户进程可以通过read()或者recv()等函数从socket的接收队列中读取数据。这是第二次内核态/用户态切换，也是第三次缓冲区数据的拷贝。

   

10. **介绍一下零拷贝**

    零拷贝（Zero Copy）是一种读写优化技术，旨在减少数据在系统内部的复制操作，提高数据传输的效率。在零拷贝中，数据可以在不涉及用户态和内核态之间的拷贝的情况下在系统内部传递。

    零拷贝的实现方式有多种，常见的有以下几种：

    **内存映射：**利用虚拟内存的特性，将**内核缓冲区**和**用户缓冲区**映射到同一个**物理地址**，从而省去一次CPU拷贝。

    **sendfile：**利用内核提供的sendfile系统调用，将文件数据直接从**内核缓冲区**传输到**socket缓冲区**。

    **DMA：DMA控制器**将数据从内核缓冲区拷贝到**网卡设备**，从而省去一次CPU拷贝。DMA（Direct Memory Access，直接内存访问）是一种计算机系统中的**数据传输技术**，旨在减轻中央处理器（CPU）对内存访问和数据传输的负担。DMA 允许**外围设备直接访问系统内存**，而**无需 CPU 的直接参与**。这样可以提高数据传输的效率，减少 CPU 的占用率，同时允许 CPU 在数据传输过程中执行其他任务。

    

11. **缓存的作用**

    **提高性能：**通过缓存数据，处理器不必等待慢速设备（如磁盘或网络）传输数据，从而允许它继续执行其他任务。

    **平衡处理速度不匹配：**各个组件的处理速度可能不匹配。CPU 处理速度通常比磁盘或网络传输速度快得多。通过使用缓冲区，可以平衡这种速度不匹配。

    

12. 

## 八.linux篇

1. **Linux内存管理机制**

   1. **虚拟内存管理：**

      - Linux 使用虚拟内存来映射物理内存和磁盘空间，以提供更大的地址空间和更灵活的内存管理。
      - 虚拟内存通过页面（page）来进行管理，页面是内存和磁盘上的固定大小的块。

   2. **页面置换：**

      - 当系统内存不足时，Linux 会使用页面置换机制将不常用的页面从物理内存中置换到磁盘上，从而腾出空间供更紧急需要的页面使用。
      - 常见的页面置换算法包括最近最少使用（LRU）、时钟算法（Clock Algorithm）等。

   3. **内存压缩：**

      - 内存压缩是一种在内存不足时通过压缩内存页面来腾出空间的技术。

   4. **交换空间（Swap Space）：**

      - Linux 使用交换空间作为一种延伸内存的手段，将不活动的页面移动到交换空间中，从而腾出物理内存。

        

2. 

## 九.项目篇

1. 为什么要做这个项目？
2. 是**为了解决什么问题**？
3. 项目的性质是什么？
4. 有什么亮点？难点？
5. 运用了哪些技术?
6. 有什么收获？
7. Web服务器里怎么设计的IO复用
8. 是否有做压测
9. 请求是同时请求还是分开的
10. 你觉得现在一般大厂使用的支持百万千万并发的服务器与你这个项目是一个概念吗
11. 项目里用了线程池，线程池怎么建立起来的，为什么要用线程池
12. 那你从请求队列里取请求那不还是一个连接对应一个线程吗？
13. 
14. 



## 十.其余篇

1. **构成一个计算机需要什么，各个组件做什么工作？**

   1. **中央处理器（Central Processing Unit，CPU）：**
      - **功能：** 执行计算机程序中的指令。
      - **工作：** 从内存中获取指令，执行算术和逻辑操作，并控制其他硬件设备。

   2. **内存（Memory）：**
      - **功能：** 存储计算机程序和数据，供 CPU 快速访问。
      - **工作：** 包括随机访问存储器（RAM）和只读存储器（ROM），RAM 用于临时存储数据和程序，而 ROM 存储固化的不变的程序和数据。

   3. **存储设备（Storage Devices）：**
      - **功能：** 提供长期存储，用于保存操作系统、应用程序和用户数据。
      - **工作：** 包括硬盘驱动器（HDD）、固态硬盘（SSD）、光盘驱动器等。

   4. **输入输出设备**

      

2. **很多小文件（总量1T）想从一台主机传输到另外一台主机，保证速度的前提下设计一个方案**

   **打包压缩：** 将小文件打包成压缩文件，然后进行传输。这样可以减少传输的文件数量，降低文件系统开销和网络开销。
   **并行传输：** 利用并行传输的方式提高传输速度。可以将文件分成多个部分，并同时传输这些部分。

   

3. **设计一个函数，这个函数没有任何输入，每次执行这个函数就会返回一个INT64的值，要保证返回的值是全局唯一的，也就是之前没有输出过的，怎么操作？**

   定义全局静态变量。

   

4. **读一个大文件和读很多个小文件效率是一样的吗？假设小文件总量和大文件大小一致**
     读取大文件时，文件内容通常在磁盘上是连续存储的，因此磁盘寻址时间相对较小。相比之下，读取许多小文件可能导致文件系统随机读取，磁盘寻址时间可能会增加。

5. 

6. 

## 十一.HR面试篇

1. 有没有实习经历
2. 和导师做过什么项目
3. C++接触多长时间了
4. 做导师的项目是自己选择还是他分配的
5. 项目来源
6. 这两个项目哪个印象比较深刻，如果想聊我们聊哪个
7. 项目是自己完成还是团体参与，独立完成的时候有没有和其他同学讨论交流过
8. 在选择任务的技术路线时如何佐证你的方案是可行的
9. 组会讨论是什么形式，你期望的是什么样的反馈
10. 如果你的想法和大家的反馈有冲突怎么办
11. 当你的任务有做偏了的情况在哪一步去进行挽回
12. 别人给你的反馈不一定是正确的，你觉得自己的思路更好，这种情况怎么处理
13. 对于更具有权威性的人提出的建议你是怎么考虑的
14. 合作的项目彼此之间进度不一的情况怎么处理
15. 研究生规划
16. 你觉得自己是偏技术钻研方向还是偏向业务（社交、组织协调）
17. 工作城市的选择
18. 实习时间
19. 优势和不足的点
20. 项目大概做了多长时间
21. 对这个项目的时间周期满意吗
22. 面试表现:评价比较正面。
23. 如何评价自己？
24. 朋友同事如何评价自己？
25. 最自豪的事情？
26. 最大的优点？觉得自己有什么缺点？
27. 怎么选公司？
28. 跟别的候选人比有什么优势
29. 对云怎么理解
30. 工作中最自豪的事情
31. 工作中有没有遇到需要和别的组协调的工作
32. 怎么处理同事间的分歧
33. 介绍项目
34. 和同事领导的相处方式
35. 校园竞赛经历
36. 校园干部经历
37. 问最近一次的比赛，聊了比较久一个人工智能的竞赛，问到了深度学习里用了什么网络模型，自己做了什么贡献、如何更新模型，怎么开展的，识别出错怎么办，如果遇到恶意攻击怎么办（说了一个自己的方案）
38. 业余爱好，怎么拿的奖
39. 聊竞赛，所有的竞赛全部问了一遍，感觉是看竞赛中的参与程度
40. 你觉得你在这几轮面试中你的优势是什么，劣势是什么
41. 面试完之后会复盘吗
42. 为什么选择字节跳动
43. 说一下职业规划，看到简历偏后端一些，是否会并不喜欢客户端的方向呢？
44. 个人的优势与短板
45. 你说擅长团队协作是因为自己带队作为负责人参与了很多比赛吗
46. 说一下你带团队时会考虑哪些问题，一个团队的关键点是什么
47. 大概什么时间能够到岗，实习多久
48. 对于转正你有什么问题吗
49. 对于工作的城市有要求吗
50. 家里对于工作地点上有意见吗
51. 进入到字节跳动团队后，你希望从你的mentor得到哪些帮助
52. 当你遇到问题你会主动找他人问吗
53. 有过压力很大时候吗？
54. 是怎样克服这个压力
55. 还有其他公司在面试吗
56. 对于这边的团队有了解吗


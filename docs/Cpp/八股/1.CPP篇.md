# 1.CPP篇

## 1.C++ 语⾔基础篇

### 1、说⼀下你理解的 C++ 中的四种智能指针

​		⾯试官你好，⾸先，说⼀下为什么要使⽤智能指针：智能指针其作⽤是管理⼀个指针，避免咋们程序员申请的空间 在函数结束时忘记释放，造成内存泄漏这种情况滴发⽣。 然后使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动 调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要 ⼿动释放内存空间。

​		

**常⽤接⼝**

```cpp
T* get();
T& operator*();
T* operator->();
T& operator=(const T& val);
T* release();
void reset (T* ptr = nullptr);
/*

T 是模板参数, 也就是传⼊的类型；
get() ⽤来获取 auto_ptr 封装在内部的指针, 也就是获取原⽣指针；
operator() 重载 , operator->() 重载了->, operator=()重载了=；
realease() 将 auto_ptr 封装在内部的指针置为 nullptr, 但并不会破坏指针所指向的内容, 函数返回的是内部指
针置空之前的值；
直接释放封装的内部指针所指向的内存, 如果指定了 ptr 的值, 则将内部指针初始化为该值 (否则将其设置为
nullptr；
*/
```

下⾯分别说⼀下哪四种：

1、**auto_ptr**（C++98 的⽅案，C11 已抛弃）采⽤所有权模式。

```cpp
auto_ptr<std::string> p1 (new string ("hello"));
auto_ptr<std::string> p2;
p2 = p1; //auto_ptr 不会报错.
//此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题
```

2、**unique_ptr**（替换 auto_ptr ） 

​		unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资 源泄露特别有⽤。 采⽤所有权模式，还是上⾯那个例⼦

```cpp
unique_ptr<string> p3 (new string (auto));//#4
unique_ptr<string> p4；//#5
p4 = p3;//此时会报错

//编译器认为 p4=p3 ⾮法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr ⽐ auto_ptr 更安全
//若要转移资源，需要使用std::move(p) 函数
```

3、**shared_ptr**（共享型，强引⽤）

​		shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销 毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共 享。

​		可以通过成员函数 use_count() 来查看资源的所有者个数，除了可以通过 new 来构造，还可以通过传⼊auto_ptr, unique_ptr,weak_ptr 来构造。当我们调⽤ release() 时，当前指针会释放资源所有权，计数减⼀。当计数等于 0 时，资源会被释放。

​		shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性 (auto_ptr 是独占的)，在使⽤引⽤计数的机制上提供了 可以共享所有权的智能指针。

4、**weak_ptr**（弱引⽤）

​		weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理 的是那个强引⽤的 shared_ptr。

​		weak_ptr 只是提供了对管理对象的⼀个访问⼿段。weak_ptr 设计的⽬的是为配合 shared_ptr ⽽引⼊的⼀种智 能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造，它的构造和析构不会 引起引⽤记数的增加或减少。

​		weak_ptr 是⽤来解决 shared_ptr 相互引⽤时的死锁问题，如果说两个 shared_ptr 相互引⽤，那么这两个指针的 引⽤计数永远不可能下降为0，也就是资源永远不会释放。它是对对象的⼀种弱引⽤，不会增加对象的引⽤计数， 和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调⽤ **lock** 函数来获得 shared_ptr。

​		当两个智能指针都是 shared_ptr 类型的时候，析构时两个资源引⽤计数会减⼀，但是两者引⽤计数还是为 1，导 致跳出函数时资源没有被释放（的析构函数没有被调⽤），解决办法：把其中⼀个改为weak_ptr就可以。



### 2、C++ 中内存分配情况

![img](http://oss.interviewguide.cn/img/202205220021689.png)

​		**栈：**由编译器管理分配和回收，存放局部变量和函数参数。 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限

​		**堆：**由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲 碎⽚的情况。 

​		**全局/静态存储区：**分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

​		**常量存储区：**存储常量，⼀般不允许修改。 

​		**代码区：**存放程序的⼆进制代码。





### **3、C++ 中的指针参数传递和引⽤参数传递**

​		**指针参数传递本质上是值传递**，它所传递的是⼀个**地址值**。值传递过程中，被调函数的形式参数作为被调函数的局 部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本（替身）。 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，不会影响主调函数的实参变量的值 （形参指针变了，实参指针不会变）。如指针变成了其他指针，p = op，最终的值不会变

​		引⽤参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数 放进来的**实参变量的地址**。被调函数对形参（本体）的任何操作都被处理成**间接寻址**，即通过栈中存放的地址访问 主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数 中的实参变量。

​		**引⽤传递和指针传递是不同的**，虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理 都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针 地址，它将应⽤不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就 得使⽤指向指针的指针或者指针引⽤。

​		**从编译的⻆度来讲**，程序在编译时分别将指针和引⽤添加到符号表上，符号表中记录的是变量名及变量所对应地 址。指针变量在符号表上对应的地址值为指针变量的地址值，⽽引⽤在符号表上对应的地址值为引⽤对象的地址值 （与实参名字不同，地址相同）。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值 可以改），⽽引⽤对象则不能修改



### 4、C++ 中 const 和 static 关键字（定义，⽤途）

**static 作⽤：控制变量的存储⽅式和可⻅性。**

**作⽤⼀：修饰局部变量**：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块 执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续 到整个程序执⾏结束。但是要注意的是，虽然⽤ static 对局部变量进⾏修饰之后，其⽣命周期以及存储空间发⽣了 变化，**但其作⽤域并没有改变**，作⽤域还是限制在其语句块。



**作⽤⼆：修饰全局变量**：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被 访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成 了**本⽂件可⻅**。



**作⽤三：修饰函数：**⽤ static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。



**作⽤四：修饰类：**如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何 特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副 本，可以通过；类和对象去调⽤。

（补充：静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。）



**作⽤五：类成员/类函数声明 static**

1.函数体内 static 变量的作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下 次调⽤时仍维持上次的值；

2.在模块内的 static 全局变量可以被模块内所⽤函数访问，但不能被模块外其它函数访问； 

3.在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； 

4.在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉； 

5.在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变 量。

6.static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初 始化；

7.由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本 对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰 的类成员；

8.static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意 义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指 针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。



**const 关键字：含义及实现机制**



**const 修饰基本类型数据类型：**基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后， 其结果是⼀样的。在使⽤这些常量的时候，只要不改变这些常量的值即可。

**const 修饰指针变量和引⽤变量：**如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变量，即指 针指向为常量，也叫底层const；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常量，也叫顶层const。



**const 应⽤到函数中：**作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变量初始化 const 常量，则在函数体 中，按照 const 所修饰的部分进⾏常量化，保护了原对象的属性。

 [注意]：参数 const 通常⽤于参数为指针或引⽤ 的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照"修饰原则"进⾏修饰，起到相应的保护作 ⽤。

**const 在类中的⽤法：**

const 成员变量，只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为 类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员， 因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构 造函数的初始化列表中进⾏。

const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注 意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含 有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数



**const 修饰类对象，定义常量对象：**常量对象只能调⽤常量函数，别的成员函数都不能调⽤。 

补充：const 成员函数中如果实在想修改某个变量，可以使⽤ mutable 进⾏修饰。成员变量中如果想建⽴在整个类 中都恒定的常量，应该⽤类中的枚举常量来实现或者 static const。

**C ++ 中的 const类成员函数（⽤法和意义）**

​		常量对象可以调⽤类中的 const 成员函数，但不能调⽤⾮ const 成员函数； （原因：对象调⽤成员函数时，在形 参列表的最前⾯加⼀个形参 this，但这是隐式的。this 指针是默认指向调⽤函数的当前对象的，所以，很⾃然， this 是⼀个常量指针 test * const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表（即⼩括号） 后加了 const 关键字（void print() const;），此成员函数为常量成员函数，此时它的隐式this形参为 const test * const，即不可以通过 this 指针来改变指向对象的值

⾮常量对象可以调⽤类中的 const 成员函数，也可以调⽤⾮ const 成员函数。



### 5、C 和 C++ 区别 （函数/类/struct/class）

​		⾸先，C 和 C++ 在基本语句上没有过⼤的区别。

​		C++ 有新增的**语法和关键字**，语法的区别有头⽂件的不同和命名空间的不同，C++ 允许我们⾃⼰定义⾃⼰的空间， C 中不可以。关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new  和 delete，⽽且 C++ 中在指针的基础上增加了引⽤的概念，关键字例如 C++中还增加了 auto，explicit 体现显示 和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。

​		函数⽅⾯ C++ 中有重载和虚函数的概念：C++ ⽀持函数重载⽽ C 不⽀持，是因为 C++ 函数的名字修饰与 C 不同， C++ 函数名字的修饰会将参数加在后⾯，例如，int func(int,double)经过名字修饰之后会变成_func_int_double， ⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。

​		**C++ 还有虚函数概念，⽤以实现多态。**

​		**类⽅⾯，C 的 struct 和 C++ 的类也有很⼤不同**：C++ 中的 struct 不仅可以有成员变量还可以成员函数，⽽且对于  struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public，C++ 中除了 struct 还有  class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。

​		**C++ 中增加了模板还重⽤代码，提供了更加强⼤的 STL 标准库。**

​		最后补充⼀点就是 C 是⼀种结构化的语⾔，重点在于算法和数据结构。C 程序的设计⾸先考虑的是如何通过⼀个代 码，⼀个过程对输⼊进⾏运算处理输出。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对 应的问题领域，这样就能通过获取对象的状态信息得到输出

​		C 的 struct 更适合看成是⼀个数据结构的实现体，⽽ C++ 的 class 更适合看成是⼀个对象的实现体。



### 7、说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？

​		对于局部常量，存放在栈区；

​		对于全局常量，编译期⼀般不分配内存，放在符号表中以提⾼访问效率；

​		字⾯值常量，⽐如字符串，放在常量区。



### **8、C++ 中重载和重写，重定义的区别**

**重载**

​		翻译⾃ overload，是指同⼀可访问区内被声明的⼏个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰 会将参数加在后⾯，可以是参数类型，个数，顺序的不同。根据参数列表决定调⽤哪个函数，重载不关⼼函数的返 回类型。

**重写**

​		翻译⾃ override，派⽣类中重新定义⽗类中除了函数体外完全相同的虚函数，注意被重写的函数不能是 static 的， ⼀定要是虚函数，且其他⼀定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修 饰符是可以不同的，尽管 virtual 中是 private 的，派⽣类中重写可以改为 public。

**重定义（隐藏）**

​		派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同，即⽗类中除了定义成 virtual 且完全相同的同名函数才不会被派⽣类中的同名函数所隐藏（重定义）。



### 9、介绍 C++ 所有的构造函数

​		类的对象被创建时，编译系统为对象分配内存空间，并⾃动调⽤构造函数，由构造函数完成成员的初始化⼯作。

​		即构造函数的作⽤：初始化对象的数据成员。

**⽆参数构造函数：**即默认构造函数，如果没有明确写出⽆参数构造函数，编译器会⾃动⽣成默认的⽆参数构造函 数，函数为空，什么也不做，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数。

**⼀般构造函数：**也称重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，前提是 参数的个数或者类型不同，创建对象时根据传⼊参数不同调⽤不同的构造函数。

**拷⻉构造函数：**拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对 象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函 数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函 数，最好⾃⼰定义并且在函数中执⾏**深拷⻉**。

**移动构造函数**：用于将一个对象的资源所有权从一个对象转移到另一个对象，而不进行资源的深拷贝。移动构造函数可以提高性能并减少内存复制的开销。移动构造函数使用了右值引用（Rvalue Reference）作为参数，并在函数体内将资源的所有权从源对象转移到目标对象。通常，移动构造函数会直接将源对象的指针或其他资源信息移交给目标对象，然后将源对象的资源指针设为nullptr，以确保源对象在析构时不会释放资源。

**类型转换构造函数：**根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种，这⾥提出 来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。

**赋值运算符的重载：**注意，这个类似拷⻉构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造 函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会⽣成默认的赋值运算 符，做⼀些基本的拷⻉⼯作。



```cpp
A a1, A a2; a1 = a2;//调⽤赋值运算符
A a3 = a1;//调⽤拷⻉构造函数，因为进⾏的是初始化⼯作，a3 并未存在

```



### 10、C++ 的四种强制转换

C++ 的四种强制转换包括：**static_cast     dynamic_cast     const_cast     reinterpret_cast**

**static_cast：**明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类-\>基类）安全，下⾏转换（基类-\>派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；

**dynamic_cast：**专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指 针，可能造成⾮法访问等问题。

**const_cast：**专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个 可以操作常量的转换符。

**reinterpret_cast：**不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解 释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换。



### 11、指针和引⽤的区别

​		指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。

​		在程序编译的时候，将指针和引⽤添加到符号表中。

​		指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添 加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为 空，sizeof 指针得到的是指针类型的⼤⼩。

​		⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将"引⽤变量名-引⽤对象的地址"添加到符号 表中，**符号表⼀经完成不能改变**，所以引⽤必须⽽且只能在**定义时**被绑定到⼀块内存上，后续不能更改，也不能为 空，也没有 const 和⾮ const 区别。

​		sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤ 后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。

​		作为参数时也不同，传指针的实质是**传值**，传递的值是指针的地址；传引⽤的实质是**传地址**，传递的是变量的地 址。



### 12、 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？

​		野指针(wild pointer)：就是没有被初始化过的指针。⽤ gcc -Wall 编译, 会出现 used uninitialized 警告。

​		悬空指针：是指针最初指向的内存已经被释放了的⼀种指针。

​		⽆论是野指针还是悬空指针，都是指向⽆效内存区域(这⾥的⽆效指的是"不安全不可控")的指针。 访问"不安全可 控"(invalid)的内存区域将导致"Undefined Behavior"。

​		**如何避免使⽤野指针？在平时的编码中，养成在定义指针后且在使⽤之前完成初始化的习惯或者使⽤智能指针。**



### 13、说⼀下 const 修饰指针如何区分？

​		下⾯都是合法的声明，但是含义⼤不同：

```cpp
const int * p1; //指向整形常量的指针，它指向的值不能修改
int * const p2; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。
const int *const p3; //指向整形常量 的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。
```

​		理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量 ，如果该关键字的右边是类型，则值是 常量；如果关键字的右边是指针变量，则指针本身是常量。



### 14、简单说⼀下函数指针

​		从定义和⽤途两⽅⾯来说⼀下⾃⼰的理解：

​		⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函 数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。

​		在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后， 可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。

​		其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。

```cpp
char * fun(char * p) {…} // 函数fun
char * (*pf)(char * p); // 函数指针pf
pf = fun; // 函数指针pf指向函数fun
pf(p); // 通过函数指针pf调⽤函数fun

```

### 15、堆和栈区别

​		**栈**

​		由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数 参数等。

​		连续的内存空间，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。

​		⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可 变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在 栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它 放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地 址，程序由该点继续运⾏，不会产⽣碎⽚。

​		栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩。

​		**堆**

​		由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问 题。

​		不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请 ⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然 如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。

​		堆是低地址向⾼地址扩展，空间交⼤，较为灵活。



### 16、函数传递参数的⼏种⽅式

​		**值传递：**形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。

​		**指针传递：**也是值传递的⼀种⽅式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进 ⾏操作

​		**引⽤传递：**实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部 的实参上⾯。



### 17、new / delete ，malloc / free 区别

​		都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。

**执⾏ new 实际上执⾏两个过程：**

​		1.分配未初始化的内存空间（malloc）；

​		2.使⽤对象的构造函数对空间进⾏初始 化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处 理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。

**执⾏ delete 实际上也有两个过程：**

1. 使⽤析构函数对对象进⾏析构；
2. 回收内存空间（free）。



**为什么有了 malloc／free 还需要 new／delete？**

​		因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动 态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／ free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于 malloc／free，所以有了 new／delete 操作符。



### 18、volatile 和 extern 关键字

**volatile 三个特性**



**易变性：**在汇编层⾯反映出来，就是两条语句，下⼀条语句不会直接使⽤上⼀条语句对应的 volatile 变量的寄存器 内容，⽽是重新从内存中读取。

**不可优化性：**volatile 告诉编译器，不要对我这个变量进⾏各种激进的优化，甚⾄将变量直接消除，保证程序员写 在代码中的指令，⼀定会被执⾏。

**顺序性：**能够保证 volatile 变量之间的顺序性，编译器不会进⾏乱序优化。



**extern**

在 C 语⾔中，修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处引 ⽤”。

注意 extern 声明的位置对其作⽤域也有关系，如果是在 main 函数中进⾏声明的，则只能在 main 函数中调⽤，在 其它函数中不能调⽤。其实要调⽤其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，为啥要⽤ extern？因为⽤ extern 会加速程序的编译过程，这样能节省时间。



**在 C++ 中 extern 还有另外⼀种作⽤**，⽤于指示 C 或者 C＋＋函数的调⽤规范。⽐如在 C＋＋ 中调⽤ C 库函数，就 需要在 C＋＋ 程序中⽤ extern “C” 声明要引⽤的函数。这是给链接器⽤的，告诉链接器在链接的时候⽤C 函数规范 来链接。主要原因是 C＋＋ 和 C 程序编译完成后在⽬标代码中命名规则不同，⽤此来解决名字匹配的问题。



### 19、define 和 const 区别（编译阶段、安全性、内存占⽤等）

**对于 define 来说，**宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定 义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期 的效果。因为 define 宏定义仅仅是展开，因此运⾏时系统并不为宏定义分配内存，但是从汇编 的⻆度来讲， define 却以⽴即数的⽅式保留了多份数据的拷⻉。 



**对于 const 来说，**const 是在编译期间进⾏处理的，const 有类型，也有类型检查，程序运⾏时系统会为 const 常 量分配内存，⽽且从汇编的⻆度讲，const 常量在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的 拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常量分配内存，⽽是直接将 const 常量添 加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。



### 20、计算下⾯⼏个类的⼤⼩

```cpp
class A{}; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1.
class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）
class A{static int a; }; sizeof(A) = 1;
class A{int a; }; sizeof(A) = 4;
class A{static int a; int b; }; sizeof(A) = 4;

```



### 21、⾯向对象的三⼤特性，并举例说明

C++ ⾯向对象的三⼤特征是：封装、继承、多态。

**所谓封装**

​		就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信 息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据 可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部 分意外的改变或错误的使⽤了对象的私有部分。

**所谓继承**

​		是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能 ⼒：它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新 类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要 实现继承，可以通过“继承”和“组合”来实现。

​		继承概念的实现⽅式有两类： 

​		**实现继承：**实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。 

​		**接⼝继承：**接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒。

**所谓多态** 

​		就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个接⼝，可以实现多种 ⽅法。 

​		多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函 数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在 运⾏时才确定，这就属于晚绑定。



### 22、多态的实现

​		多态其实⼀般就是指**继承加虚函数实现的多态**，对于᯿载来说，实际上基于的原理是，编译器为函数⽣成符号表时 的不同规则，᯿载只是⼀种语⾔特性，与多态⽆关，与⾯向对象也⽆关，但这⼜是 C++中增加的新规则，所以也算 属于 C++，所以如果⾮要说᯿载算是多态的⼀种，那就可以说：多态可以分为**静态多态和动态多态**。

​		**静态多态其实就是重载，**因为静态多态是指在编译时期就决定了调⽤哪个函数，根据参数列表来决定；

​		**动态多态是指通过⼦类重写⽗类的虚函数来实现的，**因为是在运⾏期间决定调⽤的函数，所以称为动态多态， ⼀般情况下我们不区分这两个时所说的多态就是指动态多态。 动态多态的实现与**虚函数表，虚函数指针**相关。

​		**扩展：**⼦类是否要重写⽗类的虚函数？⼦类继承⽗类时， ⽗类的纯虚函数必须重写，否则⼦类也是⼀个虚类不可实 例化。 定义纯虚函数是为了实现⼀个接⼝，起到⼀个规范的作⽤，规范继承这个类的程序员必须实现这个函数。



### 23、虚函数相关（虚函数表，虚函数指针），虚函数的实现原理

​		⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会 根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类 的函数。

​		实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类 继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对 象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚 函数指针的初始化是在构造函数中完成的。

​		后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻 找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

​		补充：如果基类中没有定义成 virtual，那么进⾏ 

```cpp
Base B;
Derived D; 
Base *p = D; 
p->function();
```

​		 这种情况下调⽤ 的则是 Base 中的 function()。因为基类和派⽣类中都没有虚函数的定义，那么编译器就会认为不⽤留给动态多态 的机会，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派⽣类对象，⾸先要构造基类的空 间，然后构造派⽣类的⾃身内容，形成⼀个派⽣类对象，那么在进⾏类型转换时，直接截取基类的部分的内存，编 译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数 的地址，所以执⾏的是基类的函数。



### 24、编译器处理虚函数表应该如何处理

对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤：

​		1.拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表

​		2.当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基 类

​		3.查看派⽣类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派⽣类是否有⾃ 身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中

```cpp
Derived *pd = new D(); 
B *pb = pd;
C *pc = pd; 
```

其中 pb，pd，pc 的指针位置是不同的，要注意的是派⽣类的⾃ 身的内容要追加在主基类的内存块后。

![1](img\1.PNG)

### 25、析构函数⼀般写成虚函数的原因

​		直观的讲：是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准 备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调 ⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的 ⾃身内容将⽆法被析构，造成内存泄漏。

​		如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构 函数，成功释放内存。



### 26、构造函数为什么⼀般不定义为虚函数

​		虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体类型。但是，我们要 创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函 数不应该被定义成虚函数；

​		⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找 到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函 数表来调⽤虚函数，那么这个调⽤实际上也是违反了先实例化后调⽤的准则。



### 27、构造函数或析构函数中调⽤虚函数会怎样

​		实际上是不应该在构造函数或析构函数中调⽤虚函数的，因为这样的调⽤其实并不会带来所想要的效果。

​		举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数 action_type()，在基类的构造函数中 调⽤了这个虚函数。

​		派⽣类中重写了这个虚函数，我们期望着根据对象的真实类型不同，⽽调⽤各⾃实现的虚函数，但实际上当我们创 建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初 始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法。

​		也就是说构造派⽣类的基类部分是，编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实 现，并没有按照我们想要的⽅式进⾏。即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象。

​		在析构函数中也是同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那么在执⾏基类的析构 函数中是不可能调⽤到派⽣类重写的⽅法的。所以说，我们不应该在构在函数或析构函数中调⽤虚函数，就算调⽤ ⼀般也不会达到我们想要的结果。



### 28、析构函数的作⽤，如何起作⽤？

​		构造函数只是起初始化值的作⽤，但实例化⼀个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函 数⾥⾯，这样就使其他的函数⾥⾯有值了。规则，只要你⼀实例化对象，系统⾃动回调⽤⼀个构造函数，就是你不 写，编译器也⾃动调⽤⼀次。

​		析构函数与构造函数的作⽤相反，⽤于撤销对象的⼀些特殊任务处理，可以是释放对象分配的内存空间；特点：析 构函数与构造函数同名，但该函数前⾯加~。

​		析构函数没有参数，也没有返回值，⽽且不能重载，在⼀个类中只能有⼀个析构函数。 当撤销对象时，编译器也会 ⾃动调⽤析构函数。 每⼀个类必须有⼀个析构函数，⽤户可以⾃定义析构函数，也可以是编译器⾃动⽣成默认的析 构函数。⼀般析构函数定义为类的公有成员。



### 29、构造函数的执⾏顺序？析构函数的执⾏顺序？

**构造函数顺序**

​		基类构造函数。如果有多个基类，则构造函数的调⽤顺序是某类在**类派⽣表中出现的顺序**，⽽不是它们在成员 初始化表中的顺序。

​		成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象**在类中被声明的顺序**，⽽不是它们 出现在成员初始化表中的顺序。

​		派⽣类构造函数。

**析构函数顺序**

​		调⽤派⽣类的析构函数；

​		调⽤成员类对象的析构函数；

​		调⽤基类的析构函数。



### 30、纯虚函数 （应⽤于接⼝继承和实现继承）

虚函数：允许在基类中实现

纯虚函数：不允许在基类中实现



实际上，纯虚函数的出现就是为了让继承可以出现多种情况：

​		有时我们希望派⽣类只继承成员函数的接⼝

​		有时我们⼜希望派⽣类既继承成员函数的接⼝，⼜继承成员函数的实现，⽽且可以在派⽣类中可以重写成员函 数以实现多态

​		有的时候我们⼜希望派⽣类在继承成员函数接⼝和实现的情况下，不能重写缺省的实现。

其实，声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的 实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化。

对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调⽤这个实现的唯⼀⽅式 是在派⽣类对象中指出其 class 名称来调⽤。



### 31、静态绑定和动态绑定的介绍

​		说起静态绑定和动态绑定，我们⾸先要知道静态类型和动态类型，静态类型就是它在程序中被声明时所采⽤的类 型，在编译期间确定。动态类型则是指“⽬前所指对象的实际类型”，在运⾏期间确定。

​		静态绑定，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发⽣在编译期间。

​		动态绑定，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发⽣在运⾏期间。

​		⽐如说，virtual 函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意， 我们不应该重新定义继承⽽来的缺省参数，因为即使我们重定义了，也不会起到效果。因为⼀个基类的指针指向⼀ 个派⽣类对象，在派⽣类的对象中针对虚函数的参数缺省值进⾏了重定义， 但是缺省参数值是静态绑定的，静态绑 定绑定的是静态类型相关的内容，所以会出现⼀种派⽣类的虚函数实现⽅式结合了基类的缺省参数值的调⽤效果， 这个与所期望的效果不同。



### 32、深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）

​		当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即 浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。

​		但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会 调⽤两次析构函数，⽽导致指野指针的问题。

​		所以，这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从 ⽽也就解决来野指针的问题。简⽽⾔之，当数据成员中有指针时，必需要⽤深拷⻉更加安全。



### 33、什么情况下会调⽤拷⻉构造函数(三种情况)

​		⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中。

​		⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值。

​		⼀个对象需要通过另外⼀个对象进⾏初始化。

### 34、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？

​		为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构造函数⽣成⼀个副 本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数 的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就是⼀个⽆限递归。



### 35、结构体内存对⻬⽅式和为什么要进⾏内存对⻬？

⾸先我们来说⼀下结构体中内存**对⻬的规则**：

​		1.对于结构体中的各个成员，第⼀个成员位于偏移为 0 的位置，以后的每个数据成员的偏移量必须是 min(\#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。

​		2.在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是 min(\#pragma pack() 制定的数，⻓度最⻓的数据成员的⻓度) 的倍数。

**那么内存对⻬的作⽤是什么呢？**

​		1.经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐ 如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的， 那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。

​		2.如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存 器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4 字节的数据进⼊寄存器，所以说，当内 存没有对⻬时，寄存器进⾏了很多额外的操作，⼤⼤降低了 CPU 的性能。

​		3.另外，还有⼀个就是，有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理，不是所有的硬件平台都能访问任 意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存 对⻬还有利于平台移植。



### 36、内存泄漏的定义，如何检测与避免？

​		**定义：**内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越 ⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那 么这块内存就泄漏了。

**如何检测内存泄漏**

​		1.⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀ 两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。

​		2.还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个 可能的解释就是有个进程出现了内存泄漏。

​		3.当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的 检测。



### 38、说⼀下红⿊树（RB-tree）

​		

红⿊树的定义：

 性质1：每个节点要么是⿊⾊，要么是红⾊。 

性质2：根节点是⿊⾊。

性质3：每个叶⼦节点（NIL）是⿊⾊。

性质4：每个红⾊结点的两个⼦结点⼀定都是⿊⾊。

性质5：任意⼀结点到每个叶⼦结点的路径都包含数量相同的⿊结点。



### 39、说⼀下 define、const、typedef、inline 使⽤⽅法？

**1、const 与 \#define 的区别**

​		const 定义的常量是变量带类型，⽽\#define 定义的只是个常数不带类型；

​		define 只在预处理阶段起作⽤，简单的⽂本替换，⽽ const 在编译、链接过程中起作⽤；

​		define 只是简单的字符串替换没有类型检查。⽽const是有数据类型的，是要进⾏判断的，可以避免⼀些低级错 误；

​		define 预处理后，占⽤代码段空间，const 占⽤数据段空间；

​		const 不能重定义，⽽ define 可以通过 \#undef 取消某个符号的定义，进⾏重定义；

​		define 独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。

**2、\#define 和别名 typedef 的区别**

​		执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；\#define 是宏定义，发⽣在预处理阶段， 不进⾏类型检查；

​		功能差异，typedef ⽤来定义类型的别名，定义与平台⽆关的数据类型，与 struct 的结合使⽤等。

​		define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。

​		作⽤域不同，\#define 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。

​		⽽ typedef 有⾃⼰的作⽤域。

**3、define 与 inline 的区别**

​		\#define是关键字，inline是函数；

​		宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；

​		inline 函数有类型检查，相⽐宏定义⽐较安全；



### 40、预处理，编译，汇编，链接程序的区别

​		⼀段⾼级语⾔代码经过四个阶段的处理形成可执⾏的⽬标⼆进制代码。

​		预处理器→编译器→汇编器→链接器：最难理解的是编译与汇编的区别。

**预处理阶段：**写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 \#开头的命令，修改原始的程序，如 \#include 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件,删除注释。

**编译阶段：**编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是**汇编语⾔程序**。⾼级语⾔是源程序。所以注意概 念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼ 级语⾔翻译的汇编语⾔相同。

**汇编阶段：**汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀ 个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。

**链接阶段：**⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个 名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得 到的是可执⾏⽬标⽂件。



### 41、说⼀下 fork，wait，exec 函数

​		⽗进程产⽣⼦进程使⽤ fork 拷⻉出来⼀个⽗进程的副本，此时只拷⻉了⽗进程的⻚表，两个进程都读同⼀块内 存。

​		当有进程写的时候使⽤写实拷⻉机制分配内存，exec 函数可以加载⼀个 elf ⽂件去替换⽗进程，从此⽗进程和⼦进 程就可以运⾏不同的程序了。

​		fork 从⽗进程返回⼦进程的 pid，从⼦进程返回 0，调⽤了 wait 的⽗进程将会发⽣阻塞，直到有⼦进程状态改变， 执⾏成功返回 0，错误返回 -1。

​		exec 执⾏成功则⼦进程从新的程序开始运⾏，⽆返回值，执⾏失败返回 -1。



### 42、动态编译与静态编译

​		静态编译，编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中 去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；

​		动态编译，可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅ ⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只 ⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库， 则⽤动态编译的可执⾏⽂件就不能运⾏。

### 43、动态链接和静态链接区别

​		静态连接库就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；动态 链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候 再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。

​		静态链接库与动态链接库都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib 中的指令都全部被 直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时 可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。

​		静态链接库和动态链接库的另外⼀个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，⽽在动态链 接库中还可以再包含其他的动态或静态链接库。

​		动态库就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中有多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对 lib ⽂件中同⼀个函数的 调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。



### 44、动态联编与静态联编

​		在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编 和动态联编；

​		静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态 联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束 定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率 ⾼，但灵活性差。

​		动态联编是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数 的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象 类型将做出不同的编译结果。

​		C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活 性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类 的指针变量名-\>虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）

**实现动态联编三个条件：**

​		必须把动态联编的⾏为定义为类的虚函数；

​		类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；

​		必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数；

### 45.malloc原理 以及brk mmap系统调用

![malloc](img\malloc.PNG)

### 46.什么时候会发生段错误

​		非法访问内存地址：

​			使用野指针

​			试图修改常量区内容

### 47.在main执行之前和之后执行的代码可能是什么？

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
- `__attribute__((destructor))`

### 48.cout和printf有什么区别？

​		很多人认为cout是一个函数，其实不是的，它是类`std::ostream`的全局对象。

​		cout后可以跟不同的类型是因为cout已存在针对各种类型数据的重载，所以会自动识别数据的类型。

​		输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。

​		cout是有缓冲输出:

```cpp
cout << "abc " <<endl; 
cout << "abc\n "; cout <<flush; //这两个才是一样的.
```

flush立即强迫缓冲输出。

printf是行缓冲输出，不是无缓冲输出。

### 49、定义和声明的区别

**如果是指变量的声明和定义：** 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

**如果是指函数的声明和定义：** 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。

### 50、什么是一致性哈希？

**一致性哈希**

一致性哈希是一种哈希算法，就是**在移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系**

尽可能少的改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以先想想，真实情况如何处理

一致性哈希将整个哈希值空间组**织成一个虚拟的圆环**，假设哈希函数的值空间为0~2^32-1，整个哈希空间环如下左图所示

![img](http://oss.interviewguide.cn/img/202205212342491.png)

一致性hash的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-object4在环上的分布图

**结点和数据映射**

假如有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-nodeC

现在有一批的数据object1-object4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，可以沿着顺时针方向寻找，找到一个结点（服务器）则将数据存在这个结点上，这样数据和结点就产生了一对一的关联，如下图所示：

![img](http://oss.interviewguide.cn/img/202205212343455.png)

**移除结点**

如果一台服务器出现问题，如上图中的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可，下左图

![img](http://oss.interviewguide.cn/img/202205212343330.png)

**添加结点**

如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，见上右图

**虚拟结点**

假设仅有2台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1和nodeA2，nodeC变成：nodeC1和nodeC2，映射情况变成如下：

![img](http://oss.interviewguide.cn/img/202205212343034.png)

这样数据分布就均衡多了，平衡性有了很大的提高



### 51、介绍一下几种典型的锁

**读写锁**

- 多个读者可以同时进行读
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

**互斥锁**

一次只能一个线程拥有互斥锁，其他线程只有等待

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁

**条件变量**

互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。

**自旋锁**

如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。



## 2.类和数据抽象

### 1、什么是类的继承？

**类与类之间的关系**

​		has-A 包含关系，⽤以描述⼀个类由多个部件类构成，实现 has-A 关系⽤类的成员属性表示，即⼀个类的成员属性 是另⼀个已经定义好的类；

​		use-A，⼀个类使⽤另⼀个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的⽅式来实现；

​		is-A，继承关系，关系具有传递性；



**继承的相关概念**

​		所谓的继承就是⼀个类继承了另⼀个类的属性和⽅法，这个新的类包含了上⼀个类的属性和⽅法，被称为⼦类或者 派⽣类，被继承的类称为⽗类或者基类；



**继承的特点**

​		⼦类拥有⽗类的所有属性和⽅法，⼦类可以拥有⽗类没有的属性和⽅法，⼦类对象可以当做⽗类对象使⽤

### 2、什么是组合？

​		⼀个类⾥⾯的数据成员是另⼀个类的对象，即内嵌其他类的对象作为⾃⼰的成员；创建组合类的对象：⾸先创建各 个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进⾏初始化，⼜要对内嵌对象进⾏初始 化。

​		创建组合类对象，构造函数的执⾏顺序：先调⽤内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺 序，与组合类构造函数的初始化列表顺序⽆关。然后执⾏组合类构造函数的函数体，析构函数调⽤顺序相反。

### 3、构造函数析构函数可否抛出异常

​		C++ 只会析构已经完成的对象，对象只有在其构造函数执⾏完毕才算是完全构造妥当。在构造函数中发⽣异常，控 制权转出构造函数之外。因此，在对象 b 的构造函数中发⽣异常，对象b的析构函数不会被调⽤。因此会造成内存 泄漏。

​		⽤ auto_ptr 对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发⽣资源泄漏的危机，不再需要 在析构函数中⼿动释放资源；

​		如果控制权基于异常的因素离开析构函数，⽽此时正有另⼀个异常处于作⽤状态，C++ 会调⽤ terminate 函数让程 序结束；

​		如果异常从析构函数抛出，⽽且没有在当地进⾏捕捉，那个析构函数便是执⾏不全的。如果析构函数执⾏不全，就 是没有完成他应该执⾏的每⼀件事情。



### 4、类如何实现只能静态分配和只能动态分配

​		前者是把 new、delete 运算符重载为 private 属性。

​		后者是把构造、析构函数设为 protected 属性，再⽤⼦类来动态创建

建⽴类的对象有两种⽅式：

​		**静态建⽴**，静态建⽴⼀个类对象，就是由编译器为对象在栈空间中分配内存；

​		**动态建⽴**，A *p = new A(); 动态建⽴⼀个类对象，就是使⽤ new 运算符为对象在堆空间中分配内存。这个过 程分为两步，第⼀步执⾏ operator new() 函数，在堆中搜索⼀块内存并进⾏分配；第⼆步调⽤类构造函数构 造对象；

只有使⽤ new 运算符，对象才会被建⽴在堆上，因此只要限制 new 运算符就可以实现类对象只能建⽴在栈 上。可以将 new 运算符设为私有。



### 5、何时需要成员初始化列表？过程是什么？

​		用初始化列表会快一些的原因是，对于类类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。

​		当初始化⼀个引⽤成员变量时；

​		初始化⼀个 const 成员变量时；

​		当调⽤⼀个基类的构造函数，⽽构造函数拥有⼀组参数时；

​		当调⽤⼀个成员类的构造函数，⽽他拥有⼀组参数；

​		编译器会⼀⼀操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示⽤户代码前。list中 的项⽬顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的

### 6、程序员定义的析构函数被扩展的过程？

​		析构函数函数体被执⾏；

​		如果 class 拥有成员类对象，⽽后者拥有析构函数，那么它们会以其声明顺序的相反顺序被调⽤；

​		如果对象有⼀个 vptr，现在被重新定义

​		如果有任何直接的上⼀层⾮虚基类拥有析构函数，则它们会以声明顺序被调⽤；

​		如果任何虚基类拥有析构函数

### 7、构造函数的执⾏算法？

​		在派⽣类构造函数中，所有的虚基类及上⼀层基类的构造函数调⽤；

​		对象的 vptr 被初始化；

​		如果有成员初始化列表，将在构造函数体内扩展开来，这必须在 vptr 被设定之后才做；

​		执⾏程序员所提供的代码；

### 8、构造函数的扩展过程？

​		记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序； 

​		如果⼀个成员并没有出现在成员初始化列表中，但它有⼀个默认构造函数，那么默认构造函数必须被调⽤； 

​		如果 class 有虚表，那么它必须被设定初值； 

​		所有上⼀层的基类构造函数必须被调⽤； 

​		所有虚基类的构造函数必须被调⽤。



### 9、哪些函数不能是虚函数

​		**构造函数**，构造函数初始化对象，派⽣类必须知道基类函数⼲了什么，才能进⾏构造；当有虚函数时，每⼀个类有 ⼀个虚表，每⼀个对象有⼀个虚表指针，虚表指针在构造函数中初始化；

​		**内联函数**，内联函数表示在编译阶段进⾏函数体的替换操作，⽽虚函数意味着在运⾏期间进⾏类型确定，所以内联 函数不能是虚函数；

​		**静态函数**，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。

​		**友元函数**，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

​		**普通函数**，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

### 10、类的对象存储空间？

- 非静态成员的数据类型大小之和。
- 编译器加入的额外成员变量（如指向虚函数表的指针）。
- 为了边缘对齐优化加入的padding。

空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0.

### 11、关于this指针你知道什么？全说出来

- this指针是类的指针，指向对象的首地址。
- this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
- this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

**this指针的用处**

一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的**非静态成员函数**中访问类的**非静态成员**的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行

**this指针的使用**

一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；

另外一种情况是当形参数与成员变量名相同时用于区分，如this-\>n = n （不能写成n = n）

**类的this指针有以下特点**

(1）**this**只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，**传入参数为当前对象地址，成员函数第一个参数为**为**T \* const this**

如：

```cpp
class A{public:	int func(int p){}};
```

其中，**func**的原型在编译器看来应该是：

**int func(A \* const this,int p);**

（2）由此可见，**this**在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：

```cpp
A a;
a.func(10);//此处，编译器将会编译成：A::func(&a,10); 
```

看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。



### 12、几个this指针的易混问题

#### A. this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答

#### B. this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。

#### C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？

大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的

#### D. this指针是如何访问类中的变量的？

如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。

在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。

this是类的指针，如果换成结构体，那this就是结构的指针了。

#### E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

**this指针只有在成员函数中才有定义。**因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

#### F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。

#### G.在成员函数中调用delete this会出现什么问题？对象还可以使用吗？

1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

#### F. 如果在类的析构函数中调用delete this，会发生什么？

会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。





## 3.STL 容器和算法



### 1、C++ 的 STL 介绍（内存管理，allocator，函数，实现机理，多线程实 现等）

​		STL ⼀共提供六⼤组件，包括容器，算法，迭代器，仿函数，配接器和配置器，彼此可以组合套⽤。容器通过配置 器取得数据存储空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，配接器可以应⽤ 于容器、 仿函数和迭代器。

**容器：**各种数据结构，如 vector，list，deque，set，map，⽤来存放数据， 从实现的⻆度来讲是⼀种类模板。

**算法：**各种常⽤的算法，如 sort（插⼊，快排，堆排序），search（⼆分查找）， 从实现的⻆度来讲是⼀种⽅法 模板。

**迭代器：**从实现的⻆度来看，迭代器是⼀种将 operator*,operator->,operator++, operator--等指针相关操作赋予 ᯿载的类模板，所有的 STL 容器都有⾃⼰的迭代器。

**仿函数：**从实现的⻆度看，仿函数是⼀种᯿载了 operator()的类或者类模板。 可以帮助算法实现不同的策略。

**配接器：**⼀种⽤来修饰容器或者仿函数或迭代器接⼝的东⻄。

**配置器：**负责空间配置与管理，从实现的⻆度讲，配置器是⼀个实现了动态空间配置、空间管理，空间释放的类模 板。



**扩展： 内存管理 allocator**

​		SGI 设计了**双层级配置器**，第⼀级配置器直接使⽤ malloc()和 free()完成内存的分配和回收。第⼆级配置器则根据 需求ᰁ的⼤⼩选择不同的策略执⾏。

​		对于第**⼆级配置器**，如果需求块⼤⼩⼤于 128bytes，则直接转⽽调⽤第⼀级配置器，使⽤ malloc()分配内存。如 果需求块⼤⼩⼩于 128bytes，第⼆级配置器中维护了 16 个⾃由链表，负责 16 种⼩型区块的次配置能⼒。 即当有⼩于 128bytes 的需求块要求时，⾸先查看所需需求块⼤⼩所对应的链表中是否有空闲空间，如果有则直接 返回，如果没有，则向内存池中申请所需需求块⼤⼩的内存空间，如果申请成功，则将其加⼊到⾃由链表中。如果 内存池中没有空间，则使⽤ malloc() 从堆中进⾏申请，且申请到的⼤⼩是需求的⼆倍（或⼆倍＋n 附加），⼀ 倍放在⾃由空间中，⼀倍（或⼀倍＋n）放⼊内存池中。 如果 malloc()也失败，则会遍历⾃由空间链表，四处寻找“尚有未⽤区块，且区块够⼤”的 freelist，找到⼀块就挖出 ⼀块交出。如果还是没有，仍交由 malloc()处理，因为 malloc() 有 out-of-memory 处理机制或许有机会释放其他 的内存拿来⽤，如果可以就成功，如果不⾏就报 bad_alloc 异常。



**STL 中序列式容器的实现：**

**vector**

​		是动态空间，随着元素的加⼊，它的内部机制会⾃⾏扩充空间以容纳新元素。vector 维护的是⼀个连续的线性空 间，⽽且普通指针就可以满⾜要求作为 vector 的迭代器（RandomAccessIterator）。

​		vector 的数据结构中其实就是三个迭 代器构成的，⼀个指向⽬前使⽤空间头的 iterator，⼀个指向⽬前使⽤空间尾 的iterator，⼀个指向⽬前可⽤空间尾的 iterator。当有新的元素插⼊时，如果⽬前容量够⽤则直接插⼊，如果容量 不够，则容量扩充⾄两倍，如果两倍容量不⾜， 就扩张⾄⾜够⼤的容量。

​		扩充的过程并不是直接在原有空间后⾯追加容量，⽽是重新申请⼀块连续空间，将原有的数据拷⻉到新空间中，再 释放原有空间，完成⼀次扩充。需要注意的是，每次扩充是重新开辟的空间，所以扩充后，原有的迭代器将会失 效。



**list**

​		与 vector 相⽐，list 的好处就是每次插⼊或删除⼀个元素，就配置或释放⼀个空间，⽽且原有的迭代器也不会失 效。STL list 是⼀个双向链表，普通指针已经不能满⾜ list 迭代器的需求，因为 list 的存储空间是不连续的。list 的 迭代器必需具备前移和后退功能，所以 list 提供的是 BidirectionalIterator。list 的数据结构中只要⼀个指向 node 节点的指针就可以了。



**deque**

​		vector 是单向开⼝的连续线性空间，deque 则是⼀种双向开⼝的连续线性空间。所谓双向开⼝，就是说 deque ⽀ 持从头尾两端进⾏元素的插⼊和删除操作。相⽐于 vector 的扩充空间的⽅式，deque 实际上更加贴切的实现了动 态空间的概念。deque 没有容量的概念，因为它是动态地以分段连续空间组合⽽成，随时可以增加⼀段新的空间并 连接起来。

​		由于要维护这种整体连续的假象，并提供随机存取的接⼝（即也提供 RandomAccessIterator），避开了“重新配 置，复制，释放”的轮回，代价是复杂的迭代器结构。也就是说除⾮必要，我们应该尽可能 的使⽤ vector，⽽不是 deque。

​		那么我们回过来具体说 deque 是如何做到维护整体连续的假象的， deque 采⽤⼀块所谓的 map 作为主控，这⾥ 的 map 实际上就是⼀块⼤⼩连续的空间，其中每⼀个元素，我们称之为节点 node，都指向了另⼀段连续线性空间 称为缓冲区，缓冲区才是 deque 的真正存储空间主体。

​		SGI STL 是允许我们指定 缓冲区的⼤⼩的，默认 0 表示使⽤ 512bytes 缓冲区。当 map 满载时，我们选⽤ ⼀块更 ⼤的空间来作为 map，重新调整配置。deque 另外⼀个关键的就是它的 iterator 的设计，deque 的 iterator 中有 四个部分，cur 指向缓冲区现⾏元素，first 指向缓冲区的头，last 指向缓冲区的尾（有时会包含备⽤空间），node 指向管控中⼼。所以总结来说，deque的数据结构中包含了，指向第⼀个节点的iterator start， 和指向最后⼀个节 点的 iterator finish，⼀块连续空间作为主控 map，也需要记住 map 的⼤⼩，以备判断何时配置更⼤的 map。



**stack**

​		是⼀种先进后出的数据结构，只有⼀个出⼝，stack 允许从最顶端新增元素，移除最顶端元素，取得最顶端元素。 deque 是双向开⼝的数据结构，所以使⽤ deque 作为底部结构并封闭其头端开⼝，就形成了⼀个 stack。



**queue**

​		是⼀种先进先出的数据结构，有两个出⼝，允许从最底端加⼊元素，取得最顶端元素，从最底端新增元素，从最顶 端移除元素。deque 是双向开⼝的数据结构，若以 deque 为底部结构并封闭其底端的出⼝，和头端的⼊⼝，就形 成了⼀个 queue。（其实 list 也可以实现 deque）



**heap**

​		堆并不属于 STL 容器组件，它是个幕后英雄，扮演 priority_queue 的助⼿，priority_queue 允许⽤户以任何次序 将任何元素推⼊容器内，但取出时⼀定是从优先权最⾼（数值最⾼）的元素开始取。⼤根堆（binary max heap） 正具有这样的性质，适合作为 priority_queue 的底层机制。

​		⼤根堆，是⼀个满⾜每个节点的键值都⼤于或等于其⼦节点键值的⼆叉树（具体实现是⼀个 vector，⼀块连续空 间，通过维护某种顺序来实现这个⼆叉树），新加⼊元素时，新加⼊的元素要放在最下⼀层为叶节点，即具体实现 是填补在由左⾄右的第⼀个空格（即把新元素插⼊在底层 vector 的 end()），然后执⾏⼀个所谓上溯的程序：将新 节点拿来与 ⽗节点⽐较，如果其键值⽐⽗节点⼤，就⽗⼦对换位置，如此⼀直上溯，直到不需要对换或直到根节点 为⽌。当取出⼀个元素时，最⼤值在根节点，取⾛根节点，要割舍最下层最右边的右节点，并将其值重新安插⾄最 ⼤堆，最末节点放⼊根节点后，进⾏⼀个下溯程序：将空间节点和其较⼤的节点对调，并持续下⽅，直到叶节点为 ⽌。



**priority_queue**

​		底层时⼀个 vector，使⽤ heap 形成的算法，插⼊，获取 heap 中元素的算法，维护这个 vector，以达到允许⽤户 以任何次序将任何元素插⼊容器内，但取出时⼀定是从优先权最⾼（数值最⾼）的元素开始取的⽬的。



**slist：**STL list 是⼀个双向链表， slist 是⼀个单向链表。



### 2、vector 使⽤的注意点及其原因，频繁对 vector 调⽤ push_back() 性 能影响

**使⽤注意点：**

注意插⼊和删除元素后迭代器失效的问题； 

清空 vector 数据时，如果保存的数据项是指针类型，需要逐项 delete，否则会造成内存泄漏。

**频繁调⽤ push_back()影响：**

​		向 vector 的尾部添加元素，很有可能引起整个对象 存储空间的重新分配，重新分配更⼤的内存，再将原数据拷⻉ 到新空间中，再释 放原有内存，这个过程是耗时耗⼒的，频繁对 vector 调⽤ push_back()会导致性能的下降。

​		在 C++11 之后， vector 容器中添加了新的⽅法： emplace_back() ，和 push_back() ⼀样的是都是在容器 末尾添加⼀个新的元素进去，不同的是 emplace_back() 在效率上相⽐较于 push_back() 有了⼀定的提升。

​		emplace_back() 函数在原理上⽐ push_back() 有了⼀定的改进，包括在内存优化⽅⾯和运⾏效率⽅⾯。内存 优化主要体现在使⽤了就地构造（直接在容器内构造对象，不⽤拷⻉⼀个复制品再使⽤）+强制类型转换的⽅法来 实现，在运⾏效率⽅⾯，由于省去了拷⻉构造过程，因此也有⼀定的提升。



### 3、map 和 set 有什么区别，分别⼜是怎么实现的？

​		map 和 set 都是 C++ 的关联容器，其底层实现都是红⿊树（RB-Tree）。

​		由于 map 和 set 所开放的各种操作接⼝，RB-tree 也都提供了，所以⼏乎所有的 map 和 set 的操作⾏为，都只是 转调 RB-tree 的操作⾏为。

​		

map 和 set 区别在于：

​		（1）map 中的元素是 key-value（关键字—值）对：关键字起到索引的作⽤，值则表示与索引相关联的数据；Set 与之相对就是关键字的简单集合，set 中每个元素只包含⼀个关键字。

​		（2）set 的迭代器是 const 的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为 map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么⾸先需要删除该键，然后调节平衡， 再插⼊修改后的键值，调节平衡，如此⼀来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改 变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；⽽map的 迭代器则不允许修改key值，允许修改value值。

​		（3）map⽀持下标操作，set不⽀持下标操作。map可以⽤key做下标，map的下标运算符[ ]将关键码作为下标去 执⾏查找，如果关键码不存在，则插⼊⼀个具有该关键码和mapped_type类型默认值的元素⾄map中，因此下标 运算符[ ]在map应⽤中需要慎⽤，const_map不能⽤，只希望确定某⼀个关键值是否存在⽽不希望插⼊元素时也不 应该使⽤，mapped_type类型没有默认值也不应该使⽤。如果find能解决需要，尽可能⽤find。



### 4、请你来说⼀说 STL 迭代器删除元素

​		这个主要考察的是迭代器失效的问题。

​		对于序列容器 vector，deque来说，使⽤ erase(itertor) 后，后边的每个元素的迭代器都会失效，但是后边每个元 素都会往前移动⼀个位置，但是 erase 会返回下⼀个有效的迭代器；

​		对于关联容器 map set 来说，使⽤了 erase(iterator) 后，当前元素的迭代器失效，但是其结构是红⿊树，删除当 前元素的，不会影响到下⼀个元素的迭代器，所以在调⽤ erase 之前，记录下⼀个元素的迭代器即可。

​		对于 list 来说，它使⽤了不连续分配的内存，并且它的 erase ⽅法也会返回下⼀个有效的 iterator，因此上⾯两种 正确的⽅法都可以使⽤。



### 5、请你来说⼀下 STL 中迭代器的作⽤，有指针为何还要迭代器

**迭代器**

​		Iterator（迭代器）模式⼜称 Cursor（游标）模式，⽤于提供⼀种⽅法顺序访问⼀个聚合对象中各个元素, ⽽⼜不 需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运⽤于聚合对象的⼀种模式，通过运⽤该 模式，使得我们可以在不知道对象内部表示的情况下，按照⼀定顺序（由iterator提供的⽅法）访问聚合对象中的 各个元素。

​		由于Iterator模式的以上特性：与聚合对象耦合，在⼀定程度上限制了它的⼴泛运⽤，⼀般仅⽤于底层聚合⽀持 类，如STL的list、vector、stack 等容器类及ostream_iterator等扩展iterator。



**迭代器和指针的区别**

​		迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的⼀些功能，通过重载了指针的⼀些操作符，-\>、 *、++、--等。迭代器封装了指针，是⼀个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的 对象， 本质是封装了原⽣指针，是指针概念的⼀种提升（lift），提供了⽐指针更⾼级的⾏为，相当于⼀种智能指 针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

​		迭代器返回的是对象引⽤⽽不是对象的值，所以cout只能输出迭代器使⽤*取值后的值⽽不能直接输出其⾃身。

**迭代器产⽣原因**

​		Iterator类的访问⽅式就是把不同集合类的访问逻辑抽象出来，使得不⽤暴露集合内部的结构⽽达到循环遍历集合 的效果。



### 6、回答⼀下 STL ⾥ resize 和 reserve 的区别

​		**resize()：**改变当前容器内含有元素的数量(size())，eg: vector v; v.resize(len);v的size变为len,如果原来v的size⼩于 len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即 下标为len，此时容器是size为len+1；

​		**reserve()：**改变当前容器的最⼤容量（capacity）,它不会⽣成元素，只是确定这个容器允许放⼊多少对象，如果 reserve(len)的值⼤于当前的capacity()，那么会重新分配⼀块能存len个对象的空间，然后把之前v.size()个对象通 过 copy construtor 复制过来，销毁之前的内存；

### 7、STL的两级空间配置器

1、首先明白为什么需要二级空间配置器？

我们知道动态开辟内存时，要在堆上申请，但若是我们需要

频繁的在堆开辟释放内存，则就会**在堆上造成很多外部碎片**，浪费了内存空间；

每次都要进行调用**malloc、free**函数等操作，使空间就会增加一些附加信息，降低了空间利用率；

随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。

于是就设置了二级空间配置器，**当开辟内存\<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**

关于STL中一级空间配置器和二级空间配置器的选择上，一般默认**选择的为二级空间配置器**。 如果大于128字节再转去一级配置器器。

#### 一级配置器

**一级空间配置器**中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：

1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数

2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常

3、如果自定义了处理函数就进行处理，完事再继续分配试试

![img](http://oss.interviewguide.cn/img/202205220035143.png)

#### 二级配置器

![img](http://oss.interviewguide.cn/img/202205220035104.png)

1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。

2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空： （1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。 （2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。 （3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。 3、内存池为空，申请内存 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。 4、malloc没有成功 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。

释放时调用deallocate()函数，若释放的n\>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：

1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；

2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。

### 8、Vector如何释放空间?

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要空间动态缩小，可以考虑使用deque。

如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。

```cpp
vector(Vec).swap(Vec); //将Vec中多余内存清除； 
vector().swap(Vec); //清空Vec的全部内存；
```

### 9、STL中的allocator、deallocator

1. 第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；
2. 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；
3. 空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；
4. 空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。



### 10、STL中hash table扩容发生什么？

1. hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。
2. 向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。



# 4.C++11 新特性

C++11 的特性主要包括下⾯⼏个⽅⾯：

​		提⾼运⾏效率的语⾔特性：右值引⽤、泛化常量表达式

​		原有语法的使⽤性增强：初始化列表、统⼀的初始化语法、类型推导、范围 for 循环、Lambda 表达式、final 和 override、构造函数委托

​		语⾔能⼒的提升：空指针 nullptr、default 和 delete、⻓整数、静态 assert

​		C++ 标准库的更新：智能指针、正则表达式、哈希表等

### 1、空指针 nullptr

​		nullptr 出现的⽬的是为了替代 NULL。

​		在某种意义上来说，传统 C++ 会把 NULL、 0 视为同⼀种东⻄，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定 义为 ((void*)0)，有些则会直接将其定义为 0。C++ 不允许直接将 void * 隐式转 换到其他类型，但如果 NULL 被定义为 ((void*)0)，那么当编译 char *ch = NULL; 时，NULL 只好被定义为 0。⽽这依然会产⽣问题，将导 致了 C++ 中᯿载特性 会发⽣混乱，考虑：

​		

```cpp
void func(int);
void func(char *);
```

​		对于这两个函数来说，如果 NULL ⼜被定义为了 0 那么 func(NULL) 这个语句将 会去调⽤ func(int)，从⽽导致代码 违反直观。

​		为了解决这个问题，C++11 引⼊了 nullptr 关键字，专⻔⽤来区分空指针、0。nullptr 的类型为nullptr_t，能够隐 式 的转换为任何指针或成员指针的类型，也能和他们进⾏相等或者不等的⽐较。

​		当需要使⽤ NULL 时候，养成直接使⽤ nullptr 的习惯。



### 2、Lambda 表达式

​		Lambda 表达式实际上就是提供了⼀个类似匿名函数的特性，⽽匿名函数则是在需要⼀个函数，但是⼜不想费⼒去 命名⼀个函数的情况下去使⽤的。

​		利⽤ lambda 表达式可以编写内嵌的匿名函数，⽤以替换独⽴函数或者函数对象，并且使代码更可读。

​		从本质上来讲， lambda 表达式只是⼀种语法糖，因为所有其能完成的⼯作都可以⽤其它稍微复杂的代码来实现， 但是它简便的语法却给 C++ 带来了深远的影响。

​		从⼴义上说， lamdba 表达式产⽣的是**函数对象**。在类中，可以**重载函数调⽤运算符()**，此时类的对象可以将具有 类似函数的⾏为，我们称这些对象为函数对象（Function Object）或者仿函数（Functor）。相⽐ lambda表达 式，函数对象有⾃⼰独特的优势。

​		lambda 表达式⼀般都是从⽅括号[]开始，然后结束于花括号{}，花括号⾥⾯就像定义函数那样，包含了 lamdba 表 达式体，⼀个最简单的例⼦如下：

```cpp
// 定义简单的lambda表达式
auto basicLambda = [] { cout << "Hello, world!" << endl; };
basicLambda(); // 输出：Hello, world!
```

​		上⾯是最简单的 lambda 表达式，没有参数。如果需要参数，那么就要像函数那样，放在圆括号⾥⾯，如果有返回 值，返回类型要放在-\>后⾯，即拖尾返回类型，当然你也可以忽略返回类型，lambda会帮你⾃动推断出返回类 型：

```cpp
// 指明返回类型，托尾返回类型
auto add = [](int a, int b) -> int { return a + b; };
// ⾃动推断返回类型
auto multiply = [](int a, int b) { return a * b; };
int sum = add(2, 5); // 输出：7
int product = multiply(2, 5); // 输出：10

```

​		最前边的 [] 是 lambda 表达式的⼀个很重要的功能，就是 闭包。

​		先说明⼀下 lambda 表达式的⼤致原理：每当你定义⼀个 lambda 表达式后，编译器会⾃动⽣成⼀个匿名类（这 个类当然重载了（）运算符），我们称为闭包类型（closure type）。

​		那么在运⾏时，这个 lambda 表达式就会返回⼀个匿名的闭包实例，其实⼀个**右值**。所以，我们上⾯的 lambda 表 达式的结果就是⼀个个闭包实例。

​		**闭包的⼀个强⼤之处是其可以通过传值或者引⽤的⽅式捕捉其封装作⽤域内的变量**，前⾯的⽅括号就是⽤来定义捕 捉模式以及变量，我们⼜将其称为 lambda 捕捉块。例⼦如下：

```cpp
int main() {
 int x = 10;
 
 auto add_x = [x](int a) { return a + x; }; // 复制捕捉x,lambda表达式⽆法修改此变量
 auto multiply_x = [&x](int a) { return a * x; }; // 引⽤捕捉x，lambda表达式可以修改此变量
 
 cout << add_x(10) << " " << multiply_x(10) << endl;
 // 输出：20 100
 return 0;
}
```



```
捕获的⽅式可以是引⽤也可以是复制，但是具体说来会有以下⼏种情况来捕获其所在作⽤域中的变量：
[]：默认不捕获任何变量；
[=]：默认以值捕获所有变量；
[&]：默认以引⽤捕获所有变量；
[x]：仅以值捕获x，其它变量不捕获；
[&x]：仅以引⽤捕获x，其它变量不捕获；
[=, &x]：默认以值捕获所有变量，但是x是例外，通过引⽤捕获；
[&, x]：默认以引⽤捕获所有变量，但是x是例外，通过值捕获；
[this]：通过引⽤捕获当前对象（其实是复制指针）；
[*this]：通过传值⽅式捕获当前对象；
```

⽽ lambda 表达式⼀个更重要的应⽤是其可以⽤于函数的参数，通过这种⽅式可以实现回调函数。其实，最常⽤的 是在STL算法中，⽐如你要统计⼀个数组中满⾜特定条件的元素数量，通过 lambda 表达式给出条件，传递给 count_if 函数：

```cpp
int val = 3;
vector<int> v {1, 8, 5, 3, 6, 10};
int count = std::count_if(v.beigin(), v.end(), [val](int x) { return x > val; });
// v中⼤于3的元素数量
```

最后给出 lambda 表达式的完整语法：

```cpp
[ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception
attribute -> ret { body }
// 可选的简化语法
[ capture-list ] ( params ) -> ret { body } 
[ capture-list ] ( params ) { body } 
[ capture-list ] { body }


capture-list：捕捉列表，这个不⽤多说，前⾯已经讲过，它不能省略；
params：参数列表，可以省略（但是后⾯必须紧跟函数体）；
mutable：可选，将 lambda 表达式标记为 mutable 后，函数体就可以修改传值⽅式捕获的变量；
constexpr：可选， C++17 ，可以指定 lambda 表达式是⼀个常ᰁ函数；
exception：可选，指定 lambda 表达式可以抛出的异常；
attribute：可选，指定 lambda 表达式的特性；
ret：可选，返回值类型；
body：函数执⾏体。
```



### 3、右值引⽤



**左值引用和右值引用**

左值引用：传统的C++中引用被称为左值引用

右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置

**这里主要说一下右值引用的特点：**

- 特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去
- 特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值
- 特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。

​		C++03 及之前的标准中，右值是不允许被改变的，实践中也通常使⽤ const T& 的⽅式传递右值。然⽽这是效率低 下的做法，例如：

```cpp
Person get(){
 Person p;
 return p;
}
Person p = get();
```

上述获取右值并初始化 p 的过程包含了 Person 的3个构造过程和2个析构过程。 这是 C++ ⼴受诟病的⼀点，但 C++11 的右值引⽤特性允许我们对右值进⾏修改。 借此可以实现 move语义 ，即从右值中直接拿数据过来初始化 或修改左值， ⽽不需要重新构造左值后再析构右值。⼀个 move 构造函数是这样声明的：

```cpp
class Person{
public:
 Person(Person&& rhs){...}
 ...
};
```



### 4. 泛化的常常表达式

还记得刚开始学习 C++ 给你的苦恼吗？你看：

```cpp
int N = 5;
int arr[N];
```

编译器会报错： error: variable length array declaration not allowed at file scope int arr[N]; 

但 N 就是5，不过编译器不知道这⼀点，于是我们需要声明为 const int N = 5 才可以。但C++11的 泛化常数给出了解决⽅案：

```cpp
constexpr int N = 5; // N 变成了⼀个只读的值
int arr[N]; // OK
```

constexpr 告诉编译器这是⼀个编译期常量，甚⾄可以把⼀个函数声明为编译期常量表达式。

```cpp
constexpr int getFive(){ return 5; }
int arr[getFive() + 1];

```

### 5、初始化列表

接下来⼏个特性属于原有语⾔特性的使⽤性增强。这意味着这些操作原来也是可以实现的， 不过现在语法上更加简 洁。⽐如⾸先要介绍的初始化列表。

⽽ C++11 提供了 initializer_list 来接受变⻓的对象初始化列表：

```cpp
#include <iostream>

class MyClass {
public:
    int num1;
    int num2;

    MyClass(int n1, int n2) : num1(n1), num2(n2) {
        // 构造函数的初始化列表
        // 使用冒号 : 标识，并在冒号后按照成员变量的声明顺序提供初始化值
    }

    void printNumbers() {
        std::cout << "num1: " << num1 << std::endl;
        std::cout << "num2: " << num2 << std::endl;
    }
};

int main() {
    MyClass obj(10, 20);
    obj.printNumbers();

    return 0;
}
```

注意初始化列表特性只是现有语法增强，并不是提供了动态的可变参数。该列表只能静态地构造。



### 6、统⼀的初始化语法

​		不同的数据类型具有不同的初始化语法。如何初始化字符串？如何初始化数组？如何初始化多维数组？如何初始化 对象？

​		C++11给出了统⼀的初始化语法：均可使⽤“{}-初始化变ᰁ列表”：

```cpp
X x1 = X{1,2};
X x2 = {1,2}; // 此处的'='可有可⽆
X x3{1,2};
X* p = new X{1,2};
struct D : X {
 D(int x, int y) :X{x,y} { /* … */ };
};
struct S {
 int a[3];
 // 对于旧有问题的解决⽅案
 S(int x, int y, int z) :a{x,y,z} { /* … */ };
};
```

### 7、类型推导

C++ 提供了 auto 和 decltype 来静态推导类型，在我们知道类型没有问题但⼜不想完整地写出类型的时候， 便可 以使⽤静态类型推导。

```cpp
for(vector<int>::const_iterator it = v.begin(); it != v.end(); ++it);
// 可以改写为
for(auto it = v.begin(); it != v.end(); ++it);

```

C++仍然是强类型的，会执⾏静态类型检查的语⾔。 这只是语法上的简化，并未改变C++的静态类型检查。

decltype ⽤于获取⼀个表达式的类型，⽽不对表达式进⾏求值（类似于 sizeof ）。 decltyp(e) 规则如下：

​		若 e 为⼀个⽆括号的变量、函数参数、类成员，则返回类型为该变量/参数/类成员在源程序中的声明类型；

​		否则的话，根据表达式的值分类（value categories），设设 T 为 e 的类型：

​				若 e 是⼀个左值（lvalue，即“可寻址值”），返回 T& ；

​				若 e 是⼀个临终值（xvalue），则返回值为 T&& ；

​				若 e 是⼀个纯右值（prvalue），则返回值为 T 。

```cpp
const std::vector<int> v(1);
const int&& foo(); // 返回临终值：⽣命周期已结束但内存还未拿⾛
auto a = v[0]; // a 为 int
decltype(v[0]) b = 0; // b 为 const int&
 // 即 vector<int>::operator[](size_type) const 的返回值类型
auto c = 0; // c, d 均为 int
auto d = c; 
decltype(c) e; // e 为 int，即 c 的类型
decltype((c)) f = e; // f 为 int&，因为 c 是左值
decltype(0) g; // g 为 int，因为 0 是右值
```

### 8、基于范围的for循环

Boost 中定义了很多"范围"，很多标准库函数都使⽤了范围⻛格的实现。这⼀概念被C++11提了出来：

```cpp
int arr[5];
std::vector<int> v;
for(int x: arr);
for(const int& x: arr);
for(int x: v);
for(auto &x: v);
```

### 9、构造函数委托

在 C# 和 Java 中，⼀个构造函数可以调⽤另⼀个来实现代码复⽤，但 C++⼀直不允许这样做。 

现在可以了，这使得构造函数可以在同⼀个类中⼀个构造函数调⽤另⼀个构造函数，从⽽达到简化代码的⽬的：

```cpp
class myBase {
 int number; string name;
 myBase( int i, string& s ) : number(i), name(s){}
public:
 myBase( ) : myBase( 0, "invalid" ){}
 myBase( int i ) : myBase( i, "guest" ){}
 myBase( string& s ) : myBase( 1, s ){ PostInit(); }
};

```

### 10、final 和 override

C++ 借由虚函数实现运⾏时多态，但 C++ 的虚函数⼜很多脆弱的地⽅：

​		⽆法禁⽌⼦类重写它。可能到某⼀层级时，我们不希望⼦类继续来重写当前虚函数了。

​		容易不⼩⼼隐藏⽗类的虚函数。⽐如在重写时，不⼩⼼声明了⼀个签名不⼀致但有同样名称的新函数。

C++11 提供了 final 来禁⽌虚函数被重写/禁⽌类被继承， override 来显示地重写虚函数。 这样编译器给我们 不⼩⼼的⾏为提供更多有⽤的错误和警告。

```cpp
struct Base1 final { }; 
struct Derived1 : Base1 {}; // 编译错：Base1不允许被继承
struct Base2 {
 virtual void f1() final;
 virtual void f2();
};
struct Derived2 : Base2 {
 virtual void f1(); // 编译错：f1不允许重写
 virtual void f2(int) override; // 编译错：⽗类中没有 void f2(int)
};
```



### 11、default 和 delete

我们知道编译器会为类⾃动⽣成⼀些⽅法，⽐如构造和析构函数（完整的列表⻅ Effective C++: Item 5）。 现在我们可以显式地指定和禁⽌这些⾃动⾏为了。

```cpp
struct classA {
 classA() = defauult; // 声明⼀个⾃动⽣成的函数
 classA(T value);
 void *operator new(size_t) = delete; // 禁⽌⽣成new运算符
};
```

在上述 classA 中定义了 classA(T value) 构造函数，因此编译器不会默认⽣成⼀个⽆参数的构造函数了， 如 果我们需要可以⼿动声明，或者直接 = default 。



### 12、静态 assertion

C++ 提供了两种⽅式来 assert ：⼀种是 assert 宏，另⼀种是预处理指令 #error 。 前者在运⾏期起作⽤，⽽后 者是预处理期起作⽤。它们对模板都不好使，因为模板是编译期的概念。 static_assert 关键字的使⽤⽅式如 下：

```cpp
template< class T >
struct Check {
 static_assert( sizeof(int) <= sizeof(T), "T is not big enough!" ) ;
} ;

```

### 13、智能指针

​		接下来介绍 C++11 对于 C++ 标准库的变更。C++11 把 TR1 并⼊了进来，废弃了 C++98 中的 auto_ptr ， 同时 将 shared_ptr 和 uniq_ptr 并⼊ std 命名空间。

```cpp
int main(){
 std::shared_ptr<double> p_first(new double);
 {
 std::shared_ptr<double> p_copy = p_first;
 *p_copy = 21.2;
 } // p_copy 被销毁，⾥⾯的 double 还有⼀个引⽤因此仍然保持
 return 0; // p_first 及其⾥⾯的 double 销毁
}
```



### 14、正则表达式

```cpp
const char *reg_esp = "[ ,.\\t\\n;:]";
std::regex rgx(reg_esp) ;
std::cmatch match ; 
const char *target = "Polytechnic University of Turin " ;
if( regex_search( target, match, rgx ) ) {
 const size_t n = match.size();
 for( size_t a = 0 ; a < n ; a++ ) {
 string str( match[a].first, match[a].second ) ;
 cout << str << "\n" ;
 }
}
```



### 15、增强的元组

在 C++ 中本已有⼀个 pair 模板可以定义⼆元组，C++11 更进⼀步地提供了变⻓参数的 tuple 模板：

```cpp
typedef std::tuple< int , double, string > tuple_1 t1;
typedef std::tuple< char, short , const char * > tuple_2 t2 ('X', 2, "Hola!");
t1 = t2 ; // 隐式类型转换

```



### 16、哈希表

C++ 的 map , multimap , set , multiset 使⽤红⿊树实现， 插⼊和查询都是 O(lgn) 的复杂度，

但 C++11 为这四种模板类提供了（底层哈希实现）以达到 O(1) 的复杂度：

std::unordered_set   std::unordered_multiset   std::unordered_map   std::unordered_multimap

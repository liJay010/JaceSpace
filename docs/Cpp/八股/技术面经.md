**一面48min**

1. 自我介绍

2. 研究生的研究方向

3. 做过什么后端开发相关的项目

4. webserver是你独立写的还是参考别人

5. 三个项目都是什么类型？

6. C++的内存结构

7. 堆区和栈区的区别

8. 什么情况下使用堆区什么情况使用栈区

9. 数组和链表的区别

10. 进程和线程的区别

11. i = i + 1大概执行多久

12. 进程间的通信方式有哪些

13. **了解中断吗**

中央处理单元（CPU）是计算机的核心组件，负责执行指令集中的指令。中断是一种机制，允许外部设备或软件在CPU执行指令的过程中打断正常的程序流，引起CPU执行一些特殊的处理程序。这样的机制是为了响应外部事件、处理异步事件或执行紧急任务而设计的。

以下是CPU处理中断的一般步骤：

1. **中断触发：** 中断可以是来自外部设备（例如硬件中断）或软件生成的（例如系统调用或异常）。当中断条件满足时，中断被触发。
2. **中断请求（IRQ）：** 外部设备或软件生成一个中断请求信号，通知CPU发生了中断事件。这个请求会被送到中断控制器（如果有的话）。
3. **中断控制器：** 中断控制器是一种硬件设备，用于协调和管理多个中断源。它确定中断的优先级，决定哪个中断应该被优先处理。在多核系统中，每个核可能有自己的中断控制器。
4. **中断向量：** 中断控制器将中断请求映射到一个中断向量，该向量指向中断服务程序的入口地址。中断向量是一个用于索引中断服务程序入口地址的数值。
5. **保存当前状态：** 在响应中断之前，CPU通常会保存当前执行的程序状态（例如程序计数器、寄存器状态等），以便在中断服务程序执行完毕后能够恢复到原来的状态。
6. **中断服务程序执行：** CPU跳转到中断服务程序的入口地址开始执行，这是一段专门设计来处理特定中断的代码。中断服务程序执行完成后，控制返回到原来的程序。
7. **恢复状态：** CPU使用之前保存的状态信息将程序状态还原到中断发生之前的状态。
8. **继续执行：** CPU继续执行被中断的程序，从中断点之后的指令继续执行。

14. 键盘上敲一个字母是什么中断

    ​		键盘输入通常通过中断方式被处理。当你在键盘上敲击一个键时，这会生成一个硬件中断，通知计算机发生了键盘输入事件。这个中断被称为"键盘中断"或"键盘中断请求"（Keyboard Interrupt Request，简称KIRQ）为硬中断。

    ​		具体来说，当你按下或释放键盘上的一个键时，键盘控制器产生一个中断信号，这个信号被传递给计算机的中断控制器。中断控制器会将这个键盘中断请求传递给处理器（CPU）。处理器接收到中断请求后，会停止当前执行的程序，保存当前的状态，并跳转到预定义的键盘中断服务程序的入口地址开始执行相应的处理代码。

    ​		在操作系统中，有一个用于处理键盘输入的中断服务程序，它负责解释键盘输入并将其传递给适当的应用程序或操作系统组件。这样，通过中断处理，计算机可以即时响应键盘输入事件，使用户能够与计算机进行交互。

    

15. Linux系统熟悉吗

16. 查找一个字符串是否在文件中

    grep "your_string" your_fil

    

17. 查找本机一个端口号的状态

    netstat -an | grep 8080

    ss -an | grep 8080

    lsof -i :8080

18. 几十个G的文件中查找一个字符串是否存在

19. 如何判断远程服务的端口有没有开启

    telnet remote_host remote_port

20. 平时在Linux上都用什么命令

    

21. 介绍一下OSI七层协议，各层协议都有哪些

    
    OSI（Open Systems Interconnection）模型是一个网络体系结构模型，将网络通信划分为七个不同的层次，每个层次负责特定的功能。每一层的功能都相对独立，通过定义标准的接口，不同层次的实现可以独立开发和修改。下面是 OSI 模型的七个层次及其相应的协议：

    1. **物理层（Physical Layer）：**

       - 功能：传输比特流，主要关注物理介质、电流、编码等。
       - 协议：没有特定的协议，主要涉及硬件标准（如Ethernet、Wi-Fi等）。

    2. **数据链路层（Data Link Layer）：**

       - 功能：负责将比特流组织成帧，进行错误检测和纠正。
       - 协议：ARP（Address Resolution Protocol）等。

    3. **网络层（Network Layer）：**

       - 功能：负责在不同网络之间进行路由和转发，实现端到端的数据传输。
       - 协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等。

    4. **传输层（Transport Layer）：**

       - 功能：提供端到端的通信，负责数据的可靠性、流量控制和错误恢复。
       - 协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。

    5. **会话层（Session Layer）：**

       - 功能：管理和协调会话，确保数据传输的正确顺序。
       - 协议：NetBIOS（Network Basic Input/Output System）等。

    6. **表示层（Presentation Layer）：**

       - 功能：处理数据的表示和格式，确保应用层能够解释数据。
       - 协议：JPEG、GIF、SSL/TLS（Secure Sockets Layer/Transport Layer Security）等。

    7. **应用层（Application Layer）：**

       - 功能：为用户提供网络服务，是网络应用程序的接口。

       - 协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）、DNS（Domain Name System）等。

         

22. 百度搜索到页面出现百度，这中间发生了什么

    - 域名解析DNS
    - 发起TCP的3次握手
    - 建立TCP连接后发起http请求
    - 服务器响应http请求，浏览器得到html代码
    - 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）
    - 浏览器对页面进行渲染呈现给用户。

23. 百度默认用什么端口 80

24. 三次握手

25. 两次握手可以吗

26. 如果网络情况非常好百分百不会发生拥塞，不会重传SYN，不会有历史连接的问题，可以两次握手吗？

27. 什么时候用tcp什么时候用udp

28. 此时此刻的视频面试用的udp还是tcp

29. udp丢包会有什么现象？

​	**数据丢失**

​	**乱序**

​	**延迟变化**

​	**应用层处理**



1. http和https的区别

   都是用于在网络上传输数据的协议，它们之间的主要区别在于安全性和加密。

   - **HTTP：** 传输的数据是明文的，不经过加密处理。
   - **HTTPS：** 使用SSL/TLS协议对数据进行加密，确保传输的数据在网络上是安全的。

   

2. 证书是绿色的是什么意思？

​		网站启用了HTTPS。这是为了加密数据传输，提高用户的数据安全性。



**二面1h**

1. proactor和reactor模式

"Reactor" 和 "Proactor" ，通常用于描述事件驱动编程中的不同策略。它们分别表示了两种不同的并发模型。

​	**Reactor 模式：**

- Reactor 是一种并发模型，用于处理并发 I/O 操作。

- 在 Reactor 模式中，有一个单独的事件分发器（Dispatcher）负责监听和分发事件。

- 当有事件发生时，分发器将事件分发给相应的处理器（Handlers）进行处理。

- 典型的例子是事件循环，例如在 GUI 编程中常见的事件循环模型。

  **Proactor 模式：**

- Proactor 也是一种处理并发 I/O 操作的并发模型，与 Reactor 不同，Proactor 更加关注异步处理。
- 在 Proactor 模式中，I/O 操作的启动和完成都由应用程序管理，而不是由事件分发器负责。
- 当一个异步操作完成时，系统会通知相应的处理器。
- Proactor 模式更适合高并发环境，因为它允许应用程序继续执行其他任务，而不必等待 I/O 操作完成。



1. 从数据流的角度描述一下proactor模式

​		Proactor 模式是一种用于处理异步 I/O 操作的设计模式。在 Proactor 模式中，关注的是异步事件的处理，而不是同步事件。下面从数据流的角度描述 Proactor 模式的工作流程：

1. **应用程序初始化：**
   - 应用程序初始化时，创建一个 Proactor 对象，该对象负责管理 I/O 操作的启动和完成。
2. **启动异步操作：**
   - 当应用程序希望执行一个异步 I/O 操作时，它会向 Proactor 对象提交请求，并指定操作的类型、数据缓冲区、回调函数等信息。
3. **Proactor 启动操作：**
   - Proactor 接收到应用程序提交的异步请求后，负责启动相应的异步 I/O 操作。这可能涉及到操作系统的异步 I/O API。
4. **应用程序继续执行：**
   - Proactor 模式的关键点是，在 I/O 操作执行的过程中，应用程序不会被阻塞。它可以继续执行其他任务，而无需等待 I/O 操作的完成。
5. **I/O 操作完成通知：**
   - 当异步 I/O 操作完成时，操作系统会通知 Proactor 对象。这通常通过操作系统提供的事件通知机制来实现。
6. **Proactor 调用回调函数：**
   - Proactor 对象收到 I/O 操作完成通知后，调用应用程序事先注册的回调函数。这个回调函数负责处理已完成的 I/O 操作的结果。
7. **应用程序处理结果：**
   - 在回调函数中，应用程序可以处理异步操作的结果，检查错误状态，读取或写入数据，然后根据需要提交更多的异步请求。

通过 Proactor 模式，应用程序在执行异步 I/O 操作的同时可以继续执行其他任务，而不必等待 I/O 操作的完成。这种模式特别适用于高并发的网络编程场景，如服务器处理大量并发连接时，可以更有效地利用系统资源。



1. 五种IO模型
2. epoll是同步还是异步的？这个争议很大

​		IO层面，epoll是同步的。
​		从消息处理层面，epoll是异步的。

1. 如何用同步IO模拟proactor模式

   **使用线程或多线程：**

   - 在同步 I/O 模型下，可以使用线程或多线程的方式，其中一个线程负责执行 I/O 操作，而其他线程负责应用程序的其他任务。这种方式可以让应用程序在等待 I/O 操作完成的同时继续执行其他任务。

   **回调函数：**

   - 使用回调函数的概念，让应用程序可以在 I/O 操作完成时执行特定的回调函数。这样，当 I/O 操作完成时，应用程序能够得到通知，并执行相应的处理逻辑。

   **事件轮询（Event Loop）：**

   - 通过事件轮询机制，模拟 Proactor 模式中的事件通知。在同步 I/O 模型下，应用程序可以通过定期检查 I/O 操作的状态来模拟事件的发生。当状态表明 I/O 操作完成时，应用程序可以执行相应的回调函数。

1. Linux如何切换目录、查看端口绑定情况、查看cpu利用率命令

   cd   netstat/ss   top

2. 什么是qps和tps，如何计算

​		QPS “Queries Per Second” 每秒查询率。
​		TPS ”Transactions Per Second“ 每秒事务数，一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。

1. 线程池数量如何确定

   **任务的性质：**

   - 任务是否是 CPU 密集型（计算密集型）还是 I/O 密集型（例如，网络请求、文件操作）？
   - 如果是 CPU 密集型任务，线程池的大小通常设置为 CPU 核心数。
   - 如果是 I/O 密集型任务，可以使用更多的线程，因为线程在等待 I/O 操作完成时可以执行其他任务。

   **硬件环境：**

   - CPU 核心数：线程池的大小通常不宜超过可用的 CPU 核心数。过多的线程可能导致线程切换开销增加而降低性能。

   - 内存：每个线程会占用一定的内存，因此要确保线程池大小不会消耗过多的系统内存。

     

2. 线程池和任务队列有没有做分离



1. 线程池中怎么利用的信号量机制

1. CPU利用率拉满的时候在线程池中增加线程是否能提高qps
2. http的5类状态码
3. 是否使用过lib库，动态链接库静态链接库特点、区别
4. 进程线程区别、通信方式
5. 协程
6. 
7. static加在全局变量上
8. 加在局部变量上
9. 加在类成员函数上
10. 如何使用类中的static成员函数
11. static数据成员如何修改
12. const加在不同位置的效果，和static问法差不多
13. 全局变量的默认关键字
14. 面向对象三大特性
15. 虚函数表在什么时候创建的、存在什么位置
16. 虚函数存在什么位置
17. 虚函数指针在什么时候创建
18. 虚函数为什么能实现多态
19. 函数调用的过程中堆栈的变化情况
20. 什么是内存泄漏、如何防止
21. 既然提到智能指针，说几个常见的，哪个比较熟
22. 你提到RAII，什么是RAII、智能指针为什么能防止内存泄漏
23. 看过智能指针的源码吗？讲一下shared_ptr的内部结构
24. 如果一个传给shared_ptr一个引用，那么引用计数会不会+1
25. 宏定义，有无类型检查，在什么阶段生效



**一面**

1. 深挖实习经历，由于涉及page cache，还问了page cache的作用（20min左右）
2. MySQL用char和varchar什么区别？（一开始没想到，后面经过引导是char在更改字段比较多的场景下容易导致页分裂）
4. 顺势问一下MySQL底层数据结构，为啥不用二叉树，B树或者哈希表？
5. C++智能指针shared_ptr底层结构体有哪些成员？分别有什么用？



**一面**

1. 介绍项目
2. 线程池的线程数量怎么确定？
3. 工作队列大小有什么用，怎么确定？
4. CPU密集型和IO密集型怎么判断？项目的具体场景是什么？
5. Webserver的压力测试怎么做的，Webbench原理是什么？
6. WebServer项目和别人做的有什么区别？
7. CPU和磁盘怎么交互的？
8. MESI协议

9.进程间通信方式有哪些？

10.内存映射工作机制

​		内存映射是一种将文件或其他对象映射到程序地址空间的机制，使得应用程序可以直接读取和写入这些对象，就好像它们是内存中的数据结构一样。这种机制通常用于处理大型文件或共享数据，以提高性能和简化编程模型。下面是内存映射的工作机制的一般步骤：

1. **打开文件或对象：** 首先，应用程序需要打开文件或对象，这可以通过文件系统调用（如`open`）来完成。如果是在Unix/Linux系统上，也可以使用`mmap`系统调用来映射内存。
2. **配置映射参数：** 在打开文件之后，应用程序需要配置映射参数，包括映射的起始地址、映射的长度、映射的权限（读、写、执行等）以及映射的标志（共享或私有）。这些参数通常由特定的系统调用或库函数提供。
3. **进行内存映射：** 一旦映射参数被配置好，应用程序通过系统调用（如`mmap`）将文件或对象映射到其地址空间。内核会为映射分配一段虚拟内存，并将文件的内容或对象的数据加载到这个虚拟内存中。
4. **访问映射的数据：** 一旦映射完成，应用程序可以直接通过内存访问操作来读取或写入映射的数据，而不需要进行额外的文件读写操作。这样的访问通常更加高效，因为它减少了系统调用和数据传输的开销。
5. **同步和刷新：** 如果应用程序对映射的数据进行了修改，可能需要调用同步（`msync`）或刷新（`flush`）操作，将内存中的修改同步回文件或对象中，以确保数据的一致性。
6. **解除映射：** 当应用程序不再需要映射时，需要通过系统调用（如`munmap`）解除映射关系，释放相应的资源。这会导致操作系统回收相应的虚拟内存，并根据需要刷新修改。

总体而言，内存映射提供了一种方便且高效的访问文件或对象数据的方式，使得程序员可以像操作内存一样访问这些数据，而不必过多地关心底层的文件 I/O 操作。

11.内存映射和共享内存区别？

​		**内存映射：**

1. **映射方式：** 内存映射是将文件或其他对象映射到进程的地址空间，使得这些对象可以像内存一样被访问。这包括文件映射和匿名映射。
2. **文件映射：** 主要用于将文件映射到内存，这样可以直接在内存中读取或写入文件数据，而无需通过传统的文件 I/O 操作。
3. **匿名映射：** 创建一个与文件无关的映射，可以用于进程间通信或创建共享的内存区域。
4. **使用场景：** 内存映射通常用于处理文件、数据库等大型数据集，或者用于多进程之间的通信。

**共享内存：**

1. **共享方式：** 共享内存是通过在不同的进程之间创建共享的内存区域，使得这些进程可以直接访问共享的内存段，而无需通过中间介质。
2. **通信方式：** 共享内存主要用于进程间通信，允许多个进程之间快速、高效地共享数据。进程可以读取和写入共享内存中的数据，实现数据的共享。
3. **使用场景：** 共享内存通常用于需要频繁交换大量数据的进程之间，以提高性能和效率。

**区别总结：**

1. **映射对象：** 内存映射主要涉及将文件或其他对象映射到进程的地址空间，而共享内存是直接在不同进程之间创建共享的内存区域。
2. **用途：** 内存映射通常用于处理文件、数据库等数据集，而共享内存用于进程间通信，特别是需要频繁交换大量数据的情况。
3. **实现机制：** 内存映射可以是文件映射或匿名映射，而共享内存是直接创建一块共享的内存区域。



12.滑动窗口和拥塞控制分别干什么，差异是什么？

13.构成一个计算机需要什么，各个组件做什么工作，越详细越好

 

1. 介绍项目
4. 详细介绍一下epoll底层实现
5. 介绍一些poll，select底层实现
6. 红黑树怎么实现的
7. Linux内存回收机制
8. 平常的学习方法
9. 对云了解多少，对容器了解多少？

10.对Linux内核开发的认识





1. C++智能指针有哪些
2. 详细介绍一下shared_ptr
3. 进程间有哪些通信方式
4. 进程和线程有什么差异
5. 写代码为什么要封装和继承
8. 介绍回溯的时间复杂度
9. 内存中的堆和栈介绍一下
10. 进程间通信方式
11. 介绍一下协程
12. C++有哪些新特性



1. 问项目，做了什么优化和改进
2. 有没有写文档的习惯，怎么记录
3. 跑C++程序的时候如果进程崩了，怎么排查问题？
4. 因为讲到日志，所以问了怎么写和使用日志系统
5. 异常怎么处理
6. 介绍一下Linux的日志系统
7. 算法题：判断给出的IP地址是否合法，easy难度



# here

1. 浏览器输入百度到呈现页面发生了什么？
2. TCP三次握手/四次挥手描述？
3. TCP的TFO功能了解吗，有什么用？
4. 四次挥手的2MSL有什么用？
5. webserver在断开一个请求的socket连接时又进来一个socket连接，描述一下会发生什么
6. 为啥要用虚拟内存，怎么实现？
7. 算法题：用栈实现队列
8. 算法题：接雨水
9. TCP是全双工的，HTTP是哪种？全双工半双工单工？
10. APP想要向手机发送一个推送，怎么实现的？TCP连接是一直保持连接的吗？
11. Reactor模式的单线程模型了解吗，介绍一下？有哪些常见的系统或者服务器用了这个
12. Reactor模式的单线程模式怎么实现的
13. Proactor介绍一下
14. Epoll是阻塞/非阻塞？异步/同步？
15. 怎么实现异步，有哪些应用场景和函数？
16. 服务器有一个连接进来，到应用程序读取到数据，需要经过几次内核态/用户态切换？需要几次缓冲区数据的拷贝？
17. 计算机为什么需要缓冲区？
18. 零拷贝介绍一下
19. DMA介绍一下
20. 了解协程吗
21. 了解RAII吗
22. 进程和线程在创建/释放的时候有什么不同？
23. C++中有哪些原子操作
24. C++中原子操作有哪些库函数，怎么实现的？
25. Mutex加锁底层怎么实现的？
26. 什么是自旋锁？
27. TCP四次挥手介绍一下，这个MSL是什么意思
28. C++中不借助中间变量，怎么交换两个变量的值？提示，二进制操作
29. 算法题：小于n的最大整数
30. webserver的项目中，多个子线程执行请求的顺序是如何决定的？
31. 服务端的socket接收缓冲区只剩10个字节，但是客户端发过来一个未经过分片的12个字节的报文。之后客户端和服务端分别会发生什么事情？如果服务端的接收窗口变为0会怎么样？
32. 场景题：很多小文件（总量1T）想从一台主机传输到另外一台主机，保证速度的前提下设计一个方案
33. mmap在这个场景中可以用到吗？
34. 场景题：设计一个函数，这个函数没有任何输入，每次执行这个函数就会返回一个INT64的值，要保证返回的值是全局唯一的，也就是之前没有输出过的，怎么操作？
35. 读一个大文件和读很多个小文件效率是一样的吗？假设小文件总量和大文件大小一致。追问：那如果读小文件，磁头来回移动，有没有优化的办法
36. STL中优先队列的底层是怎么实现的
37. 小顶堆取出顶部元素之后，下面的元素怎么更新？
38. C++尾部递归
39. 算法题：机器人走格子；进阶：有障碍物的情况
40. shared_ptr底层的引用计数怎么实现的？
41. shared_ptr怎么实现线程安全？比如当一个线程创建指向a内存的shared_ptr，另一个线程销毁了一个指向a内存的shared_ptr，怎么保证安全？
42. C++的多态是什么？
43. C++的动态绑定怎么实现的？
44. 比如一个派生类继承自2个基类，这两个基类中的虚函数表怎么关联到派生类中的虚函数表，比如用基类的指针指向了一个派生类对象，怎么用vptr找到派生类中重新定义的A基类中的虚函数？
45. STL中，比如vector，是如何做内存管理的？
46. TCP的拥塞控制和流量控制有什么区别？
47. TCP的keep-alive和HTTP的keep-alive有什么区别？
48. 算法题：打印螺旋矩阵
49. 算法题：设计一个数据结构，其读，写，随机取，删除的时间复杂度都比较低。
50. C++左值和右值
51. 动态绑定怎么实现？
52. 一个类有多个基类，内存中怎么虚函数表是怎么分布的？
53. 函数调用机制？

1. 怎么定位内存泄漏的位置？
2. mysql为什么用可重复读而不用串行读？为什么用可重复读而不用读已提交。
3. Webserver如果一个fd上来了数据，但是还没有读它要花很长的时间，这个时候不会就把这个fd给close掉了吗？
4. MySQL日志线程怎么获取数据的？也是用队列嘛？这个队列的信号量怎么用的？
5. 设计类似12306铁路网站的后台抢票系统。
6. 自旋锁和互斥锁有什么区别？分别适合什么场景？
7. MySQL的order by和group by会走索引吗？
8. WebServer线程池的线程数和工作队列的大小是怎么确定的？这个子线程是怎么获得socket连接的fd的？如果工作队列满了，后续进来的请求怎么处理呢？

1. C++ shared_ptr如何保证线程安全？
2. C++如何解决线程安全问题？
3. C++派生类的构造和析构顺序是什么？为什么按照这种顺序？
4. C++11中有什么新特性？
5. 内存对齐有什么用？
6. 给出几个类，判断类占的内存大小
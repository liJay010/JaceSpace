# 情景设计类问题

### 1、HelloWorld 程序开始到打印到屏幕上的全过程?

1.⽤户告诉操作系统执⾏ HelloWorld 程序（通过键盘输⼊等）； 

2.操作系统：找到 HelloWorld 程序的相关信息，检查其类型是否是可执⾏⽂件；并通过程序⾸部信息，确定代 码和数据在可执⾏⽂件中的位置并计算出对应的磁盘块地址；

3.操作系统：创建⼀个新进程，将 HelloWorld 可执⾏⽂件映射到该进程结构，表示由该进程执⾏ HelloWorld 程序；

4.操作系统：为 HelloWorld 程序设置 cpu 上下⽂环境，并跳到程序开始处； 

5.执⾏ HelloWorld 程序的第⼀条指令，发⽣缺⻚异常；

6.操作系统：分配⼀⻚物理内存，并将代码从磁盘读⼊内存，然后继续执⾏ HelloWorld 程序; HelloWorld 程序执⾏ puts 函数（系统调⽤），在显示器上写⼀字符串; 

7.操作系统：找到要将字符串送往的显示设备，通常设备是由⼀个进程控制的，所以，操作系统将要写的字符串 送给该进程; 

8.操作系统：控制设备的进程告诉设备的窗⼝系统，它要显示该字符串，窗⼝系统确定这是⼀个合法的操作，然 后将字符串转换成像素，将像素写⼊设备的存储映像区; 

9.视频硬件将像素转换成显示器可接收和⼀组控制数据信号; 

10.显示器解释信号，激发液晶屏; 

11.OK，我们在屏幕上看到了 HelloWorld;

### 2、⼿写实现智能指针类

```cpp
template<typename T>
class SharedPtr {
	private:
	     size_t* m_count_;
	T* m_ptr_;
	public:
	 //构造函数
	SharedPtr(): m_ptr_(nullptr),m_count_(new size_t) {
	}
	SharedPtr(T* ptr): m_ptr_(ptr),m_count_(new size_t) {
		*m_count_ = 1;
	}
	//析构函数
	~SharedPtr() {
		-- (*m_count_);
		if (*m_count_ == 0) {
			delete m_ptr_;
			delete m_count_;
			m_ptr_ = nullptr;
			m_count_ = nullptr;
		}
	}
	//拷⻉构造函数
	SharedPtr(const SharedPtr& ptr) {
		m_count_ = ptr.m_count_;
		m_ptr_ = ptr.m_ptr_;
		++(*m_count_);
	}
	//拷⻉赋值运算
	void operator=(const SharedPtr& ptr) {
		SharedPtr(std::move(ptr));
		//移动构造函数
		SharedPtr(SharedPtr&& ptr) : m_ptr_(ptr.m_ptr_), m_count_(ptr.m_count_) {
			++
			(*m_count_);
		}
		//移动赋值运算
		void operator=(SharedPtr&& ptr) {
			SharedPtr(std::move(ptr));
		}
		//解引⽤
		T& operator*() {
			return *m_ptr_;
		}
		//箭头运算
		T* operator->() {
			return m_ptr_;
		}
		//重载bool操作符
		operator bool() {
			return m_ptr_ == nullptr;
		}
		T* get() {
			return m_ptr_;
		}
		size_t use_count() {
			return *m_count_;
		}
		bool unique() {
			return *m_count_ == 1;
		}
		void swap(SharedPtr& ptr) {
			std::swap(*this, ptr);
		}
	}
	;
	;
}
```



### 3、⼿写字符串函数 strcat，strcpy，strncpy，memset，memcpy实 现

```cpp
//把 src 所指向的字符串复制到 dest，注意：dest定义的空间应该⽐src⼤。
char* strcpy(char *dest,const char *src) {
	char *ret = dest;
	assert(dest!=NULL);
	//优化点1：检查输⼊参数
	assert(src!=NULL);
	while(*src!='\0')
	 *(dest++)=*(src++);
	*dest='\0';
	//优化点2：⼿动地将最后的'\0'补上
	return ret;
}
//考虑内存᯿叠的字符串拷⻉函数 优化的点
char* strcpy(char *dest,char *src) {
	char *ret = dest;
	assert(dest!=NULL);
	assert(src!=NULL);
	memmove(dest,src,strlen(src)+1);
	return ret;
}
//把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
char* strcat(char *dest,const char *src) {
	//1. 将⽬的字符串的起始位置先保存，最后要返回它的头指针
	//2. 先找到dest的结束位置,再把src拷⻉到dest中，记得在最后要加上'\0'
	char *ret = dest;
	assert(dest!=NULL);
	assert(src!=NULL);
	while(*dest!='\0')
	 dest++;
	while(*src!='\0')
	*(dest++)=*(src++);
	*dest='\0';
	return ret;
}
//把 str1 所指向的字符串和 str2 所指向的字符串进⾏⽐较。
//该函数返回值如下：
//如果返回值 < 0，则表示 str1 ⼩于 str2。
//如果返回值 > 0，则表示 str1 ⼤于 str2。
//如果返回值 = 0，则表示 str1 等于 str2。
int strcmp(const char *s1,const char *s2) {
	assert(s1!=NULL);
	assert(s2!=NULL);
	while(*s1!='\0' && *s2!='\0') {
		if(*s1>*s2)
		 return 1; else if(*s1<*s2)
		 return -1; else {
			s1++,s2++;
		}
	}
	//当有⼀个字符串已经⾛到结尾
	if(*s1>*s2)
	 return 1; else if(*s1<*s2)
	 return -1; else
	 return 0;
}
//在字符串 str1 中查找第⼀次出现字符串 str2 的位置，不包含终⽌符 '\0'。
char* strstr(char *str1,char *str2) {
	char* s = str1;
	assert(str1!='\0');
	assert(str2!='\0');
	if(*str2=='\0')
	 return NULL;
	//若str2为空，则直接返回空
	while(*s!='\0') {
		//若不为空，则进⾏查询
		char* s1 = s;
		char* s2 = str2;
		while(*s1!='\0'&&*s2!='\0' && *s1==*s2)
		 s1++,s2++;
		if(*s2=='\0')
		 return str2;
		//若s2先结束
		if(*s2!='\0' && *s1=='\0')
		 return NULL;
		//若s1先结束⽽s2还没结束，则返回空
		s++;
	}
	return NULL;
}
//模拟实现memcpy函数 从存储区 str2 复制 n 个字符到存储区 dst。
void* memcpy(void* dest, void* src, size_t num) {
	void* ret = dest ;
	size_t i = 0 ;
	assert(dest != NULL ) ;
	assert(src != NULL) ;
	for (i = 0; i<num; i++) {
		//因为void* 不能直接解引⽤，所以需要强转成char*再解引⽤
		//此处的void*实现了泛型编程
		*(char*) dest = *(char*) src ;
		dest = (char*)dest + 1 ;
		src = (char*) src + 1 ;
	}
	return ret ;
}
//考虑内存᯿叠的memcpy函数 优化的点
void* memmove(void* dest, void* src, size_t num) {
	char* p1 = (char*)dest;
	char* p2 = (char*)src;
	if(p1<p2) {
		//p1低地址p2⾼地址
		for (size_t i=0; i!=num; ++i)
		 *(p1++) = *(p2++);
	} else {
		//从后往前赋值
		p1+=num-1;
		p2+=num-1;
		for (size_t i=0; i!=num; ++i)
		 *(p1--) = *(p2--);
	}
	return dest;
}
```

### 4、C++ 模板是什么，底层怎么实现的？

​		编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产⽣不同的函数；编译器 会对函数模板进⾏两次编译：在声明的地⽅对模板代码本身进⾏编译，在调⽤的地⽅对参数替换后的代码进⾏编 译。 

​		这是因为函数模板要被实例化后才能成为真正的函数，在使⽤函数模板的源⽂件中包含函数模板的头⽂件，如果该 头⽂件中只有声明，没有定义，那编译器⽆法实例化该模板，最终导致链接错误。



### 5、请你来写个函数在 main 函数执⾏前先运⾏

```cpp
//第⼀种：gcc扩展，标记这个函数应当在main函数之前执⾏。同样有⼀个__attribute((destructor))，标记函
//数应当在程序结束之前（main结束之后，或者调⽤了exit后）执⾏;
__attribute((constructor))void before() {
	printf("before main 1\n");
}
//第⼆种：全局 static 变量的初始化在程序初始阶段，先于 main 函数的执⾏
int test1() {
	cout << "before main 2" << endl;
	return 1;
}
static int i = test1();
// 第三种：知乎⼤⽜ Milo Yip 的回答利⽤ lambda 表达式
int a = []() {
	cout << "before main 3" << endl;
	return 0;
}
();
int main(int argc, char** argv) {
	cout << "main function" <<endl;
	return 0;
}
```

### 6、请你来说⼀下 fork 函数

```cpp
#Fork：创建⼀个和当前进程映像⼀样的进程可以通过 fork() 系统调⽤：
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);

```

​		成功调⽤ fork() 会创建⼀个新的进程，它⼏乎与调⽤ fork() 的进程⼀模⼀样，这两个进程都会继续运⾏。在⼦进程 中，成功的 fork( ) 调⽤会返回0。在⽗进程中 fork() 返回⼦进程的 pid。

​		如果出现错误，fork() 返回⼀个负值。

​		最常⻅的 fork() ⽤法是创建⼀个新的进程，然后使⽤ exec() 载⼊⼆进制映像，替换当前进程的映像。这种情况下， 派⽣（fork）了新的进程，⽽这个⼦进程会执⾏⼀个新的⼆进制可执⾏⽂件的映像。这种“派⽣加执⾏”的⽅式是很 常⻅的。

​		在早期的 Unix 系统中，创建进程⽐较原始。当调⽤ fork 时，内核会把所有的内部数据结构复制⼀份，复制进程的 ⻚表项，然后把⽗进程的地址空间中的内容逐⻚的复制到⼦进程的地址空间中。但从内核⻆度来说，逐⻚的复制⽅ 式是⼗分耗时的。现代的 Unix 系统采取了更多的优化，例如 Linux，采⽤了写时复制的⽅法，⽽不是对⽗进程空 间进程整体复制。

### 7、说⼀下 ++i 和 i++ 的区别

​		++i （前置加加）先⾃增 1再返回，i++ （后置加加）先返回 i 再⾃增1。 前置加加不会产⽣临时对象，后置加加必须产⽣临时对象，临时对象会导致效率降低

++i 实现：

```cpp
int& int::operator++ (){
 *this +=1；
 return *this；
}
```

​		i++ 实现：

```cpp
const int int::operator（int）{
 int oldValue = *this；
 ++（*this）；
 return oldValue；
}
```

### 8、简单说⼀下 printf 实现原理？

​		在C/C++中，对函数参数的扫描是从后向前的。C/C++的函数参数是通过压⼊堆栈的⽅式来给函数传参数的（堆栈 是⼀种先进后出的数据结构）。

​		最先压⼊的参数最后出来，在计算机的内存中，数据有 2 块，⼀块是堆，⼀块是栈（函数参数及局部变量在这 ⾥），⽽栈是从内存的⾼地址向低地址⽣⻓的，控制⽣⻓的就是堆栈指针了，最先压⼊的参数是在最上⾯，就是说 在所有参数的最后⾯，最后压⼊的参数在最下⾯，结构上看起来是第⼀个，所以最后压⼊的参数总是能够被函数找 到。

​		因为它就在堆栈指针的上⽅。printf的第⼀个被找到的参数就是那个字符指针，就是被双引号括起来的那⼀部分， 函数通过判断字符串⾥控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移 量了



### 9、讲讲⼤端⼩端，如何检测

⼤端模式：是指数据的⾼字节保存在内存的低地址中，⽽数据的低字节保存在内存的⾼地址端。 

⼩端模式，是指数据的⾼字节保存在内存的⾼地址中，低位字节保存在在内存的低地址端。



**直接读取存放在内存中的⼗六进制数值，取低位进⾏值判断**

```cpp
int a = 0x12345678;
int *c = &a;
c[0] == 0x12 ⼤端模式
c[0] == 0x78 ⼩段模式

```

**⽤共同体来进⾏判断**

​		union 共同体所有数据成员是共享⼀段内存的，后写⼊的成员数据将覆盖之前的成员数据，成员数据都有相同的⾸ 地址。Union 的⼤⼩为最⼤数据成员的⼤⼩。

​		union 的成员数据共⽤内存，并且⾸地址都是低地址⾸字节。Int i= 1时：⼤端存储1放在最⾼位，⼩端存储1放在最 低位。当读取char ch时，是最低地址⾸字节，⼤⼩端会显示不同的值。

```cpp
#include <stdio.h>
int main() {
	union {
		int a;
		//4 bytes
		char b;
		//1 byte
	}
	data;
	data.a = 1;
	//占4 bytes，⼗六进制可表示为 0x 00 00 00 01
	//b因为是char型只占1Byte，a因为是int型占4Byte
	//所以，在联合体data所占内存中，b所占内存等于a所占内存的低地址部分
	if(1 == data.b) {
		//⾛到这⾥意味着说明a的低字节，被取给到了b
		//即a的低字节存在了联合体所占内存的(起始)低地址，符合⼩端模式特征
		printf("Little_Endian\n");
	} else {
		printf("Big_Endian\n");
	}
	return 0;
}
```

### 10、分别写出 bool，int，float，指针类型的变ᰁ a 与“零”的⽐较语句。

```cpp
bool:if ( !a ) or if(a)
int: if ( a == 0)
float: const EXPRESSION EXP = 0.000001 if ( a <= EXP && a >= -EXP)
pointer : if ( a != NULL) or if(a == NULL)
    
    //⽆论是 float 还是 double 类型的变量，都有精度限制。所以⼀定要避免将浮点变ᰁ⽤“==”或“！=”与数字⽐较，应 该设法转化成“>=”或“<=”形式。
```

### 11、回调函数的作⽤

​		当发⽣某种事件时，系统或其他函数将会⾃动调⽤你定义的⼀段函数；

​		回调函数就相当于⼀个中断处理函数，由系统在符合你设定的条件时⾃动调⽤。为此，你需要做三件事：1，声 明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为⼀个参数，以便于系统调 ⽤；

​		回调函数就是⼀个通过函数指针调⽤的函数。如果你把函数的指针（地址）作为参数传递给另⼀个函数，当这个指 针被⽤为调⽤它所指向的函数时，我们就说这是回调函数；

​		因为可以把调⽤者与被调⽤者分开。调⽤者不关⼼谁是被调⽤者，所有它需知道的，只是存在⼀个具有某种特定原 型、某些限制条件（如返回值为int）的被调⽤函数。
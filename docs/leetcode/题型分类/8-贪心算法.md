# 8-贪心算法

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**

### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int child = 0, si = 0;
        while(child < g.size() && si < s.size())
        {
            if(s[si] >= g[child])
            {
                si++;
                child++;
            }
            else si++;
        }
        return child;
    }
};
```

### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

此题可当作搜索题，满足条件+1即可，不要想复杂了

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        int cur = 1, res = 1 , pre = 0;
        for(int i = 1; i < nums.size();i++)
        {
            if((nums[i] - nums[i - 1] != 0) && ((nums[i] - nums[i - 1]) * pre) <= 0)cur++;
            pre = nums[i] - nums[i - 1] == 0 ? pre :(nums[i] - nums[i - 1]) / abs(nums[i] - nums[i - 1]);
            res = max(cur,res);
        }
        return res;
    }
};
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int cur = 0 ,res = nums[0];
        for(int i : nums)
        {
            cur += i;
            res = max(cur , res);
            if(cur < 0)cur = 0;
        }
        return res;
    }
};
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0;
        for(int i = 1; i < prices.size();i++)
        {
            if(prices[i] - prices[i-1] > 0) res += prices[i] - prices[i-1];
        }
        return res;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int step = 0 , cur = 0;
        while(cur < nums.size())
        {
            step = max(step - 1,nums[cur]);
            if(step <= 0 && cur < nums.size() - 1) return false;
            else cur++;
        }
        return true;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int step = 0 , cur = 0;
        while(cur < nums.size() - 1)
        {
            int add = 1 , mu = 0;
            for(int i = 1 ; i <= nums[cur];i++)
            {
                if(cur + i >= nums.size() - 1) return step + 1;
                if(nums[cur + i] + i >= mu)
                {
                    mu = nums[cur + i] + i;
                    add = i;
                }
            }
            step++;
            cur += add;
        }
        return step;
    }
};
```

### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```cpp
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        int cur = 0 ,mins = INT_MAX;
        while(cur < nums.size() && k)
        {
            if(nums[cur] < 0)
            {
                nums[cur] = -nums[cur];
                k--;
                mins = min(nums[cur],mins);
            }
            else if(nums[cur] == 0) 
            {
                k = 0;
                break;
            }
            else 
            {
                mins = min(nums[cur],mins);
                break;
            }
            cur++;
        }
        mins = k % 2 == 0 ? 0: -2 * mins;
        return accumulate(nums.begin(),nums.end(),0) + mins;
    }
};
```

### [134. 加油站](https://leetcode.cn/problems/gas-station/)

可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。

每个加油站的剩余量rest[i]为gas[i] - cost[i]。

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int cur_oil = 0 , all_oil = 0 , start = 0;

        for(int i = 0; i < gas.size();i++)
        {
            cur_oil += gas[i] - cost[i];
            all_oil += gas[i] - cost[i];
            if(cur_oil < 0)
            {
                cur_oil = 0;
                start = i + 1;
            }
        }
        if(all_oil < 0) return -1;
        return start;
    }
};
```

### [135. 分发糖果](https://leetcode.cn/problems/candy/)

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candys(ratings.size() , 1);
        for(int i = 1 ; i < ratings.size() ;i++)
        {
            if(ratings[i] > ratings[i - 1]) candys[i] = candys[i - 1] + 1;
        }
        for(int i = ratings.size() - 1 ; i > 0 ;i--)
        {
            candys[i - 1] = ratings[i - 1] > ratings[i] ? max(candys[i] + 1,candys[i - 1]): candys[i - 1];
        }
        return accumulate(candys.begin(),candys.end(),0);
    }
};
```

### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0 , ten = 0;
        for(int x : bills)
        {
            if(x == 5) five++;
            else if(x == 10) 
            {
                ten++;
                if(five) five--;
                else return false;
            }
            else
            {
                if(ten && five)
                {
                    ten--;
                    five--;
                }
                else if(five >= 3) five -= 3;
                else return false;
            }
        }
        return true;
    }
};
```



### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。

那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），**让高个子在前面**。

**此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！**

那么只需要按照k为下标重新插入队列就可以了

```cpp
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),[&](const vector<int> &a,const vector<int> &b){
            if(a[0] != b[0]) return a[0] > b[0];
            else return a[1] < b[1];
        });
        vector<vector<int>> res;
        for(auto x:people)
        {
            res.insert(res.begin() + x[1],x);
        }
        return res;
    }
};
```

### [646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/)

```cpp

```



### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

```cpp


```

### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

```cpp

```

### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

这道题关键就是将找到各个字母最后出现的位置，判断当前max是不是在最后出现的位置内

```cpp

```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

```cpp

```

### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

```cpp

```

### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

```cpp

```

### [1221. 分割平衡字符串](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)

```cpp

```

### [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)

```cpp

```



### [665. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/)

```cpp

```

### [870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)（思路没问题测试不给过）

```cpp
class Solution {
public:
    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {
        map<int,int> umap;
        for (int i = 0; i < nums1.size(); ++i) umap[nums1[i]]++;
        vector<int>res;
        for (int i = 0; i < nums2.size(); ++i) {
            
            bool find = false;
            int a = -1;
            for (auto &x:umap) {
                if (x.first > nums2[i] && umap[x.first] > 0)
                {
                    find = true;
                    res.push_back(x.first);
                    x.second--;
                    if(x.second== 0)a = x.first;
                    break;
                }
            }
            if(a != -1) umap.erase(a);
            if (!find)
            {
                
                res.push_back(umap.begin()->first);
                if(--umap[umap.begin()->first] == 0) umap.erase(umap[umap.begin()->first]);
            }
        }
        return res;
    }
};
```


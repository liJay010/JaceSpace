# 2-双指针-滑动窗口

## 双指针

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while(fast < nums.size())
        {
            if(nums[fast] != val) nums[slow++] = nums[fast];
            fast++;
        }
        nums.resize(slow);
        return nums.size();
    }
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        int left = 1, right = 1;
        while(right < nums.size())
        {
            if(nums[right] != nums[right-1]) nums[left++] = nums[right];
            right++;
        }
        nums.resize(left);
        return nums.size();
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int fast = 0 ,slow = 0;
        for (; fast < nums.size(); ++fast) {
            if (0!=nums[fast]) nums[slow++] = nums[fast];
        }
        for (int i = slow; i < nums.size(); ++i) {
            nums[i] = 0;
        }
        }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```cpp
class Solution {
    void process(string &st)
    {
        int slow = 0;
        for (int i = 0; i < st.size(); ++i) {
            if ( st[i] != '#') st[slow++] = st[i];
            else
            {
                if (slow > 0) slow--;
            }
        }
        st.resize(slow);
    }
public:
    bool backspaceCompare(string s, string t) {
        process(s);
        process(t);
        return s == t;
    }
};
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int cur = 0;
        int mins = INT_MAX;
        for (int i = 0; i < nums.size(); ++i) {
            nums[i] = nums[i] * nums[i];
            if(nums[i] < mins)
            {
                mins = nums[i];
                cur = i;
            }
        }

        int left = cur - 1, right = cur + 1;
        vector<int> res;
        res.push_back(nums[cur]);
        while(left >= 0 && right < nums.size())
        {
            
            if(nums[left] < nums[right]) 
            {
                cur = left;
                left--;
            }
            else
            {
                cur = right;
                right++;
            }
            res.push_back(nums[cur]);
        }
        while(left >= 0) res.push_back(nums[left--]);
        while(right < nums.size()) res.push_back(nums[right++]);
        
        return res;
    }
};
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() < 2) return s.size();
        unordered_set<char> uset;
        int left = 0 , right = 0, max_len = 0;
        while(right < s.size())
        {
            if(uset.find(s[right]) == uset.end()) uset.insert(s[right]);
            else
            {
                while(s[right] != s[left])
                {
                    uset.erase(s[left++]);
                }
                left++;
            }
            max_len = max(max_len , int(uset.size()));
            right++;
        }
        return max_len;
    }
};
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0 , right = height.size() - 1 , max_v = 0;
        while(left < right)
        {
            max_v = max(max_v,(right - left) * min(height[left],height[right]));
            if(height[left] < height[right]) left++;
            else right--;
        }
        return max_v;
    }
};
```





## 滑动窗口

### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, right = 0 , maxsize = 0;
        while(right < nums.size())
        {
            if(nums[right] || k) nums[right++] != 0 ? : k--;
            else nums[left++]  ? : right++;
            maxsize = max(maxsize , right - left);
        }
        return maxsize;
    }
};
```



### [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

（与上一题类似）

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int left = 0 , right = 0,  k = 1 ,max_len = 0;
        while(right < nums.size())
        {
            if(nums[right] || k) nums[right++] ? : k--;
            else nums[left++] ? : right++;
            max_len = max(max_len , right - left - 1);
        }
        return max_len;
    }
};
```


# 2-双指针-滑动窗口

## 双指针

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

**题目难度： 简单                               用时： 3   分钟                                                标记：      完成** 

```cpp
//（双指针）
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast = 0,slow = 0;
        for (fast; fast < nums.size(); ++fast) {
            if (nums[fast] != val)
            {
                nums[slow++] = nums[fast];
            }
        }
        nums.resize(slow);
        return slow;
    }
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

**题目难度： 简单                               用时： 20   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() < 2) return nums.size();
        int fast = 1 ,slow = 1;
        for (fast; fast < nums.size(); ++fast) {
            if (nums[fast] == nums[fast-1]) continue;
            nums[slow++] = nums[fast];
        }
        return slow--;
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

**题目难度： 简单                               用时： 4   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int fast = 0 ,slow = 0;
        for (; fast < nums.size(); ++fast) {
            if (0!=nums[fast]) nums[slow++] = nums[fast];
        }
        for (int i = slow; i < nums.size(); ++i) {
            nums[i] = 0;
        }
        }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

**题目难度： 简单                               用时： 7   分钟                                                标记：      完成** 

```cpp
class Solution {
    void process(string &st)
    {
        int slow = 0;
        for (int i = 0; i < st.size(); ++i) {
            if ( st[i] != '#') st[slow++] = st[i];
            else
            {
                if (slow > 0) slow--;
            }
        }
        st.resize(slow);
    }
public:
    bool backspaceCompare(string s, string t) {
        process(s);
        process(t);
        return s == t;
    }
};
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

**题目难度： 简单                               用时： 1   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i) {
            nums[i] = nums[i] * nums[i];
        }
        std::sort(nums.begin(), nums.end());
        return nums;
    }
};
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

**题目难度： 中等                               用时： 15   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> umap;
        int slow = 0,count = 0,maxcount = 0;
        for (int i = 0; i < s.size(); ++i) {
            //找不到
            if (umap.find(s[i])==umap.end())
            {
                umap.insert(s[i]);
                count++;
                maxcount = max(count,maxcount);
            }
            //找到了
            else{
                while (s[slow]!=s[i])
                {
                    umap.erase(s[slow]);
                    slow++;
                }
                slow++;
                count = umap.size();

            }
        }
        return maxcount;
    }
};
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)（未完成）

一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。

**题目难度： 中等                               用时： 20   分钟                                                标记：      未完成** 

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res_max = 0 , right = height.size() - 1, left = 0;
        while (left < right)
        {
            res_max = max(res_max,(right - left) * min(height[left],height[right]));
            if(height[left] < height[right])left++;
            else right--;
        }
        return res_max;
    }
};
```

### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left=0 ,right = 0, res=0; 
        while(left < nums.size() && right < nums.size()) {
            if(nums[right] || k ) nums[right++]? : k--;
            else nums[left++]? : right++;
            res = max(res , right - left);
            }
        return res;
    }
};
```

### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

**题目难度：简单                     用时： 11分钟                      标记： 完成**

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1 = 0,p2 = 0;
        nums1.resize(m+n);
        vector<int> res;
        while (p1 < m && p2 < n)
        {
            if (nums1[p1] > nums2[p2]) res.push_back(nums2[p2++]);
            else res.push_back(nums1[p1++]);
        }
        while (p1 == m && p2 != n) res.push_back(nums2[p2++]);
        while (p1 != m && p2 == n) res.push_back(nums1[p1++]);
        nums1.assign(res.begin(),res.end());
    }
};
```



## 滑动窗口（双指针）

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

**题目难度： 中等                               用时：18   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int min_count = INT_MAX,fast = 0 ,slow = 0,sum = 0;
        for (; fast < nums.size(); ++fast) {
            sum+=nums[fast];
            while (sum >= target)
            {
                min_count = min(fast - slow + 1 , min_count);
                sum-=nums[slow++];
            }
        }
        if (min_count == INT_MAX) return 0;
        return min_count;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

**题目难度： 中等                               用时：35   分钟                                                标记：      未完成** 

```cpp
//904. 水果成篮
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
       int left =0,right = 0,ans = 0;
       int ln=fruits[left],rn=fruits[right]; //篮子一号和二号
       while(right < fruits.size())
       {
            if(fruits[right] == rn || fruits[right] == ln){//属于篮子某个种类
                ans = max(ans,right + 1 - left);  //更新结果，每次取一个数就更新一下
                right++;
            }else{//如果遇到第三种，把慢指针移动到快指针前一步，该步的水果种类必然不同于快指针，此时慢指针慢慢回退齐所有的连续同类。（秒啊）
                left = right - 1;  //取到第三种则移动左标到right -1
                ln = fruits[left]; //更新第一个篮子
                while(left >= 1 && fruits[left - 1] == ln) left--;
                rn = fruits[right];
                ans = max(ans,right + 1 - left);
            }
       }
        return ans;
    }
};
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

**题目难度： 中等                               用时：24   分钟                                                标记：      未完成** 

```cpp
//59. 螺旋矩阵 II

class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n,vector<int> (n,0)); //初始化数组
        res[0][0] = 1;//初始化第一个元素
        int count = 2;//记数
        int j = 0 ,i = 0;
        while (count<=n*n)
        {
            while (j < n -1 && res[i][j+1] == 0) res[i][++j] = count++;//→
            while (i < n -1 && res[i+1][j] == 0) res[++i][j] = count++;//↓
            while (j > 0 && res[i][j-1] == 0) res[i][--j] = count++;//←
            while (i > 0 && res[i-1][j] == 0) res[--i][j] = count++;//↑
        }

        return res;
    }
};


```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

**题目难度： 中等                               用时：14   分钟                                                标记：      完成** 

```cpp
//54. 螺旋矩阵（与上一题思路相似，生成矩阵判断是否走过）
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        int i = 0 , j = 0 ,count = 1;
        int size = matrix.size() * matrix[0].size();
        vector<vector<bool>> sym(matrix.size(),vector<bool>(matrix[0].size(), false));
        vector<int> res;
        res.push_back(matrix[0][0]);
        sym[0][0] = true;
        while (count < size)
        {
            while (j < matrix[0].size() -1 && !sym[i][j+1])
            {
                res.push_back(matrix[i][++j]);
                sym[i][j]=true;
                count++;
            }
            while (i < matrix.size() -1 && !sym[i+1][j])
            {
                res.push_back(matrix[++i][j]);
                sym[i][j]=true;
                count++;
            }
            while (j > 0 && !sym[i][j-1])
            {
                res.push_back(matrix[i][--j]);
                sym[i][j]=true;
                count++;
            }
            while (i>0 && !sym[i-1][j])
            {
                res.push_back(matrix[--i][j]);
                sym[i][j]=true;
                count++;
            }
        }

        return res;
    }
};
```

### [1365.有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        unordered_map<int,int>umap;
        vector<int> res(nums.begin(),nums.end());
        std::sort(nums.begin(), nums.end());
        for (int i = nums.size() -1 ; i >= 0; --i) {
            umap[nums[i]] = i;
        }
        for (int i = 0; i < res.size(); ++i) {
            res[i] = umap[res[i]];
        }
        return res;
    }
};
```

### [ 941.有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if (arr.size() < 3) return false;
        //从前往后
        int st = 1;
        while (st < arr.size() && arr[st] > arr[st-1])st++;
        //从后往前
        int ed = arr.size() - 2;
        while (ed >= 0 && arr[ed] > arr[ed+1])ed--;
        if (st == 1 || ed == arr.size() - 2) return false;//在原地
        if (st-1 == ed+1) return true;
        return false;
    }
};

```

### [1207.独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int,int> umap;
        for (int i = 0; i < arr.size(); ++i) {
            umap[arr[i]]+=1;
        }
        unordered_set<int> uset;
        for (auto x:umap) {
            if (uset.find(x.second)!=uset.end()) return false;
            uset.insert(x.second);
        }
        return true;
    }
};
```

### [ 189. 旋转数组](https://leetcode.cn/problems/rotate-array/)

**题目难度： 简单                     用时：                   5分钟                      标记： 完成**

```cpp
//有多余空间
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        vector<int> front(nums.end() - k ,nums.end());
        vector<int> back(nums.begin(),nums.end() - k);
        front.insert(front.end(),back.begin(),back.end());
        nums.assign(front.begin(),front.end());
    }
};
//方法二
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k =  k % nums.size();
        std::reverse(nums.begin(), nums.end());
        std::reverse(nums.begin(), nums.begin()+k);
        std::reverse(nums.begin()+k, nums.end());
    }
};
```

### [ 724.寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
//维护左右和
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int leftsum = 0,rightsum = accumulate(nums.begin(),nums.end(),0);
        for (int i = 0; i < nums.size(); ++i) {
            rightsum-=nums[i];
            if (leftsum == rightsum) return i;
            leftsum+=nums[i];
        }
        return -1;
    }
};
```

### [922. 按奇偶排序数组II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        //双指针
        for (int i = 0; i < nums.size(); ++i) {
            if (i % 2 != nums[i] % 2)
            {
                int r = nums.size() - 1;
                while (r >= 0 && i % 2 != nums[r] % 2) r--;
                swap(nums[i],nums[r]);
            }
        }
        return nums;
    }
};
```



### [524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)

**题目难度： 中等                     用时：                   15分钟                      标记： 完成**

```cpp
class Solution {
public:
    string findLongestWord(string s, vector<string>& dictionary) {
        int maxlen = 0 , index = -1;
        for (int i = 0; i < dictionary.size(); ++i) {
            int s_piont = 0 , d_point = 0;
            while (s_piont < s.size() && d_point < dictionary[i].size())
            {
                if (s[s_piont] == dictionary[i][d_point]) d_point++;
                s_piont++;
            }
            //遇到相等
            if (d_point == dictionary[i].size())
            {
                if (maxlen < dictionary[i].size())
                {
                    maxlen = dictionary[i].size();
                    index = i;
                }
                if (maxlen == dictionary[i].size() && dictionary[i] < dictionary[index])
                {
                    maxlen = dictionary[i].size();
                    index = i;
                }
            }
        }
        if (index == -1) return "";
        return dictionary[index];
    }
};
```

### [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

把重复出现的数字在 原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i) {
            int pose = abs(nums[i]) - 1;
            if (nums[pose] > 0) nums[pose] = -nums[pose];
        }
        vector<int> res;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0) res.push_back(i+1);
        }
        return res;
    }
};
```



### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

**题目难度： 中等                     用时：                   8分钟                      标记： 完成**

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        //上下翻转，再镜像对称
        for (int i = 0; i < matrix.size() / 2; ++i) {
            matrix[i].swap(matrix[matrix.size() - 1 - i]);
        }
        //镜像对称
        for (int i = 0; i < matrix.size() - 1; ++i) {
            for (int j = i + 1; j < matrix[0].size(); ++j) {
                swap(matrix[i][j],matrix[j][i]);
            }
        }
    }
};
```

### [769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/)（未完成）

从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次 分割。 为什么可以通过这个算法解决问题呢？如果当前最大值大于数组位置，则说明右边一定有小 于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到 n，所以 当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为 p，我们可以 成功完成一次分割，并且其与上一次分割位置 q 之间的值一定是 q + 1 到 p 的所有数字。

**题目难度： 中等                     用时：                   8分钟                      标记： 未完成**

```cpp
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int res = 0 ,maxs = INT_MIN;
        for (int i = 0; i < arr.size(); ++i) {
            maxs = max(maxs ,arr[i]);
            if (i == maxs) res++;
        }
        return res;
    }
};
```

### [566. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/)

**题目难度： 中等                     用时：                   8分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        if (r * c != mat.size() * mat[0].size()) return mat;
        vector<vector<int>> res(r,vector<int>(c));
        int col = 0 , raw = 0 , count = 0;
        for (int i = 0; i < mat.size(); ++i) {
            for (int j = 0; j < mat[0].size(); ++j) {
                count = i * mat[0].size() + j;
                raw = count / c;
                col = count % c;
                res[raw][col] = mat[i][j];
            }
        }
        return res;
    }
};
```


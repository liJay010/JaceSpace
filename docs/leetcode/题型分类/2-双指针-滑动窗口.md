# 2-双指针-滑动窗口

## 双指针

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0, fast = 0;
        while(fast < nums.size())
        {
            if(nums[fast] != val) nums[slow++] = nums[fast];
            fast++;
        }
        nums.resize(slow);
        return nums.size();
    }
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() < 2) return nums.size();
        int left = 1, right = 1;
        while(right < nums.size())
        {
            if(nums[right] != nums[right-1]) nums[left++] = nums[right];
            right++;
        }
        nums.resize(left);
        return nums.size();
    }
};
```

### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int fast = 0 ,slow = 0;
        for (; fast < nums.size(); ++fast) {
            if (0!=nums[fast]) nums[slow++] = nums[fast];
        }
        for (int i = slow; i < nums.size(); ++i) {
            nums[i] = 0;
        }
        }
};
```

### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```cpp
class Solution {
    void process(string &st)
    {
        int slow = 0;
        for (int i = 0; i < st.size(); ++i) {
            if ( st[i] != '#') st[slow++] = st[i];
            else
            {
                if (slow > 0) slow--;
            }
        }
        st.resize(slow);
    }
public:
    bool backspaceCompare(string s, string t) {
        process(s);
        process(t);
        return s == t;
    }
};
```

### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int cur = 0;
        int mins = INT_MAX;
        for (int i = 0; i < nums.size(); ++i) {
            nums[i] = nums[i] * nums[i];
            if(nums[i] < mins)
            {
                mins = nums[i];
                cur = i;
            }
        }

        int left = cur - 1, right = cur + 1;
        vector<int> res;
        res.push_back(nums[cur]);
        while(left >= 0 && right < nums.size())
        {
            
            if(nums[left] < nums[right]) 
            {
                cur = left;
                left--;
            }
            else
            {
                cur = right;
                right++;
            }
            res.push_back(nums[cur]);
        }
        while(left >= 0) res.push_back(nums[left--]);
        while(right < nums.size()) res.push_back(nums[right++]);
        
        return res;
    }
};
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() < 2) return s.size();
        unordered_set<char> uset;
        int left = 0 , right = 0, max_len = 0;
        while(right < s.size())
        {
            if(uset.find(s[right]) == uset.end()) uset.insert(s[right]);
            else
            {
                while(s[right] != s[left])
                {
                    uset.erase(s[left++]);
                }
                left++;
            }
            max_len = max(max_len , int(uset.size()));
            right++;
        }
        return max_len;
    }
};
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0 , right = height.size() - 1 , max_v = 0;
        while(left < right)
        {
            max_v = max(max_v,(right - left) * min(height[left],height[right]));
            if(height[left] < height[right]) left++;
            else right--;
        }
        return max_v;
    }
};
```

### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0,right = numbers.size() - 1;
        while(left < right)
        {
            if(numbers[left] + numbers[right] == target) break;
            else if(numbers[left] + numbers[right] > target) right--;
            else left++;
        }
        return {left + 1 ,right + 1};
    }
};
```

### [633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)

```cpp
class Solution {
public:
    bool judgeSquareSum(int c) {
        if(c < 3) return true;
        long left = 0, right = sqrt(c) + 1;
        while(left <= right)
        {
            if(c == left * left + right * right) return true;
            else if(c > left * left + right * right) left++;
            else right--;
        }
        return false;
    }
};
```



## 滑动窗口

### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0, right = 0 , maxsize = 0;
        while(right < nums.size())
        {
            if(nums[right] || k) nums[right++] != 0 ? : k--;
            else nums[left++]  ? : right++;
            maxsize = max(maxsize , right - left);
        }
        return maxsize;
    }
};
```



### [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

（与上一题类似）

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int left = 0 , right = 0,  k = 1 ,max_len = 0;
        while(right < nums.size())
        {
            if(nums[right] || k) nums[right++] ? : k--;
            else nums[left++] ? : right++;
            max_len = max(max_len , right - left - 1);
        }
        return max_len;
    }
};
```

### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(accumulate(nums.begin(),nums.end(),0) < target) return 0;
        int left = 0, right = 0, sums = 0 ,mins = nums.size();
        while(right < nums.size())
        {
            sums += nums[right];
            while(left <= right && sums >= target)
            {
                mins = min(mins , right - left + 1);
                sums -= nums[left++];
            }
            right++;
        }
        return mins;
    }
};
```

### [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
       int left =0,right = 0,ans = 0;
       int ln=fruits[left],rn=fruits[right]; //篮子一号和二号
       while(right < fruits.size())
       {
            if(fruits[right] == rn || fruits[right] == ln){//属于篮子某个种类
                ans = max(ans,right + 1 - left);  //更新结果，每次取一个数就更新一下
                right++;
            }else{//如果遇到第三种，把慢指针移动到快指针前一步，该步的水果种类必然不同于快指针，此时慢指针慢慢回退齐所有的连续同类。（秒啊）
                left = right - 1;  //取到第三种则移动左标到right -1
                ln = fruits[left]; //更新第一个篮子
                while(left >= 1 && fruits[left - 1] == ln) left--;
                rn = fruits[right];
                ans = max(ans,right + 1 - left);
            }
       }
        return ans;
    }
};
```


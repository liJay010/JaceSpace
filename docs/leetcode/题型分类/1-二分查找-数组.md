# 1-二分查找

### [ 704. 二分查找](https://leetcode.cn/problems/binary-search/)

**题目难度： 简单                               用时： 7   分钟                                                标记：      完成 **

我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid + 1 ;
        }
        return -1;
    }
};
```

### [35.搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

**题目难度： 简单                               用时： 5   分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0 , right = nums.size() -1;
        int mid = 0;
        while (left <= right)
        {
            mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid +1;
        }
        return left ;
    }
};

```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

**题目难度： 中等                               用时： 19   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        //使用两个二分查找
        int left1 = 0,left2 = 0, right1 = nums.size() - 1,right2 = nums.size() - 1;
        //先找you边的元素 left1 - 1
        bool find = false;
        while (left1 <= right1)
        {
            int mid = (left1 + right1) / 2;
            if(nums[mid] == target)  find = true;
            if (nums[mid] <= target) left1 = mid + 1;
            else right1 = mid - 1;
        }

        //先找左边的元素 right2 + 1
        while (left2 <= right2)
        {
            int mid = (left2 + right2) / 2;
            if (nums[mid] >= target) right2 = mid - 1;
            else left2 = mid + 1;
        }

        if(find == false) return {-1,-1};
        return {right2 + 1,left1 - 1};
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

**题目难度： 简单                               用时： 28   分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    int mySqrt(int x) {
        if (x <= 1) return x;
        long long left = 1 ,right = x, mid = 0;
        while (left <= right)
        {
            mid= (left + right) / 2;
            if (x / mid == mid) return mid;
            else if(x / mid > mid) left = mid + 1;
            else right = mid - 1;
        }
        return right;

    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

**题目难度： 简单                               用时： 3   分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        if(num < 2) return num;
        long long left = 0, right = num;
        long long mid;
        while (left <= right)
        {
            mid = (left + right) / 2;
            if (num == mid*mid) return true;
            else if (num  < mid * mid) right = mid - 1;
            else if (num  > mid * mid) left = mid + 1 ;
        }
        return false;
    }
};
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

**题目难度： 中等                               用时： 10   分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return mid;
            if(nums[mid] == nums[left]) left++;
            else if(nums[mid] <= nums[right])
            {
                if(nums[mid] < target && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
            else
            {
                if(nums[mid] > target && target >= nums[left]) right = mid - 1;
                else left = mid + 1;
            }
            
        }
        return -1;
    }
};
```



### [81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

**题目难度： 中等                               用时： 5  分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return true;
            if(nums[mid] == nums[left]) left++;
            else if(nums[mid] <= nums[right])
            {
                if(nums[mid] < target && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
            else
            {
                if(nums[mid] > target && target >= nums[left]) right = mid - 1;
                else left = mid + 1;
            }
            
        }
        return false;
    }
};
```

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)（未完成）

**题目难度： 中等                               用时： 15  分钟                                                标记：      未完成 **

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0,right = nums.size() - 1;
        int mins = nums[0];
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == nums[left]) left++;
            else if(nums[mid] <= nums[right]) right = mid - 1;
            else left = mid + 1;
            mins = min(mins,nums[mid]);
        }
        return mins;
    }
};

//解法2
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0 , right = nums.size() - 1;
        while (left < right)
        {
            int mid = (left + right) / 2;
            if (nums[right] >  nums[mid]) right = mid;
            else if(nums[right] <  nums[mid]) left = mid + 1;
            else  right--;
        }
        return nums[right];
    }
};
```

### [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

**题目难度： 中等                               用时： 15  分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int left = 0, right = nums.size() - 1, mid;
        while (left <= right)
        {
            mid = (left + right) / 2;
            //cout << mid <<endl;
            if(mid > 0 && nums[mid] == nums[mid - 1])
            {
                //右边为偶数
                if((nums.size() - 1 - mid) % 2 == 0) right = mid;
                //左边为偶数
                else left = mid + 1;
            }
            else if(mid < nums.size() - 1 && nums[mid] == nums[mid + 1])
            {
                //左边为偶数
                if(mid  % 2 == 0) left = mid;
                //右边为偶数
                else right = mid -1; 
            }
            else return nums[mid];
        }
        return nums[mid];
    }
};
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

这道题有一个简单的技巧：我们可以从右上角开始查找，若当前值大于待搜索值，我们向左 移动一位；若当前值小于待搜索值，我们向下移动一位。如果最终移动到左下角时仍不等于待搜 索值，则说明待搜索值不存在于矩阵中。

**题目难度： 中等                               用时： 5  分钟                                                标记：      完成 **

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int raw = 0 , col = matrix[0].size() - 1;
        while (raw < matrix.size() && col >= 0)
        {
            if (matrix[raw][col] == target) return true;
            else if(matrix[raw][col] < target) raw++;
            else col--;
        }
        return false;
    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        sort(potions.begin(),potions.end());
        vector<int> res;
        for(int spe:spells)
        {
            int left = 0, right = potions.size() - 1;
            //先判断是不是在中间的
            if((long)potions[left] *  spe >= success) res.push_back(potions.size());
            else if((long)potions[right] *  spe < success) res.push_back(0);
            else
            {
                while(left <= right)
                {
                    int mid = (left + right) / 2;
                    if((long)potions[mid] *  spe >= success && (long)potions[mid - 1] *  spe < success) 
                    {
                        res.push_back(potions.size() - mid);
                        break;
                    }
                    else if((long)potions[mid] *  spe < success) left = mid + 1;
                    else right = mid - 1;
                }
            }
        }
        return res;
    }
};
```



### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1])  right = mid;
            else left = mid + 1;
        }
            return left;
    }
};
```

### [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

**题目难度： 中等                     用时：                   20分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0 ,right = numbers.size() - 1;
        while (left < right)
        {
            if (target == numbers[right] + numbers[left]) return {left+ 1,right+1};
            else if (target > numbers[right] + numbers[left])
            {
                left++;
                continue;
            } else if (target < numbers[right] + numbers[left])
            {
                right--;
                continue;
            }
        }
        return {0,0};
    }
};
```

### [633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)

**题目难度： 中等                     用时：                   11分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool judgeSquareSum(int c) {
        if (c <= 2 || (int)sqrt(c) *  (int)sqrt(c)== c) return true;
        int left = 1,right = sqrt(c) ;
        while (left<= right)
        {
            long  res = (long )left*left + (long )right*right;
            cout << res << endl;
            if ((int)res == c) return true;
            else if (res > c) right--;
            else  left++;
        }
        return false;
    }
};
```


# 1-数组-二分查找

## 二分查找类

### [ 704. 二分查找](https://leetcode.cn/problems/binary-search/)

我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid + 1 ;
        }
        return -1;
    }
};
```

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的

- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```cpp
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0, right = nums.size();
          while (left <  right)
          {
              int mid = (left + right) / 2;
              if (nums[mid] == target) return mid;
              else if (nums[mid] > target) right = mid;
              else if (nums[mid] < target) left = mid + 1;
          }
          return -1;
      }
  };
  ```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0 , right = nums.size() -1;
        int mid = 0;
        while (left <= right)
        {
            mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid +1;
        }
        return left ;
    }
};
```



### [34. 在排序数组中查找元素的第一个和最后一个位置**](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0 , right = nums.size() - 1;
        //查找满足条件的最小数字 left <= target
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] >= target) right = mid - 1;
            else left = mid + 1;
        }
        int l = left;
        //查找满足条件的最大数字 right >= target
        left = 0 , right = nums.size() - 1;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] <= target) left = mid + 1;
            else right = mid - 1;
        }
        if(l > right) return {-1,-1};
        return {l,right};
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0 ,right = x;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if((long long) mid * mid == x) return mid;
            if((long long) mid * mid > x) right = mid - 1;
            else left = mid + 1;
        }
        return right;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0,right = num;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if((long long) mid * mid == num) return true;
            else if((long long) mid * mid < num) left = mid + 1;
            else right = mid - 1;
        }
        return false;
    }
};
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return mid;
            if(nums[left] == nums[mid]) left++;
            else if(nums[right] >= nums[mid])
            {
                if(target > nums[mid] && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
            else{
                if(target < nums[mid] && target >= nums[left]) right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
};
```

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if(nums[right] > nums[mid]) right = mid;
            else if(nums[right] < nums[mid])left = mid + 1;
            else right--;
        }
        return nums[right];
    }
};
```

### [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int left = 0, right = nums.size() - 1, mid;
        while (left <= right)
        {
            mid = (left + right) / 2;
            //cout << mid <<endl;
            if(mid > 0 && nums[mid] == nums[mid - 1])
            {
                //右边为偶数
                if((nums.size() - 1 - mid) % 2 == 0) right = mid;
                //左边为偶数
                else left = mid + 1;
            }
            else if(mid < nums.size() - 1 && nums[mid] == nums[mid + 1])
            {
                //左边为偶数
                if(mid  % 2 == 0) left = mid;
                //右边为偶数
                else right = mid -1; 
            }
            else return nums[mid];
        }
        return nums[mid];
    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        sort(potions.begin(),potions.end());
        vector<int> res;
        for(int x: spells)
        {
            if((long long) x * potions[0] > success )res.push_back(potions.size());
            else if((long long) x * potions.back() < success)res.push_back(0);
            else
            {
                int left = 0, right = potions.size() - 1;
                while(left <= right)
                {
                    int mid = (left + right) / 2;
                    if((long long) potions[mid] * x >= success) right = mid - 1;
                    else left = mid + 1;
                }

                res.push_back(potions.size() - left);
            }
        }
        return res;
    }
};
```

### [162. 寻找峰值*](https://leetcode.cn/problems/find-peak-element/)

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1])  right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

### [剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/)

```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int right = 0;
        for(int x:piles) right = max(right,x);
        int left = 1;
        while(left <= right)
        {
            int speed = (left + right) / 2;
            int count = 0;
            for(int x:piles) count += (x / speed) + ((x % speed) > 0);
            if(count <= h) right = speed - 1;
            else  left = speed + 1;
        }
        return left;
    }
};
```



## 数组-矩阵

### [941. 有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if(arr.size() < 3) return false;
        int cur = 1;
        while(cur < arr.size()&& arr[cur -1] < arr[cur]) cur++;
        if(cur == 1 || cur == arr.size()) return false;
        while(cur < arr.size()&& arr[cur -1] > arr[cur]) cur++;
        if(cur != arr.size()) return false;
        return true;
    }
};
```

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

```cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums.end() - k,nums.end());
        reverse(nums.begin(),nums.end() - k);
        reverse(nums.begin(),nums.end());
    }
};
```





### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int left = 0, right = accumulate(nums.begin(),nums.end(),0) , cur = 0;
        while(cur < nums.size())
        {
            right -= nums[cur];
            if(right == left) return cur;
            left += nums[cur];
            cur++;
        }
        return -1;
    }
};
```

### [922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        //双指针
        for (int i = 0; i < nums.size(); ++i) {
            if (i % 2 != nums[i] % 2)
            {
                int r = nums.size() - 1;
                while (r >= 0 && i % 2 != nums[r] % 2) r--;
                swap(nums[i],nums[r]);
            }
        }
        return nums;
    }
};
```

### [1365. 有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        unordered_map<int,int> umap;
        vector<int> res = nums;
        sort(res.begin(),res.end());
        for(int i = res.size() - 1; i >= 0;i--) umap[res[i]] = i;
        for(int i = 0;i < res.size() ;i++) res[i] = umap[nums[i]];
        return res;
    }
};
```

### [448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        for(int i = 0; i < nums.size() ;i++)
        {
            if(nums[i] > 0 && nums[nums[i] - 1] > 0)
            {
                nums[nums[i] - 1] = -nums[nums[i] - 1];
            }
            if(nums[i] < 0 && nums[-nums[i] - 1] > 0)
            {
                nums[-nums[i] - 1] = -nums[-nums[i] - 1];
            }
        }
        vector<int> res;
        for(int i = 0; i < nums.size() ;i++) if(nums[i] > 0) res.push_back(i + 1);
        return res;
    }
};
```

### [769. 最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted/)

```cpp
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int res = 0 ,mx = 0;
        for(int i = 0; i < arr.size() ;i++)
        {
            mx = max(mx , arr[i]);
            if(mx == i)res++;
        }
        return res;
    }
};
```



### [149. 直线上最多的点数](https://leetcode.cn/problems/max-points-on-a-line/)

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        if(points.size() < 3) return points.size();
        int maxpoint = 1;
        for(int i = 0; i < points.size() ;i++)
        {
            for(int j = i + 1;j < points.size() ;j++)
            {
                int x1 = points[i][0] , y1 = points[i][1] , x2 = points[j][0],y2= points[j][1];
                int sum = 2;
                for(int k = j + 1; k < points.size();k++)
                {
                    int x3 = points[k][0] , y3 = points[k][1];
                    if((x1 - x2) * (y1 - y3)  == (x1 - x3) *(y1 - y2) ) sum++;
                    maxpoint = max(maxpoint,sum);
                }
            }
        }
        return maxpoint;
    }
};
```



### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

这道题有一个简单的技巧：我们可以从右上角开始查找，若当前值大于待搜索值，我们向左 移动一位；若当前值小于待搜索值，我们向下移动一位。如果最终移动到左下角时仍不等于待搜 索值，则说明待搜索值不存在于矩阵中。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int raw = 0 , col = matrix[0].size() - 1;
        while (raw < matrix.size() && col >= 0)
        {
            if (matrix[raw][col] == target) return true;
            else if(matrix[raw][col] < target) raw++;
            else col--;
        }
        return false;
    }
};
```

### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n , vector<int>(n,0));
        int count = 2;
        res[0][0] = 1;
        int row = 0, col = 0;
        while(count <= n * n)
        {
            while(col < n - 1 && res[row][col + 1] == 0) res[row][++col] = count++;
            while(row < n - 1 && res[row + 1][col] == 0) res[++row][col] = count++;
            while(col > 0 && res[row][col - 1] == 0) res[row][--col] = count++;
            while(row > 0 && res[row - 1][col] == 0) res[--row][col] = count++;
        }
        return res;
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```cpp
//54. 螺旋矩阵（与上一题思路相似，生成矩阵判断是否走过）
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {

        int i = 0 , j = 0 ,count = 1;
        int size = matrix.size() * matrix[0].size();
        vector<vector<bool>> sym(matrix.size(),vector<bool>(matrix[0].size(), false));
        vector<int> res;
        res.push_back(matrix[0][0]);
        sym[0][0] = true;
        while (count < size)
        {
            while (j < matrix[0].size() -1 && !sym[i][j+1])
            {
                res.push_back(matrix[i][++j]);
                sym[i][j]=true;
                count++;
            }
            while (i < matrix.size() -1 && !sym[i+1][j])
            {
                res.push_back(matrix[++i][j]);
                sym[i][j]=true;
                count++;
            }
            while (j > 0 && !sym[i][j-1])
            {
                res.push_back(matrix[i][--j]);
                sym[i][j]=true;
                count++;
            }
            while (i>0 && !sym[i-1][j])
            {
                res.push_back(matrix[--i][j]);
                sym[i][j]=true;
                count++;
            }
        }

        return res;
    }
};
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

```cpp
class Solution {
public:+-
    void rotate(vector<vector<int>>& matrix) {
        //先上下，后对称
        for( int i = 0 ; i < matrix.size() / 2;i++)
            swap(matrix[i],matrix[matrix.size() - i - 1]);
        for(int i = 0; i < matrix.size(); i++)
            for(int j = i + 1; j < matrix[0].size(); j++)
                swap(matrix[i][j],matrix[j][i]);
    }
};
```

### [566. 重塑矩阵](https://leetcode.cn/problems/reshape-the-matrix/)

```cpp
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        if (r * c != mat.size() * mat[0].size()) return mat;
        vector<vector<int>> res(r,vector<int>(c));
        int col = 0 , raw = 0 , count = 0;
        for (int i = 0; i < mat.size(); ++i) {
            for (int j = 0; j < mat[0].size(); ++j) {
                count = i * mat[0].size() + j;
                raw = count / c;
                col = count % c;
                res[raw][col] = mat[i][j];
            }
        }
        return res;
    }
};
```



## 字符串

### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0 ; i < s.size() ;i += k *2 )
        {
            if(i + k <= s.size()) reverse(s.begin() + i,s.begin() + i + k);
            else reverse(s.begin() + i,s.end());
        }
        return s;
    }
};
```

### [剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        string res;
        for(char x:s)
        {
            if(x == ' ') 
            {
                res.push_back('%');
                res.push_back('2');
                res.push_back('0');
            }
            else res.push_back(x);
        }
        return res;
    }
};
```

### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

```cpp
class Solution {
public:
    string reverseWords(string s) {

        /*
         *
         * 1.移除字符串多余空格
         * 2.翻转单词
         * 3.翻转字符串
         */

        //1.移除字符串多余空格 双指针
                int slow =0, fast=0;
        s.push_back(' ');
        while (s[fast] == ' ')fast++;
        while (fast < s.size()-1)
        {
            if (s[fast] == ' ' && s[fast+1] == ' ') fast++;
            else s[slow++] = s[fast++];

        }
        s.resize(slow);

        //2.翻转单词
        int last = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (i == s.size() - 1) std::reverse(s.begin()+last, s.end());
            else if(s[i] == ' ')
            {
                std::reverse(s.begin()+last, s.begin()+i);
                last = i+1;
            }
        }

        //3.翻转字符串
        std::reverse(s.begin(), s.end());
        return s;
    }
};
```

### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string ss = s.substr(1) + s;
        ss.pop_back();
        int fid = ss.find(s);
        return fid != -1;
    }
};
```

### [925.长按键入](https://leetcode.cn/problems/long-pressed-name/)

```cpp
 class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        if(name.size() > typed.size()) return false;
        int l1 = 0 , l2 = 0;
        while(l1 < name.size())
        {
            //计算cur数量
            int l1_count = 0;
            char cur1 = name[l1];
            while(l1 < name.size() && cur1 == name[l1]) 
            {
                l1_count++;
                l1++;
            }
            if(l2 >= typed.size()) return false;
            int l2_count = 0;
            char cur2 = typed[l2];
            while(l2 < typed.size() && cur2 == typed[l2]) 
            {
                l2_count++;
                l2++;
            }
            if(cur1 != cur2 || l1_count > l2_count)return false;
        }

        return l2 == typed.size();
    }
};
```



### [680. 验证回文串 II](https://leetcode.cn/problems/valid-palindrome-ii/)

```cpp
class Solution {
public:
    bool validPalindrome(string s) {
        int left = 0 ,right = s.size() - 1;
        int count = 0;
        //left 匹配
        while (left < right)
        {
            if (s[left] == s[right])
            {
                left++;
                right--;
            } else
            {
                left++;
                count++;
            }
        }
        //right 匹配
        if (count <= 1) return true;

        left = 0 ,right = s.size() - 1;
        count = 0;
        //left 匹配
        while (left < right)
        {
            if (s[left] == s[right])
            {
                left++;
                right--;
            } else
            {
                right--;
                count++;
            }
        }
        return count <= 1;
    }
};
```

### [696. 计数二进制子串*](https://leetcode.cn/problems/count-binary-substrings/)

```cpp
class Solution {
public:
    int countBinarySubstrings(string s) {
        int count = 0 ,pre = 0 , cur = 1;
        for(int i = 1; i < s.size();i++)
        {
            if(s[i] == s[i - 1]) cur++;
            else
            {
                pre = cur;
                cur = 1;
            }
            if(pre >= cur) count++;
        }
        return count;
    }
};
```

### [409. 最长回文串](https://leetcode.cn/problems/longest-palindrome/)

```cpp
class Solution {
public:
    int longestPalindrome(string s) {
        unordered_map<char,int> umap;
        for(char x:s) umap[x]++;
        bool ch = false;
        int count = 0;
        for(auto x:umap)
        {
            if(!ch && x.second % 2 == 1) 
            {
                count += x.second;
                ch = true;
            }
            else if(ch && x.second % 2 == 1) count += x.second - 1;
            else count += x.second;
        }
        return count;
    }
};
```

### [7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

```cpp
class Solution {
public:
    int reverse(int x) {
        bool fu = x < 0;
        unsigned int res = 0;
        x = abs(x);
        if(to_string(x).size() >= 10 && x % 10 > 2) return 0;
        while(x)
        {
            res *= 10;
            res += x % 10;
            x /= 10;
        }
        res = fu ? -res:res;

        if(!fu && res > 2147483647) return 0;
        if(fu && -res > 2147483648) return 0;
        return res;
    }
};
```



### [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

```cpp
class Solution {
public:
    int calculate(string s) {
        vector<int> nums;
        vector<char> ops;
        ops.push_back('+');
        int cur = 0;
        while(cur < s.size())
        {
            //加减号直接入栈
            if(s[cur] == '+' || s[cur] == '-') ops.push_back(s[cur++]);
            //乘除号
            else if(s[cur] == '*' || s[cur] == '/')
            {
                char op = s[cur++];
                while(s[cur] == ' ') cur++;
                string nu;
                while(s[cur] >= '0' && s[cur] <= '9') nu.push_back(s[cur++]);
                int num1 = nums.back();
                nums.pop_back();
                if(op == '*')nums.push_back(num1 * stoi(nu));
                if(op == '/')nums.push_back(num1 / stoi(nu));
            }
            else if(s[cur] >= '0' && s[cur] <= '9')
            {
                string nu(1,s[cur++]);
                while(cur < s.size() && s[cur] >= '0' && s[cur] <= '9') nu.push_back(s[cur++]);
                nums.push_back(stoi(nu));
            }
            else cur++;
        }
        int res = 0;
        for(int i = 0;i < nums.size() ;i++)
        {
            //cout << ops[i] << nums[i] <<endl;
            nums[i] = ops[i] == '+'? nums[i] : -nums[i];
            res += nums[i];
        }
        return res;
    }
};
```

### [224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

```cpp
class Solution {
public:
    int calculate(string s) {
        vector<int> nums;
        vector<char> chs;
        int cur = 0;
        while(cur < s.size())
        {
            //是符号，则要找到其后面的数字
            if(s[cur] == '+' || s[cur] == '-' || s[cur] == '(') chs.push_back(s[cur++]);

            else if(s[cur] == ')')
            {
                int res = 0;
                while(chs.size() && chs.back() != '(')
                {
                    res += nums.back();
                    nums.pop_back();
                    chs.pop_back();
                }
                chs.pop_back();

                if(chs.size() == 0 || chs.back() == '(') chs.push_back('+');
                if(chs.back() == '-') nums.push_back(-res);
                else nums.push_back(res);
                cur++;
            }
            else if(s[cur] >= '0' && s[cur] <= '9')
            {
                if(chs.size() == 0 || chs.back() == '(') chs.push_back('+');
                string nu(1,s[cur++]);
                while(cur < s.size() && s[cur] >= '0' && s[cur] <= '9') nu.push_back(s[cur++]);
                if(chs.back() == '+') nums.push_back(stoi(nu));
                if(chs.back() == '-') nums.push_back(-stoi(nu));
            }
            else cur++;
        }
        int res = 0;
        for(int x : nums) res += x;
        return res;
    }
};
```


# 1-数组-二分查找

## 二分查找类

### [ 704. 二分查找](https://leetcode.cn/problems/binary-search/)

我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid + 1 ;
        }
        return -1;
    }
};
```

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的

- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```cpp
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0, right = nums.size();
          while (left <  right)
          {
              int mid = (left + right) / 2;
              if (nums[mid] == target) return mid;
              else if (nums[mid] > target) right = mid;
              else if (nums[mid] < target) left = mid + 1;
          }
          return -1;
      }
  };
  ```

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0 , right = nums.size() -1;
        int mid = 0;
        while (left <= right)
        {
            mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid -1;
            else if (nums[mid] < target) left = mid +1;
        }
        return left ;
    }
};
```



### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0 , right = nums.size() - 1;
        //查找满足条件的最小数字 left <= target
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] >= target) right = mid - 1;
            else left = mid + 1;
        }
        int l = left;
        //查找满足条件的最大数字 right >= target
        left = 0 , right = nums.size() - 1;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] <= target) left = mid + 1;
            else right = mid - 1;
        }
        if(l > right) return {-1,-1};
        return {l,right};
    }
};
```

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0 ,right = x;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if((long long) mid * mid == x) return mid;
            if((long long) mid * mid > x) right = mid - 1;
            else left = mid + 1;
        }
        return right;
    }
};
```

### [367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```cpp
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0,right = num;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if((long long) mid * mid == num) return true;
            else if((long long) mid * mid < num) left = mid + 1;
            else right = mid - 1;
        }
        return false;
    }
};
```

### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return mid;
            if(nums[left] == nums[mid]) left++;
            else if(nums[right] >= nums[mid])
            {
                if(target > nums[mid] && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
            else{
                if(target < nums[mid] && target >= nums[left]) right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
};
```

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if(nums[right] > nums[mid]) right = mid;
            else if(nums[right] < nums[mid])left = mid + 1;
            else right--;
        }
        return nums[right];
    }
};
```

### [540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int left = 0, right = nums.size() - 1, mid;
        while (left <= right)
        {
            mid = (left + right) / 2;
            //cout << mid <<endl;
            if(mid > 0 && nums[mid] == nums[mid - 1])
            {
                //右边为偶数
                if((nums.size() - 1 - mid) % 2 == 0) right = mid;
                //左边为偶数
                else left = mid + 1;
            }
            else if(mid < nums.size() - 1 && nums[mid] == nums[mid + 1])
            {
                //左边为偶数
                if(mid  % 2 == 0) left = mid;
                //右边为偶数
                else right = mid -1; 
            }
            else return nums[mid];
        }
        return nums[mid];
    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        sort(potions.begin(),potions.end());
        vector<int> res;
        for(int x: spells)
        {
            if((long long) x * potions[0] > success )res.push_back(potions.size());
            else if((long long) x * potions.back() < success)res.push_back(0);
            else
            {
                int left = 0, right = potions.size() - 1;
                while(left <= right)
                {
                    int mid = (left + right) / 2;
                    if((long long) potions[mid] * x >= success) right = mid - 1;
                    else left = mid + 1;
                }

                res.push_back(potions.size() - left);
            }
        }
        return res;
    }
};
```

### [162. 寻找峰值*](https://leetcode.cn/problems/find-peak-element/)

```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[mid + 1])  right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```

### [剑指 Offer II 073. 狒狒吃香蕉](https://leetcode.cn/problems/nZZqjQ/)

```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int right = 0;
        for(int x:piles) right = max(right,x);
        int left = 1;
        while(left <= right)
        {
            int speed = (left + right) / 2;
            int count = 0;
            for(int x:piles) count += (x / speed) + ((x % speed) > 0);
            if(count <= h) right = speed - 1;
            else  left = speed + 1;
        }
        return left;
    }
};
```



## 数组-矩阵

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

这道题有一个简单的技巧：我们可以从右上角开始查找，若当前值大于待搜索值，我们向左 移动一位；若当前值小于待搜索值，我们向下移动一位。如果最终移动到左下角时仍不等于待搜 索值，则说明待搜索值不存在于矩阵中。

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int raw = 0 , col = matrix[0].size() - 1;
        while (raw < matrix.size() && col >= 0)
        {
            if (matrix[raw][col] == target) return true;
            else if(matrix[raw][col] < target) raw++;
            else col--;
        }
        return false;
    }
};
```



## 字符串

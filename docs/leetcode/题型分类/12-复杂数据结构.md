# 12-复杂数据结构

## 1.积分图前缀和

### [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```cpp
class NumArray {
    vector<int> num;
public:
    NumArray(vector<int>& nums):num(nums) {
        partial_sum(num.begin(),num.end(),num.begin());
    }
    
    int sumRange(int left, int right) {
        return left > 0 ? num[right] - num[left - 1] : num[right];
    }
};

```

### [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```cpp
class NumMatrix {
    vector<vector<int>> res;
public:
    NumMatrix(vector<vector<int>>& matrix) :res(matrix.size() + 1, vector<int>(matrix[0].size() + 1,0)){
        for(int i = 1; i < res.size();i++)
        {
            for(int j = 1; j < res[0].size();j++)
            {
                res[i][j] = res[i - 1][j] + res[i][j - 1] + matrix[i - 1][j - 1] - res[i - 1][j - 1];
            }
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return res[row2 + 1][col2 + 1] - res[row1][col2 + 1] -res[row2 + 1][col1] + res[row1][col1];
    }
};
```

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> umap;
        partial_sum(nums.begin(),nums.end(),nums.begin());
        umap[0] = 1;
        int res = 0;
        for(int i = 0;i < nums.size();i++)
        {
            res += umap[nums[i] - k];
            umap[nums[i]]++;
        }
        return res;
    }
};
```



## 2.前缀树

### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```cpp
class Trie {
        vector<Trie*> next;
        char ch;
        bool is_end;
public:
    Trie() :is_end(false){
        next.resize(26);
    }
    
    void insert(string word) {
        Trie* cur = this;
        for(char x:word)
        {
            if(!cur->next[x - 'a'])cur->next[x - 'a'] = new Trie();
            cur = cur->next[x - 'a'];
            cur->ch = x;
        }
        cur->is_end = true;
    }
    
    bool search(string word) {
        Trie* cur = this;
        for(char x:word)
        {
            if(!cur->next[x - 'a']) return false;
            cur = cur->next[x - 'a'];
        }
        return cur->is_end;
    }
    
    bool startsWith(string prefix) {
        Trie* cur = this;
        for(char x:prefix)
        {
            if(!cur->next[x - 'a']) return false;
            cur = cur->next[x - 'a'];
        }
        return true;
    }
};

```



## 3.其余数据结构

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

我们采用一个链表 list来储存信息的 key 和 value，链表的链接顺序即为最 近使用的新旧顺序，最新的信息在链表头节点。同时我们需要一个嵌套着链表的迭代器的 unordered_map 进行快速搜索，存迭代器的原因是方便调用链表的 splice 函数来直接更新查找成功（cash hit）时的信息，即把迭代器对应的节点移动为链表的头节 点。

list::splice实现list拼接的功能。将源list的内容部分或全部元素删除，拼插入到目的list。

函数有以下三种声明：

```cpp
void list::splice( iterator pos, list rhs );
void list::splice( iterator pos, list rhs, iterator ix ); 
void list::splice( iterator pos, list rhs, iterator first, iterator last );
```

splice()把一个或一级元素从一个 list 移到另一个中去 它有三种形式

1、从positon开始，把一个 list  rhs的全部元素搬移到另一个中去 pos开始

2、从positon开始，把一个 ix 元素搬移到 rhs 的 pos位置

3、从positon开始，把first 到 last 剪接到要操作的list对象中的pos位置

```cpp
class LRUCache {
    int capacitys;
    list<pair<int,int>> lists;
    unordered_map<int,list<pair<int, int>>::iterator> umap;
public:
    LRUCache(int capacity): capacitys(capacity){

    }
    
    int get(int key) {
        if(umap.find(key) == umap.end()) return -1;
        else
        {
            lists.splice(lists.begin(), lists, umap[key]);
            return umap[key]->second;
        }
    }
    
    void put(int key, int value) {
        if(umap.find(key) != umap.end()) 
        {
            umap[key]->second  = value;
            lists.splice(lists.begin(), lists, umap[key]);
            return;
        }
        if(capacitys == umap.size())
        {
            pair<int,int> pir = lists.back();
            lists.pop_back();
            umap.erase(pir.first);
        }
        lists.push_front(pair<int,int>(key,value));
        umap[key] = lists.begin();
    }
};
```


# 23.常用代码

## 0.C++万能库

```cpp
#include<bits/stdc++.h>
```



## 1.排序类

### 快排

```cpp
void QuichSort(vector<int> &arr,int start,int end) //快排需要传入 开始 结束
{
    if(end <= start) return; //结束条件为开始大于等于结束
    int left = start,right = end,cur = arr[start]; //定义left，right以及cur（左边第一个值）
    while(left < right) //循环遍历
    {
        while(left < right && arr[right] >= cur) right--; //找到右边比cur小的数
        arr[left] = arr[right]; //将其交换到左边
        while(left < right && arr[left] <= cur) left++;//找到左边比cur大的数
        arr[right] = arr[left];//将其交换到右边
    }
    arr[left] = cur;//将cur 放到中间，保证cur左边小于，右边大于
    QuichSort(arr,0,left); //递归遍历左边
    QuichSort(arr,left + 1,end); //递归遍历右边
}
```

### 归并

```cpp
void Sort(vector<int> &arr) //快排需要传入 开始 结束
{
    vector<int> temp = arr;
    function<void(int,int)> MySort = [&](int left, int right){
        if(left >= right) return;
        //先拆分
        int mid = (left + right) / 2;
        MySort(left,mid);
        MySort(mid + 1,right);
        //后排序，此时arr在（left,mid）,(mid,right)是有序的，需要合并至temp
        int start = left, end = mid + 1,cnt = start; //注意这里，开始的合并的初始化
        for(int i = left; i <= right;i++) temp[i] = arr[i]; //先进行拷贝
        //进行合并
        while(start <= mid && end <= right)
        {
            if(temp[start] > temp[end]) arr[cnt++] = temp[end++];
            else arr[cnt++] = temp[start++];
        }
        while(start <= mid) arr[cnt++] = temp[start++];
        while(end <= right) arr[cnt++] = temp[end++];

    };
    MySort(0,arr.size() - 1);
}
```



## 2.其余类

### 二叉数的迭代遍历

```cpp
//前序遍历 -> 中 左 右
vector<int> preorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> res;
        stack<TreeNode* > st; //使用栈
        st.push(root);
        while(!st.empty())
        {
            TreeNode* top = st.top();
            st.pop();
            res.push_back(top->val); //中
            if(top->right) st.push(top->right); //右 -> 右边节点先入栈，后出
            if(top->left) st.push(top->left); //左-> 右边节点后入栈，先出
        }
        return res;
}

//中序遍历
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        while(!st.empty() || root)
        {
            if(root)
            {
                st.push(root);
                root = root->left;
            }
            else
            {
                TreeNode* top = st.top();
                st.pop();
                res.push_back(top->val);
                root = top->right;
            }   
        }
        return res;
    }


//后序遍历 -> 左 右 中（可以由前序遍历改 中右左）反序得到
vector<int> postorderTraversal(TreeNode* root) {
        if(!root) return {};
        vector<int> res;
        stack<TreeNode* > st; //使用栈
        st.push(root);
        while(!st.empty())
        {
            TreeNode* top = st.top();
            st.pop();
            res.push_back(top->val); //中
            if(top->left) st.push(top->left); //左-> 右边节点后入栈，先出
            if(top->right) st.push(top->right); //右 -> 右边节点先入栈，后出
        }
        reverse(res.begin(),res.end());
        return res;
    }
```



### 智能指针sheard_ptr

```cpp
#include <iostream>
#include <mutex>

template <typename T>
class SharedPtr {
private:
    T* data;
    size_t* count;
    std::mutex mtx;  // 添加互斥锁

public:
    // 构造函数
    SharedPtr(T* ptr = nullptr) : data(ptr), count(new size_t(1)) {}

    // 拷贝构造函数
    SharedPtr(const SharedPtr& other) : data(other.data), count(other.count) {
        std::lock_guard<std::mutex> lock(mtx);  // 加锁
        (*count)++;
    }

    // 赋值运算符重载
    SharedPtr& operator=(const SharedPtr& other) {
        if (this != &other) {
            // 减少旧对象的引用计数
            release();

            // 复制新对象的数据
            std::lock_guard<std::mutex> lock(mtx);  // 加锁
            data = other.data;
            count = other.count;

            // 增加新对象的引用计数
            (*count)++;
        }
        return *this;
    }

    // 析构函数
    ~SharedPtr() {
        release();
    }

    // 解引用运算符重载
    T& operator*() const {
        return *data;
    }

    // 成员访问运算符重载
    T* operator->() const {
        return data;
    }

private:
    // 释放资源的辅助函数
    void release() {
        if (count != nullptr) {
            std::lock_guard<std::mutex> lock(mtx);  // 加锁
            (*count)--;
            if (*count == 0) {
                delete data;
                delete count;
            }
        }
    }
};

int main() {
    SharedPtr<int> ptr1(new int(42));
    SharedPtr<int> ptr2 = ptr1;

    std::cout << "ptr1: " << *ptr1 << std::endl;
    std::cout << "ptr2: " << *ptr2 << std::endl;

    return 0;
}

```

### 线程池

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>

class ThreadPool {
public:
    ThreadPool(size_t numThreads) : stop(false) {
        for (size_t i = 0; i < numThreads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;

                    {
                        std::unique_lock<std::mutex> lock(queueMutex);

                        condition.wait(lock, [this] { return stop || !tasks.empty(); });

                        if (stop && tasks.empty()) {
                            return;
                        }

                        task = std::move(tasks.front());
                        tasks.pop();
                    }

                    task();
                }
            });
        }
    }

    template<class F>
    void enqueue(F&& func) {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            tasks.emplace(std::forward<F>(func));
        }
        condition.notify_one();
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            stop = true;
        }

        condition.notify_all();

        for (std::thread &worker : workers) {
            worker.join();
        }
    }

private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;

    std::mutex queueMutex;
    std::condition_variable condition;

    bool stop;
};

int main() {
    ThreadPool threadPool(4);

    for (int i = 0; i < 8; ++i) {
        threadPool.enqueue([i] {
            std::cout << "Task " << i << " processed by thread " << std::this_thread::get_id() << std::endl;
        });
    }

    // Give some time for tasks to be processed
    std::this_thread::sleep_for(std::chrono::seconds(2));

    return 0;
}

```

### 哈希表

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <algorithm>

// HashNode表示哈希表中的一个节点
template <typename K, typename V>
struct HashNode {
    K key;
    V value;
};

// HashMap表示哈希表
template <typename K, typename V, typename Hash = std::hash<K>>
class HashMap {
private:
    std::vector<std::list<HashNode<K, V>>> buckets;
    Hash hashFunction;

public:
    HashMap(size_t size = 10) : buckets(size) {}

    // 插入键值对
    void insert(const K& key, const V& value) {
        size_t index = hashFunction(key) % buckets.size();
        auto& bucket = buckets[index];

        // 检查是否已经存在相同的键，如果是，更新值
        auto it = std::find_if(bucket.begin(), bucket.end(), [&key](const HashNode<K, V>& node) {
            return node.key == key;
        });

        if (it != bucket.end()) {
            it->value = value;
        } else {
            // 否则，在链表头部插入新节点
            bucket.push_front({key, value});
        }
    }

    // 查找键对应的值
    bool find(const K& key, V& value) const {
        size_t index = hashFunction(key) % buckets.size();
        const auto& bucket = buckets[index];

        // 在链表中查找键
        auto it = std::find_if(bucket.begin(), bucket.end(), [&key](const HashNode<K, V>& node) {
            return node.key == key;
        });

        // 如果找到了，返回对应的值
        if (it != bucket.end()) {
            value = it->value;
            return true;
        }

        return false; // 没找到
    }

    // 移除键值对
    void remove(const K& key) {
        size_t index = hashFunction(key) % buckets.size();
        auto& bucket = buckets[index];

        // 移除链表中的节点
        bucket.remove_if([&key](const HashNode<K, V>& node) {
            return node.key == key;
        });
    }
};

int main() {
    HashMap<std::string, int> myMap;

    myMap.insert("one", 1);
    myMap.insert("two", 2);
    myMap.insert("three", 3);

    int value;

    if (myMap.find("two", value)) {
        std::cout << "Value for key 'two': " << value << std::endl;
    } else {
        std::cout << "Key 'two' not found." << std::endl;
    }

    myMap.remove("two");

    if (myMap.find("two", value)) {
        std::cout << "Value for key 'two': " << value << std::endl;
    } else {
        std::cout << "Key 'two' not found." << std::endl;
    }

    return 0;
}

```

### 线程同步问题-3线程交替打印 1 - 100

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

const int target = 100;

std::mutex mtx;
std::condition_variable cv;
int currentNumber = 1;

void printNumber(int threadId, int mod) {
    while (currentNumber <= target) {
        std::unique_lock<std::mutex> lock(mtx);

        // 等待轮到当前线程打印
        cv.wait(lock, [threadId] { return (currentNumber % 3) == threadId; });

        // 打印当前数字
        std::cout << "Thread " << threadId + 1 << ": " << currentNumber << std::endl;

        // 更新数字并通知下一个线程
        currentNumber++;
        cv.notify_all();
    }
}

int main() {
    std::thread t1(printNumber, 0, 3);
    std::thread t2(printNumber, 1, 3);
    std::thread t3(printNumber, 2, 3);

    t1.join();
    t2.join();
    t3.join();

    return 0;
}

```

### 实现可能含交集的memcpy（memmove）

```cpp
#include <iostream>

void* my_memmove(void* dest, const void* src, size_t count) {
    if (dest == nullptr || src == nullptr) {
        return nullptr;
    }

    char* destChar = static_cast<char*>(dest);
    const char* srcChar = static_cast<const char*>(src);

    // 如果 dest 在 src 的左侧（重叠部分），则从后往前复制
    if (destChar < srcChar && destChar + count > srcChar) {
        for (size_t i = count - 1; i != SIZE_MAX; --i) {
            destChar[i] = srcChar[i];
        }
    } else {
        // 否则，从前往后复制
        for (size_t i = 0; i < count; ++i) {
            destChar[i] = srcChar[i];
        }
    }

    return dest;
}

int main() {
    char buffer[20] = "Hello, World!";
    
    // 将 "World!" 移动到 buffer 的开头
    my_memmove(buffer, buffer + 7, 6);

    std::cout << "Buffer: " << buffer << std::endl;

    return 0;
}

```

### 单例模式

#### 饿汉

```cpp
class Chairman
{
public:
    void print()
    {
        cout << "对象调用" << endl;
    }
private:
    Chairman()  //私有构造函数
    {
        cout << "创建chairman类" << endl;
    }
 
public:
    static Chairman* singleman;  //类内声明chairman对象指针
};
 
Chairman* Chairman::singleman = new Chairman;  //类外进行初始化
 
int main()
{
    cout << "main函数开始执行" << endl;
    Chairman::singleman->print();
 
    system("pause");
    return 0;
}
```

#### 懒汉

```cpp
class Chairman
{
public:
    void print()
    {
        cout << "对象调用" << endl;
    }
private:
    Chairman()  //私有构造函数
    {
        cout << "创建chairman类" << endl;
    }
 
public:
    static Chairman* singleman;  //类内声明chairman对象指针
};
 
Chairman* Chairman::singleman = new Chairman;  //类外进行初始化
 
int main()
{
    cout << "main函数开始执行" << endl;
    Chairman::singleman->print();
 
    system("pause");
    return 0;
}
```

```cpp
///  内部静态变量的懒汉实现  //
class Singleton
{
public:
    ~Singleton(){
        std::cout<<"destructor called!"<<std::endl;
    }
    //或者放到private中
    Singleton(const Singleton&)=delete;
    Singleton& operator=(const Singleton&)=delete;
    static Singleton& get_instance(){
        //关键点！
        static Singleton instance;
        return instance;
    }
    //不推荐，返回指针的方式
    /*static Singleton* get_instance(){
        static Singleton instance;
        return &instance;
    }*/
private:
    Singleton(){
        std::cout<<"constructor called!"<<std::endl;
    }
};
```


# 11-图与搜索

## 图





## 深度优先搜索

### [79. 单词搜索](https://leetcode.cn/problems/word-search/)

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<bool>> visited(board.size(),vector<bool>(board[0].size(),false));
        
        function<bool(int ,int ,int)> dfs = [&](int i , int j ,int count){
            if(count == word.size()) return true;
            if(i < 0 || i >= board.size() ||j < 0 || j >= board[0].size() || visited[i][j] || word[count] != board[i][j]) return false;
            visited[i][j] = true;
            bool u = dfs(i - 1, j ,count + 1);
            bool d = dfs(i + 1, j ,count + 1);
            bool l = dfs(i, j - 1,count + 1);
            bool r = dfs(i, j + 1,count + 1);
            visited[i][j] = false;
            return u || d || l || r;
        };

        for(int i = 0 ; i < board.size();i++)
        {
            for(int j = 0 ; j < board[0].size();j++)
            {
                if(dfs(i,j,0)) return true;
            }
        }
        return false;
    }
};
```

### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

```cpp
class Solution {
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<bool>visit(rooms.size(),false);
        function<void (int)> dfs = [&](int i)
        {
            if(i > rooms.size() || visit[i]) return;
            visit[i] = true;
            for( int j = 0 ; j < rooms[i].size(); j++)
            {
                dfs(rooms[i][j]);
            }
        };
        dfs(0);
        return accumulate(visit.begin(),visit.end(),0) == visit.size();
    }
};
```

### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        vector<vector<bool>> choose(grid.size(),vector<bool>(grid[0].size(),false));
        int res = 2;
        function<void(int ,int,int)> dfs = [&](int i ,int j, int k)
        {
            if(i < 0 || j < 0|| i >= grid.size() || j >= grid[0].size()||choose[i][j]||grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i  + 1, j,k);
            dfs(i , j + 1,k);
            dfs(i  -1 , j,k);
            dfs(i , j - 1,k);
        };
        for(int i = 0; i < grid.size();i++)
        {
            for(int j = 0; j < grid[0].size();j++)
            {
                if(grid[i][j] == '1') dfs(i,j,res++);
            }
        }
        return res - 2;
    }
};
```



## 广度优先搜索

### [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> wordSet(wordList.begin(),wordList.end());
        if(wordSet.find(endWord) == wordSet.end()) return 0;
        unordered_map<string,int> wordDict;
        wordDict[beginWord] = 1;
        queue<string> que;
        que.push(beginWord);
        while(!que.empty())
        {
            string now = que.front();
            que.pop();
            for(int i = 0; i < now.size();i++)
            {
                string now_stru = now;
                for(char ch = 'a'; ch <= 'z' ;ch++)
                {
                    now_stru[i] = ch;
                    if(now_stru == endWord) return wordDict[now] + 1;
                    if(ch != now[i] && wordSet.find(now_stru) != wordSet.end() && wordDict.find(now_stru) == wordDict.end())
                    {
                        wordDict[now_stru] = wordDict[now] + 1;
                        que.push(now_stru);
                    }
                }
            }
        }
        return 0;
    }
};
```



## 并查集

### [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

```cpp
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int father[1001] = {0};
        for(int i = 0; i <= 1000; i++) father[i] = i;
        function<int(int)> find = [&](int n)
        {
            return n == father[n] ? n : father[n] = find(father[n]);
        };
        function<void(int,int)> uni = [&](int a, int b)
        {
            int fa = find(a);
            int fb = find(b);
            if(fa == fb) return;
            father[fa] = fb;
        };
        for(int i = 0; i < edges.size();i++)
        {
            if(find(edges[i][0]) != find(edges[i][1]) ) uni(edges[i][0],edges[i][1]);
            else return edges[i];
        }
        return {};
    }
};
```




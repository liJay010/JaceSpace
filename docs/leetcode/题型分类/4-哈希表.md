# 4-哈希表

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

### [1207. 独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int,int> umap;
        unordered_set<int> uset;
        for(int x:arr)umap[x]++;
        for(auto x:umap) uset.insert(x.second);
        return uset.size() == umap.size();
    }
};
```

### [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

```cpp
class Solution {
public:
    char firstUniqChar(string s) {
        int pos[26];
        int cnt[26] = {0};
        for(int i = s.size() - 1; i >= 0;i--)
        {
            cnt[s[i] - 'a']++;
            pos[s[i] - 'a'] = i;
        }
        int res = INT_MAX;
        for(int i = 0;i < 26;i++)
        {
            if(cnt[i] == 1 && res > pos[i])
            {
                res = pos[i];
            }
        }
        return res == INT_MAX ? ' ': s[res];
    }
```



### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int arr[26] = {0};
        for (int i = 0; i < s.size(); ++i) {
            arr[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); ++i) {
            arr[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; ++i) {
            if (arr[i]!=0) return false;
        }
        return true;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<string,vector<string>> umap;
        for(string s:strs)
        {
            string t = s;
            sort(s.begin(),s.end());
            umap[s].push_back(t);
        }
        for(auto x:umap) res.push_back(x.second);
        return res;
    }
};
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if(p.size() > s.size()) return {};
        unordered_map<char,int> p_umap;
        for(char x:p) p_umap[x]++;
        unordered_map<char,int> s_umap;
        vector<int> res;
        for(int i = 0; i < s.size();i++)
        {
            s_umap[s[i]]++;
            if(i >= p.size()) 
            {
                s_umap[s[i - p.size()]]--;
                if(s_umap[s[i - p.size()]] == 0)s_umap.erase(s[i - p.size()]);
            }
            if(s_umap == p_umap) res.push_back(i - p.size() + 1);
        }
        return res;
    }
};
```

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> uset1(nums1.begin(),nums1.end());
        unordered_set<int> uset2(nums2.begin(),nums2.end());
        vector<int> res;
        for(int x : uset1) 
        {
            if(uset2.find(x) != uset2.end()) res.push_back(x);
        }
        return res;
    }
};
```

### [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> umap1;
        for(int x:nums1) umap1[x]++;
        vector<int> res;
        for(int x:nums2)
        {
            if(umap1[x] > 0) 
            {
                res.push_back(x);
                umap1[x]--;
            }
        }
        return res;
    }
};
```

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> num;
        while(true)
        {
            int sum = 0;
            while(n)
            {
                sum += pow(n % 10,2);
                n /= 10;
            }
            if(sum == 1)  return true;
            if(num.find(sum) == num.end())num.insert(sum);
            else return false;
            n = sum;
        }
        return true;
    }
};
```

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> umap;
        for(int i = 0; i < nums.size() ;i++)
        {
            if(umap.find(target - nums[i]) != umap.end()) return {i,umap[target - nums[i]]};
            else umap[nums[i]] = i;
        }
        return {};
    }
};
```



### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> umap1;
        unordered_map<int,int> umap2;
        for(auto x:nums1)
            for(auto y:nums2)
                umap1[x+y]++;
        for(auto x:nums3)
            for(auto y:nums4)
                umap2[x+y]++;
        int res = 0;
        for(auto x:umap1)
        {
            if(umap2.find(-x.first) != umap2.end()) res += x.second * umap2[-x.first];
        }
        return res;
    }
};
```



### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int map[26]={0};//制作map
        for (auto  i :magazine) map[i - 'a']++;//遍历i++
        for (auto  i :ransomNote) map[i - 'a']--;
        for (int i = 0; i < 26; ++i)
            if (map[i] < 0) return false;
        return true;

    }
};
```

### [205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.size() != t.size()) return false;
        unordered_map<char,char> umap;
        unordered_map<char,char> umap2;
        for(int i = 0 ; i < s.size() ;i++) 
        {
            if(umap.find(s[i]) == umap.end()) 
            {
                umap[s[i]] = t[i];
                umap2[t[i]] = s[i];
            }
            else if(umap[s[i]] != t[i]) return false;
        }
        return umap.size() == umap2.size();
    }
};
```

### [1002. 查找共用字符](https://leetcode.cn/problems/find-common-characters/)

```cpp
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        unordered_map<char,int> umap;
        for(char s = 'a' ; s <= 'z' ;s++)
        {
            int mins = INT_MAX;
            for(string ss:words)
            {
                mins = min(mins,(int)count(ss.begin(),ss.end(),s));
                if(mins == 0) break;
            }
            if(mins) umap[s] = mins;
        }
        vector<string> res;
        for(auto &x:umap)
        {
            while(x.second--) res.push_back(string(1,x.first));
        }
        return res;
    }
};
```

### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.empty()) return 0;
        set<int> sets;
        for(int x:nums) sets.insert(x);
        int pre = INT_MIN, lenth = 1, max_len = 0;
        for(int x:sets) 
        {
            if(pre + 1 == x) lenth++;
            else lenth = 1;
            max_len = max(max_len,lenth);
            pre = x;
        }
        return max_len;
    }
};
```

### [594. 最长和谐子序列](https://leetcode.cn/problems/longest-harmonious-subsequence/)

```cpp
class Solution {
public:
    int findLHS(vector<int>& nums) {
        map<int,int> mps;
        for(int x:nums) mps[x]++;
        int pre = INT_MIN , sum = 0 , res = 0;
        int pre_sum = 0;
        for(auto x:mps)
        {
            if(pre  == x.first - 1) res = max(pre_sum + x.second,res);
            pre = x.first;
            pre_sum = x.second;
        }
        return res;
    }
};
```

### [621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char,int> umap;
        unordered_map<char,int> recent_use;
        for(char x: tasks) umap[x]++;
        int cur = 0;
        while(!umap.empty())
        {
            int mins = INT_MIN;
            char res = '-';
            for(auto &x: umap)
            {
                if((recent_use.find(x.first) == recent_use.end()|| cur - recent_use[x.first] > n) && mins < x.second)
                {
                    mins = x.second;
                    res = x.first;
                }
            }
            if(mins != INT_MIN) 
            {
                recent_use[res] = cur;
                umap[res]--;
                if(umap[res] == 0) 
                {
                    umap.erase(res);
                    recent_use.erase(res);
                }
            }
            //cout << res ;
            cur++;
        }
        return cur;
    }
};
```


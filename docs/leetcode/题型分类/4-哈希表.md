# 4-哈希表

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

### [1207. 独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int,int> umap;
        unordered_set<int> uset;
        for(int x:arr)umap[x]++;
        for(auto x:umap) uset.insert(x.second);
        return uset.size() == umap.size();
    }
};
```

### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int arr[26] = {0};
        for (int i = 0; i < s.size(); ++i) {
            arr[s[i] - 'a']++;
        }
        for (int i = 0; i < t.size(); ++i) {
            arr[t[i] - 'a']--;
        }
        for (int i = 0; i < 26; ++i) {
            if (arr[i]!=0) return false;
        }
        return true;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<string,vector<string>> umap;
        for(string s:strs)
        {
            string t = s;
            sort(s.begin(),s.end());
            umap[s].push_back(t);
        }
        for(auto x:umap) res.push_back(x.second);
        return res;
    }
};
```

### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if(p.size() > s.size()) return {};
        unordered_map<char,int> p_umap;
        for(char x:p) p_umap[x]++;
        unordered_map<char,int> s_umap;
        vector<int> res;
        for(int i = 0; i < s.size();i++)
        {
            s_umap[s[i]]++;
            if(i >= p.size()) 
            {
                s_umap[s[i - p.size()]]--;
                if(s_umap[s[i - p.size()]] == 0)s_umap.erase(s[i - p.size()]);
            }
            if(s_umap == p_umap) res.push_back(i - p.size() + 1);
        }
        return res;
    }
};
```

### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> uset1(nums1.begin(),nums1.end());
        unordered_set<int> uset2(nums2.begin(),nums2.end());
        vector<int> res;
        for(int x : uset1) 
        {
            if(uset2.find(x) != uset2.end()) res.push_back(x);
        }
        return res;
    }
};
```

### [350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

```cpp
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> umap1;
        for(int x:nums1) umap1[x]++;
        vector<int> res;
        for(int x:nums2)
        {
            if(umap1[x] > 0) 
            {
                res.push_back(x);
                umap1[x]--;
            }
        }
        return res;
    }
};
```

### [202. 快乐数](https://leetcode.cn/problems/happy-number/)

```cpp
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> num;
        while(true)
        {
            int sum = 0;
            while(n)
            {
                sum += pow(n % 10,2);
                n /= 10;
            }
            if(sum == 1)  return true;
            if(num.find(sum) == num.end())num.insert(sum);
            else return false;
            n = sum;
        }
        return true;
    }
};
```

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> umap;
        for(int i = 0; i < nums.size() ;i++)
        {
            if(umap.find(target - nums[i]) != umap.end()) return {i,umap[target - nums[i]]};
            else umap[nums[i]] = i;
        }
        return {};
    }
};
```



### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> umap1;
        unordered_map<int,int> umap2;
        for(auto x:nums1)
            for(auto y:nums2)
                umap1[x+y]++;
        for(auto x:nums3)
            for(auto y:nums4)
                umap2[x+y]++;
        int res = 0;
        for(auto x:umap1)
        {
            if(umap2.find(-x.first) != umap2.end()) res += x.second * umap2[-x.first];
        }
        return res;
    }
};
```



### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int map[26]={0};//制作map
        for (auto  i :magazine) map[i - 'a']++;//遍历i++
        for (auto  i :ransomNote) map[i - 'a']--;
        for (int i = 0; i < 26; ++i)
            if (map[i] < 0) return false;
        return true;

    }
};
```


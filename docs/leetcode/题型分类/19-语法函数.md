# 语法与函数

## 函数

### 1.lower_bound()，upper_bound

**二分查找函数：**

iteration::rstart    lower_bound(iteration::start，iteration::end，key)；

lower_bound()返回值是一个迭代器,返回指向**大于等于**key的第一个值的位置

upper_bound()返回值是一个迭代器,返回指向**大于**key的第一个值的位置

找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

[2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

```cpp
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        sort(nums.begin(), nums.end());
        long long res = 0LL;
        for (auto it = nums.begin(); it != nums.end(); ++it) {
            int minNum = lower - *it;
            int maxNum = upper - *it;
            auto x = lower_bound(it + 1, nums.end(), minNum);
            auto y = upper_bound(x, nums.end(), maxNum);
            res += y - x;
        }
        return res;
    }
};
```

### 2.list::splice

list::splice实现list拼接的功能。将源list的内容部分或全部元素删除，拼插入到目的list。

函数有以下三种声明：

```cpp
void list::splice( iterator pos, list rhs );
void list::splice( iterator pos, list rhs, iterator ix ); 
void list::splice( iterator pos, list rhs, iterator first, iterator last );
```

splice()把一个或一级元素从一个 list 移到另一个中去 它有三种形式

1、从positon开始，把一个 list  rhs的全部元素搬移到另一个中去 pos开始

2、从positon开始，把一个 ix 元素搬移到 rhs 的 pos位置

3、从positon开始，把first 到 last 剪接到要操作的list对象中的pos位置

### 3.分割字符串-stringstream

```cpp
//s为原字符串
stringstream ss(s);
string item;
while(getline(ss, item, ' '))
{
    cout << item <<endl;
}
```



## 语法

### 1.priority_queue 排序写法

```cpp
class cmp
{
    public:
    bool operator()(const pair<int,int> &a ,const pair<int,int> &b)
    {
        return a.second < b.second; //这种写法是大顶堆
    }
};
//自定义类型
priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> que;
//原有类型
priority_queue<int,vector<int>,greater<int>> que; // 小顶堆
priority_queue<int,vector<int>,less<int>> que;// 大顶堆
priority_queue<int,vector<int>> que;// 大顶堆（默认）
```



### 2.map/set 排序写法

```cpp
class MyCompare 
{
public:
    bool operator()(int v1, int v2) {
        return v1 > v2;
    }
};
set<int,greater<int>> sets1; // 指定set从大到小排序
set<int,MyCompare> sets2; // 指定set从大到小排序

//注意：map是键值对，需要按照键排序，所以参数填的int
map<int,greater<int>> map1; // 指定map从大到小排序
map<int,MyCompare> map2; // 指定map从大到小排序
```





## 刷题注意牢记

**1.二分的左右最小值怎么算**

**2.回溯的去重问题以及从什么地方开始遍历**

**3.dp的背包问题的排列和组合问题**
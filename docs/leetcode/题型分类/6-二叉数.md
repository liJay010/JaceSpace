# 6-二叉数

**二叉树的种类**

**满二叉树：**如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

**完全二叉树：**在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

**二叉搜索树**：二叉搜索树是一个有序树

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

**平衡二叉搜索树**：平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

**二叉树主要有两种遍历方式：**

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

**这里前中后，其实指的就是中间节点的遍历顺序**

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

**二叉树的定义**

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 递归三部曲

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



## 1.二叉数遍历

### 1.1 递归遍历

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```cpp
class Solution {
    vector<int> res;
    void preorder(TreeNode* root)
    {
        if (!root) return;
        res.push_back(root->val); //中
        preorder(root->left); //左
        preorder(root->right);//右
    }
public:
    vector<int> preorderTraversal(TreeNode* root) {
        preorder(root);
        return res;
    }
};
```

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```cpp
class Solution {
public:
    void pri(TreeNode* root,vector<int> &node)
    {
        if (root == NULL) return; //结点为空return null
        else{
            pri(root->left,node);//左
            node.push_back(root->val);//中
            pri(root->right,node);//右
        }
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        pri(root ,res);
        return res;
    }
};



```

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```cpp
class Solution {
public:
    void pri(TreeNode* root,vector<int> &node)
    {
        if (root == NULL) return; //结点为空return null
        else{
            pri(root->left,node);//左
            pri(root->right,node);//右
            node.push_back(root->val);//中
        }
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        pri(root ,res);
        return res;
    }
};
```

### 1.2 非递归遍历

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```cpp
//前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode *temp  = st.top();
            st.pop();
            if (temp!=NULL) res.push_back(temp->val); //中
            else continue;
            st.push(temp->right); //后 右
            st.push(temp->left); //先 左
        }
        return res;
    }
};
```

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```cpp
class Solution {
public:

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        while (!st.empty() || root)
        {
            if (root)
            {
                st.push(root);
                root = root->left;
            }
            else
            {
                root = st.top();
                st.pop();
                res.push_back(root->val);
                root = root->right;
            }
        }
        return res;
    }
};
```

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```cpp
//后序遍历
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode *> st;
        st.push(root);
        while (!st.empty())
        {
            TreeNode *temp  = st.top();
            st.pop();
            if (temp!=NULL) res.push_back(temp->val); //中
            else continue;
            st.push(temp->left);//后 左
            st.push(temp->right);//先 右
        }
        reverse(res.begin(), res.end()); //反过来左中右
        return res;
    }
};
```

### [589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

```cpp
//589. N 叉树的前序遍历
class Solution {
public:
    void pre(Node* root,vector<int> &res)
    {
        if (root==NULL) return;
        else
        {
            res.push_back(root->val);
            for (int i = 0; i < (root->children).size(); ++i) {
                pre((root->children)[i],res);
            }
        }
    }
    vector<int> preorder(Node* root) {
        vector<int> res;
        pre(root,res);
        return res;
    }
};

```

### [590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)

```cpp
//590. N 叉树的后序遍历
class Solution {
public:
    void pre(Node* root,vector<int> &res)
    {
        if (root==NULL) return;
        else
        {

            for (int i = 0; i < (root->children).size(); ++i) {
                pre((root->children)[i],res);
            }
            res.push_back(root->val);
        }
    }
    vector<int> postorder(Node* root) {
        vector<int> res;
        pre(root,res);
        return res;
    }
};
```



### 1.3 层序遍历

### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```cpp
//102. 二叉树的层序遍历
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            while (size--)
            {
                TreeNode* tp = que.front();
                que.pop();
                tmp.push_back(tp->val);
                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
            }
            res.push_back(tmp);
        }

        return res;
    }
};
```

### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```cpp
//107. 二叉树的层序遍历 II
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            while (size--)
            {
                TreeNode* tp = que.front();
                que.pop();
                tmp.push_back(tp->val);
                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
            }
            res.push_back(tmp);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```cpp
//199. 二叉树的右视图
class Solution {
    //层序遍历最后一个节点加进去
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            while (size--)
            {
                TreeNode* tp = que.front();
                que.pop();
                if(size==0) res.push_back(tp->val);
                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
            }
        }
       
        return res;
    }
};
```

### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```cpp
//637. 二叉树的层平均值
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        vector<double> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            int f = size;
            vector<int> tmp;
            double s = 0;
            while (size--)
            {
                TreeNode* tp = que.front();
                que.pop();
                s+=tp->val;

                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
            }
            res.push_back(s / f);
        }

        return res;
    }
};
```

### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```cpp
//429. N 叉树的层序遍历

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            while (size--)
            {
                Node* tp = que.front();
                que.pop();
                tmp.push_back(tp->val);

                for (int i = 0; i < (tp->children).size(); ++i) {
                    que.push((tp->children)[i]);
                }

            }
            res.push_back(tmp);
        }

        return res;
    }
};
```

### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

```cpp
//515. 在每个树行中找最大值
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            int ma = INT_MIN;
            while (size--)
            {
                TreeNode* tp = que.front();
                que.pop();
                if (ma < tp->val) ma = tp->val;

                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
            }
            res.push_back(ma);
        }

        return res;
    }
};
```

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

```cpp
//116. 填充每个节点的下一个右侧节点指针
//117. 填充每个节点的下一个右侧节点指针 II (都可以用)
class Solution {
public:
    Node* connect(Node* root){
        queue<Node*> que;

        if (root!=NULL) que.push(root);
        while (!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            while (size--)
            {
                Node* tp = que.front();
                que.pop();
                tmp.push_back(tp->val);
                if(tp->left!=NULL) que.push(tp->left);
                if(tp->right!=NULL) que.push(tp->right);
                if(size == 0) tp->next = NULL;
                else
                {
                    tp->next = que.front();
                }
            }
        }
        return root;
    }
};
```

### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

```cpp
//559. N 叉树的最大深度
class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node*> que;
        if (root == NULL)return 0;
        que.push(root);
        int deep = 1;
        while (!que.empty())
        {
            int size = que.size();
            while (size--)
            {
                Node* tmp = que.front();
                que.pop();
                for (int i = 0; i < (tmp->children).size(); ++i) {
                    que.push((tmp->children)[i]);
                }
            }
            deep++;
        }
        return deep;
    }
};


//递归
class Solution {
public:
    int maxDepth(Node* root) {
        if(!root) return 0;
        int maxdeep = 0;
        for(int i = 0; i < root->children.size();i++)
        {
            maxdeep = max(maxdeep,maxDepth(root->children[i]));
        }
        return maxdeep + 1;
    }
};
```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```cpp
//递归法
class Solution {
public:
    int maxDepth(TreeNode* root){
        if (root == NULL) return 0;
        int deep = max(maxDepth(root->left),maxDepth(root->right)) + 1;
        return deep;

    }
};

//层序遍历
class Solution {
public:
    int maxDepth(TreeNode* root){

        queue<TreeNode *> que;
        vector<vector<int>> res;
        if (root != NULL) que.push(root);
        int deep = 0;
        while (!que.empty()) {
            deep++;
            int size = que.size();
            vector<int> tmp;
            while (size--) {
                TreeNode *tp = que.front();
                que.pop();
                tmp.push_back(tp->val);
                if (tp->left != NULL) que.push(tp->left);
                if (tp->right != NULL) que.push(tp->right);
            }
            res.push_back(tmp);
        }

        return deep;

    }
};
```

### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```cpp
//111.二叉树的最小深度
class Solution {
public:
    int minDepth(TreeNode* root){

        queue<TreeNode *> que;
        if (root != NULL) que.push(root);
        int deep = 0;
        while (!que.empty()) {
            deep++;
            int size = que.size();
            vector<int> tmp;
            while (size--) {
                TreeNode *tp = que.front();
                que.pop();
                tmp.push_back(tp->val);
                if(tp->left == NULL && tp->right== NULL) return deep;
                if (tp->left != NULL) que.push(tp->left);
                if (tp->right != NULL) que.push(tp->right);
            }
        }
        return deep;

    }
};

public:
    int minDepth(TreeNode* root) {
        //回溯
        if(!root) return 0;
        int res = INT_MAX;
        function<void(TreeNode* ,int)> dfs = [&](TreeNode* r,int count)
        {
            if(!r->left && !r->right) 
            {
                res = min(count + 1,res);
                return;
            }
            if(r->left) dfs(r->left,count + 1);
            if(r->right) dfs(r->right,count + 1);
        };
        dfs(root,0);
        return res;
    }
};
```

## 其余题目

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return nullptr;
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->right = left;
        root->left = right;
        return root;
    }
};
```



### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        function<bool(TreeNode*  , TreeNode* )> isSymmetric= [&](TreeNode* left , TreeNode* right)
        {
            if(left && !right || !left && right) return false;
            if(!left && !right) return true;
            if(left->val != right->val) return false;
            return isSymmetric(left->left,right->right) && isSymmetric(left->right,right->left);
        };
        if(!root) return true;
        return isSymmetric(root->left , root->right);
    }
};
```

### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p && !q || !p && q) return false;
        if(!p && !q) return true;
        if(p->val != q->val) return false;
        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
    }
};
```

### [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

```cpp
class Solution {
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p && !q || !p && q) return false;
        if(!p && !q) return true;
        if(p->val != q->val) return false;
        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
    }
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root && !subRoot || !root && subRoot) return false;
        if(!root && !subRoot) return true;
        if(isSameTree(root, subRoot)) return true;
        else return isSubtree(root->left, subRoot) ||isSubtree(root->right, subRoot);
    }
};
```

### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

```cpp
class Solution {

public:
    bool isBalanced(TreeNode* root) {
        function<pair<bool,int>(TreeNode*)> isBalanced = [&](TreeNode* root)
        {
            if(!root) return pair<bool,int>(true,0);
            pair<bool,int> left = isBalanced(root->left);
            pair<bool,int> right = isBalanced(root->right);
            if(!left.first || !right.first) return pair<bool,int>(false,max(left.second , right.second) + 1);
            if(abs(left.second - right.second) > 1) return pair<bool,int>(false,max(left.second , right.second) + 1);
            return pair<bool,int>(true,max(left.second , right.second) + 1);
        };
        return isBalanced(root).first;
    }
};
```

### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;
        int left = 0 , right = 0;
        TreeNode* l = root;
        TreeNode* r = root;
        while(l)
        {
            left++;
            l = l->left;
        }
        while(r)
        {
            right++;
            r = r->right;
        }
        
        if(left == right) return pow(2, right) - 1;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};

```

### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        function<void(TreeNode* ,string)> dfs = [&](TreeNode* root,string tmp)
        {
            if(!root) return;
            tmp = tmp + to_string(root->val);
            if(!root->left && !root->right) 
            {
                res.push_back(tmp);
                return;
            }
            dfs(root->left,tmp+"->");
            dfs(root->right,tmp+"->");
        };
        dfs(root,"");
        return res;
    }
};
```



### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        int left = sumOfLeftLeaves(root->left);
        int right = sumOfLeftLeaves(root->right);
        if(root->left && !root->left->left && !root->left->right) return root->left->val + left + right;
        else return left + right;
    }
};
```

### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode* > que;
        que.push(root);
        int res = 0;
        while(!que.empty())
        {
            int n = que.size() ,k = 0;
            while(n--)
            {
                TreeNode* top = que.front();
                if(k++ == 0) res = top->val;
                que.pop();
                if(top->left) que.push(top->left);
                if(top->right) que.push(top->right);
            }
        }
        return res;
    }
};
```

### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if (!root->left && !root->right && root->val == targetSum) return true;
        if (!root->left && !root->right && root->val != targetSum) return false;
        bool left = hasPathSum(root->left, targetSum-root->val);
        bool right = hasPathSum(root->right, targetSum-root->val);
        return left||right;
    }
};
```

### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> res;
        vector<int> tmp;
        function<void(TreeNode* , int )> dfs = [&](TreeNode* root, int targetSum)
        {
            if(!root) return;
            tmp.push_back(root->val);
            if(!root->left && !root->right && root->val == targetSum) 
            {
                res.push_back(tmp);
                tmp.pop_back();
                return;
            }
            dfs(root->left,targetSum - root->val);
            dfs(root->right,targetSum - root->val);
            tmp.pop_back();
        };
        dfs(root,targetSum);
        return res;
    }
};
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```cpp
class Solution {
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder,int preorder_start,int preorder_end,int inorder_start,int inorder_end)
    {
        if(preorder_start == preorder_end) return nullptr;
        TreeNode* root = new TreeNode(preorder[preorder_start]);
        if(preorder_end - preorder_start == 1) return root;
        int pos = inorder_start;
        while(inorder[pos] != preorder[preorder_start]) pos++;
        
        root->left = buildTree(preorder, inorder,preorder_start + 1,preorder_start + 1 + pos - inorder_start,inorder_start,pos);
        root->right = buildTree(preorder, inorder,preorder_start + 1 + pos - inorder_start,preorder_end,pos + 1,inorder_end);
        
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
         return buildTree(preorder, inorder,0,preorder.size(),0,inorder.size());
    }
};
```

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```cpp
class Solution {
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder,int inorder_start,int inorder_end,int postorder_start,int postorder_end)
    {
        if(inorder_end == inorder_start) return nullptr;
        TreeNode* root = new TreeNode(postorder[postorder_end - 1]);
        if(inorder_end - inorder_start == 1) return root;
        int pos = inorder_start;
        while(inorder[pos] != postorder[postorder_end - 1]) pos++;
        
        root->left = buildTree(inorder, postorder,inorder_start,pos,postorder_start,postorder_start + pos - inorder_start);
        root->right = buildTree(inorder, postorder,pos + 1,inorder_end,postorder_start + pos - inorder_start,postorder_end - 1);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(inorder, postorder,0,inorder.size(),0,postorder.size());
    }
};
```

### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.size() == 0) return nullptr;
        if(nums.size() == 1) return new TreeNode(nums[0]);
        int MAX = nums[0], pos = 0;
        for(int i = 0; i < nums.size();i++) 
        {
            if(nums[i] > MAX)
            {
                MAX = nums[i];
                pos = i;
            }
        }
        TreeNode* root = new TreeNode(MAX);
        vector<int> left(nums.begin(),nums.begin() + pos);
        vector<int> right(nums.begin() + pos + 1,nums.end());
        root->left = constructMaximumBinaryTree(left);
        root->right = constructMaximumBinaryTree(right);
        return root;
    }
};
```

### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1 && !root2) return nullptr;
        if(!root1) return root2;
        if(!root2) return root1;
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```

### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;
        if(root->val == val) return root;
        else if(root->val > val) return searchBST(root->left, val);
        else return searchBST(root->right, val);
    }
};
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```cpp
class Solution {
    TreeNode* pre = nullptr;
public:
    bool isValidBST(TreeNode* root) {
        if(!root) return true;
        bool left = isValidBST(root->left);
        if(pre && root->val <= pre->val) return false;
        pre = root;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
```



### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

```cpp
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        TreeNode* pre = nullptr;
        int res = INT_MAX;
        function<void(TreeNode*)> search = [&](TreeNode* root){
            if(!root) return;
            search(root->left);
            if(pre) res = min(res,root->val - pre->val);
            pre = root;
            search(root->right);
        };
        search(root);
        return res;
    }
};
```


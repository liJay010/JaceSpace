# **程序员面试金典**



### [面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/)（图）

```cpp
class Solution {
public:
    bool findWhetherExistsPath(int n, vector<vector<int>>& graph, int start, int target) {
        //先对graph进行排序
        sort(graph.begin(),graph.end(),[&](const vector<int> &a, const vector<int> &b){
            if(a[0] == b[0]) return a[1] < b[1];
            return a[0] < b[0];
        });
        vector<bool> hash(n);
        hash[start] = true;
        for(int i = 0 ; i < graph.size();++i){
            //每当一条路径的初始位置可以到达，那么这条路径的终点就可以到达
            if(hash[graph[i][0]]){
                hash[graph[i][1]] = true;
            }
        }
        return hash[target];
    }
};
```



### [面试题 04.09. 二叉搜索树序列](https://leetcode.cn/problems/bst-sequences-lcci/)（二叉树dfs+回溯）

```cpp
class Solution {
public:
    vector<vector<int>> BSTSequences(TreeNode* root) {
        //dfs + 回溯
        if(!root) return {{}};
        vector<vector<int>> res;
        vector<int>temp;
        deque<TreeNode*> que;
        que.push_back(root);
        function<void()> dfs = [&](){
            if(que.empty())
            {
                res.push_back(temp);
                return;
            }

            int n = que.size();
            while(n--)
            {
                TreeNode* front = que.front();
                que.pop_front();
                temp.push_back(front->val);
                if(front->left) que.push_back(front->left);
                if(front->right) que.push_back(front->right);

                dfs();

                if(front->left) que.pop_back();
                if(front->right) que.pop_back();
                temp.pop_back();
                que.push_back(front);
            }
        };
        dfs();
        return res;
    }
};
```


# 13-其余问题

## 1.模拟

### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        for(int i = nums.size() - 1; i >= 0; i--)
        {
            for(int j = nums.size() - 1; j > i;j--)
            {
                if(nums[j] > nums[i])
                {
                    swap(nums[j],nums[i]);
                    reverse(nums.begin() + i + 1, nums.end());
                    return;
                }
            }
        }
        reverse(nums.begin(), nums.end());
    }
};
```

### [556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)

```cpp
class Solution {
public:
    int nextGreaterElement(int n) {
        string s = to_string(n);
        for(int i = s.size() - 1;i >= 0; i--)
        {
            for(int j = s.size() - 1; j > i ;j--)
            {
                if(s[i] < s[j])
                {
                    swap(s[i],s[j]);
                    reverse(s.begin() + i + 1,s.end());
                    long r = stol(s);
                    return (r <= INT_MAX && r != (long)n) ? r : -1;
                }
            }
        }
        return -1;
    }
};
```



### [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```cpp
class Solution {
    int calc(vector<vector<int>>& grid,int i ,int j)
    {
        int c = 0;
        if (i == 0 || grid[i-1][j] == 0) c++;
        if (i == grid.size() - 1 || grid[i+1][j] == 0) c++;
        if (j == 0 || grid[i][j-1] == 0) c++;
        if (j == grid[0].size() -1 || grid[i][j+1] == 0) c++;
        return c;
    }
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int row = grid.size() , col = grid[0].size();
        int count = 0;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (grid[i][j] == 1)
                {
                    count += calc(grid,i,j);
                }
            }
        }
        return count;
    }
};
```

### [166. 分数到小数***](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

```cpp
class Solution {
    using ll = long long;
public:
    string fractionToDecimal(int numerator, int denominator) {
        ll n = numerator, d = denominator;
        string ret;
        // 计算整数部分
        // 判断负数
        if(n * d < 0) ret += "-";


        ll a = n / d;
        if(a < 0) a *= -1;
        ret += to_string(a);

        if(n < 0) n*= -1;
        if(d < 0) d*= -1;

        // 计算小数部分
        n %= d;
        if(n == 0) {
            // 无小数
            return ret;
        }
        ret += ".";
        // 连除
        // 哈希表记录是否有数组第二次出现
        unordered_map<int, int> st;
        string t;
        int index = 0;
        while(n && !st.count(n)) {
            st[n] = index++;
            n *= 10;
            t.push_back((char)(n / d + '0'));
            n %= d;
        }
        if(n != 0) {
            // 说明出现了循环，此时对循环部分 [st[n], index] 加括号
            ret += t.substr(0, st[n]) + "(" + t.substr(st[n]) + ")";
        } else {
            ret += t;
        }
        return ret;
    }
};
```



## 2.排序

### [剑指 Offer 45. 把数组排成最小的数](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```cpp
class Solution {
public:
    string minNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[&](const int &a , const int &b){
            string sa = to_string(a);
            string sb = to_string(b);
            return sa + sb < sb + sa;
        });
        string res;
        for(int x :nums) res += to_string(x);
        return res;
    }
};
```

### [LCR 034. 验证外星语词典](https://leetcode.cn/problems/lwyVBB/)

```cpp
class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        vector<string> words_sort = words;
        unordered_map<char,int> umap;
        for(int i = 0; i < order.size() ;i++) umap[order[i]] = i;
        sort(words_sort.begin(),words_sort.end(),[&](const string &s1,const string &s2){
            int left = 0 , right = 0;
            while(left < s1.size() && right < s2.size())
            {
                if(umap[s1[left]] > umap[s2[right]]) return false;
                else if(umap[s1[left]] < umap[s2[right]]) return true;
                left++;
                right++;
            }
            if(right < s2.size()) return true;
            else return false;
        });
        return words == words_sort;
    }
};
```

### [LCR 035. 最小时间差](https://leetcode.cn/problems/569nqc/)

```cpp
class Solution {
public:
    int findMinDifference(vector<string>& timePoints) {
        vector<int> res(timePoints.size());
        for(int i = 0; i < timePoints.size();i++)
        {
            res[i] = 60 * stoi(timePoints[i].substr(0,2)) + stoi(timePoints[i].substr(3,2));
        }
        sort(res.begin(),res.end());
        int mins = min(abs(res[0] - res.back()),abs(res[0] - res.back() + 24 * 60));
        for(int i = 1 ; i < res.size();i++)
        {
            mins = min(mins,res[i] - res[i - 1]);
        }
        return mins;
    }
};LCR 035. 最小时间差

```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)（快排版本）

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        //快排思想 - 最左边 第k个值
        function<int (int ,int)> quitSort = [&](int start , int end)->int{
            //if(start >= end) return ;
            int left = start , right = end , tmp = nums[start];
            while(left < right)
            {
                while(left < right && nums[right] >= tmp) right--;
                nums[left] = nums[right];
                while(left < right && nums[left] <= tmp) left++;
                nums[right] = nums[left];
            }
            nums[left] = tmp;
            //left值是 nums数组中 第 nums.size() - left大的数
            if(nums.size() - k == left) return nums[left];
            else if(nums.size() - k > left) return quitSort(left + 1 ,end);
            else return quitSort(start,left - 1);
        };
        return quitSort(0,nums.size() - 1);
    }
};
```


# 13-其余问题

## 1.模拟

### [657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/)

```cpp
class Solution {
public:
    bool judgeCircle(string moves) {
        return (count(moves.begin(), moves.end(),'U')==count(moves.begin(), moves.end(),'D') &&
                count(moves.begin(), moves.end(),'L')==count(moves.begin(), moves.end(),'R'));
    }
};
```

### [31.下一个排列](https://leetcode.cn/problems/next-permutation/)

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        for (int i = nums.size()-1; i >=0 ; --i) {
            for (int j = nums.size()-1; j >i ; --j) {
                if (nums[j] > nums[i])
                {
                    //交换
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                    reverse(nums.begin()+i+1,nums.end());
                    return;
                }

            }
        }
        reverse(nums.begin(),nums.end());
    }
};
```



## 2.前缀/积分图

### [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```cpp
class NumArray {
    vector<int> partial;
public:
    NumArray(vector<int>& nums):partial(nums) {
        //计算前缀和
        std::partial_sum(partial.begin(), partial.end(),partial.begin());
    }

    int sumRange(int left, int right) {
        if (left == 0) return partial[right];
        return partial[right] - partial[left - 1];
    }
};

```

### [304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```cpp
class NumMatrix {
    vector<vector<int>> res;
public:
    NumMatrix(vector<vector<int>>& matrix){
        res= vector<vector<int>>(matrix.size() + 1, vector<int>(matrix[0].size() + 1, 0));
        for (int i = 1; i <= matrix.size(); ++i) {
            for (int j = 1; j <= matrix[0].size(); ++j) {
                res[i][j] = matrix[i - 1][j - 1] + res[i-1][j] + res[i][j-1] - res[i-1][j-1];
            }
        }

    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return res[row2+1][col2+1] - res[row2+1][col1] -
                res[row1][col2+1] + res[row1][col1];
    }
};

```

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0, psum = 0;
        unordered_map<int,int> umap;
        umap[0] = 1;
        //记录相等前缀和的个数，若存在前缀和为psum - k说明有umap[psum - k]个连续
        for (int x:nums) {
            psum+=x;
            res += umap[psum - k];
            umap[psum]++;
        }
        return res;
    }
};
```



## 3.


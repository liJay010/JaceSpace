# 面试问题

## 项目相关

### 1.什么是跳表

   	跳表其实就是多层的有序链表，在最底层跳跃长度是1也就是普通的链表，越往上层走，跳表的下一个节点跳得越远，每一层成指数级增长。所以增删改查只需要log(N)的复杂度。

### 2.为什么要用跳表不用其他数据结构

1. **高效的搜索操作**：跳表的平均搜索时间复杂度为 O(log n)，与红黑树等平衡树相当，因此在缓存中能够快速定位到需要的数据项。
2. **简单的实现**：跳表相对于其他平衡树（如红黑树）来说，实现相对简单，不需要复杂的旋转和着色操作，因此易于理解和实现。
3. **低延迟**：跳表具有良好的局部性，由于数据项存储在链表中，且链表节点在内存中是连续存储的，因此具有较低的访问延迟。
4. **并发访问支持**：跳表的插入和删除操作不需要全局锁定数据结构，因此更容易实现并发访问，适合高并发的分布式环境。
5. **可调节性**：跳表的层数可以根据需求进行调整，通过调整层数可以平衡搜索速度和空间利用率。
6. **容易扩展**：跳表在插入和删除操作时不需要像平衡树那样进行频繁的平衡操作，因此在分布式环境下，可以更容易地进行扩展和动态调整。

​		对于哈希表，因为要进行范围查询，哈希表对范围查询需要扫描整个表。而跳表不用。

### 3.跳表和红黑树以及平衡二叉搜索树的差别以及各自的优缺点

​	**跳表（Skip List）**：

优点：

1. 搜索、插入和删除操作的平均时间复杂度为 O(log n)，与红黑树等平衡树相当。
2. 实现相对简单，不需要复杂的旋转和着色操作。
3. 支持并发操作，可以更容易地实现并发访问和修改。

缺点：

1. 需要额外的空间来存储多层索引，相比于普通链表需要更多的空间。
2. 插入和删除操作可能需要更新多个层次的索引，导致操作复杂度略高于普通链表。
3. 不适合于对内存占用有较高要求的场景。

**红黑树（Red-Black Tree）**：

优点：

1. 平均情况下的搜索、插入和删除操作的时间复杂度为 O(log n)，在绝大多数情况下表现良好。
2. 通过旋转和着色操作来保持树的平衡，具有较好的平衡性。
3. 实现相对成熟，被广泛应用于各种编程语言和数据结构库中。

缺点：

1. 实现相对复杂，需要维护节点的颜色和旋转操作，可能会增加代码的复杂度。
2. 不适合于并发环境下的高并发读写操作，可能需要额外的同步措施来保证线程安全。
3. 在极端情况下（如频繁的插入和删除），可能会出现树的失衡，导致性能下降。

**平衡二叉搜索树（Balanced Binary Search Tree）**：

优点：

1. 保持树的平衡，保证了搜索、插入和删除操作的平均时间复杂度为 O(log n)。
2. 相较于红黑树，平衡二叉搜索树的实现可能更简单，因为不需要特殊的节点着色规则。
3. 适用于单线程和多线程环境下的数据结构需求，提供较好的性能和灵活性。

缺点：

1. 部分实现可能会牺牲一些性能来保持树的平衡性，因此在某些场景下，性能可能略低于跳表或红黑树。
2. 可能需要更多的空间来存储额外的平衡信息，相比于普通二叉搜索树。
3. 需要谨慎选择实现方法，以避免不必要的复杂度和性能损失。

总体来说，选择合适的数据结构取决于具体的应用场景、性能要求和对平衡性的需求。跳表适用于内存较大且需要快速搜索的场景，红黑树适用于需要在高并发环境下保持平衡性的场景，而平衡二叉搜索树则提供了一种折中方案，适用于需要平衡性和灵活性的场景。

### 4.节点挂掉如何转移数据

每个节点保存有自己的数据和前面一个节点的数据。增删改的时候需要同时对对应节点服务器以及下一个服务器进行操作。

当A - B - C当中的A节点挂了，中心节点会通知B节点，因为B节点保存可A的备份数据，就将B节点村的A的备份数据加入到B自己的数据中，同时将B新增的数据加入到C节点保存B的备份数据中。



### 5.新增节点如何转移数据

​		在节点A - C中新增一个节点B，需要对AC中间的数据进行划分。在哈希AB之间的数据需要转移到B，此时会通知C节点将AB之间的数据传输给B，同时将A的备份数据传输给B，然后将自己的备份数据设置为AB之间的数据。



### 6.如何保证数据的一致性

​		插入删除都需要两个节点都同时修改，只有一个节点修改成功，另外一个没有修改则会进行rollback回滚。

### 7.一致性哈希用什么实现

​		使用map-红黑树实现，把服务器映射到一个int类型的变量放在map的哈希环中。

### 8.tcmalloc和其余的内存池有什么区别，为什么要用

​		**tcmalloc（Thread-Caching Malloc）的特点：**

- **速度更快：** tcmalloc在处理小对象的分配和释放时，比glibc中的malloc（ptmalloc）快很多。例如，ptmalloc在一台2.8GHz的P4机器上执行一次小对象malloc及free大约需要300纳秒，而tcmalloc同样的操作大约只需要50纳秒
- **减少锁竞争：** tcmalloc为每个线程提供了本地缓存，这样小对象的分配几乎没有锁竞争，而大对象的分配则使用了有效的自旋锁来减少锁竞争
- **内存碎片控制：** tcmalloc通过特定的策略来分配内存，有效地控制内存碎片
- **内存利用率高：** tcmalloc的内存分配策略使得内存利用率比ptmalloc更高

**为什么要使用tcmalloc：**

- **性能提升：** 对于需要频繁分配和释放内存的应用程序，tcmalloc可以显著提升性能
- **多线程优化：** 在多线程环境下，tcmalloc的设计可以减少锁的竞争，提高程序的并发性能
- **内存管理：** tcmalloc提供了更好的内存管理机制，减少内存碎片，并且提高了内存的利用率

总的来说，tcmalloc是为了解决标准malloc在多线程环境下性能和内存利用率的问题而设计的。如果你的应用程序在这些方面有需求，那么使用tcmalloc可能会带来好处

### 9.项目是用来干什么的，实际生产的作用

​      为了解决在高并发场景中的通过分布式横向扩展节点来处理更多的数据和请求，从而提高系统的容量和吞吐量。并且通过一致性哈希实现负载均衡，防止单个节点的性能瓶颈。



### 10.B/S架构和C/S架构有什么区别

B/S架构（Browser/Server，浏览器/服务器架构）和C/S架构（Client/Server，客户机/服务器架构）是两种常见的软件应用架构，它们在设计理念、用户体验、系统维护等方面有着明显的区别：

**B/S架构的特点**:

1. **客户端简化**: 用户通过浏览器访问服务器上的应用程序，无需在客户端安装额外的软件。
2. **维护成本低**: 应用程序的更新和维护只需要在服务器端进行，客户端自动获得更新。
3. **跨平台性强**: 只要设备支持浏览器，就能访问应用程序，实现跨操作系统使用。
4. **扩展性好**: 适合大规模分布式应用，易于扩展和升级。
5. **安全性**: 由于所有数据都存储在服务器上，数据安全性依赖于服务器的安全措施。

**C/S架构的特点**:

1. **客户端功能强大**: 客户端安装专门的应用程序，可以提供丰富的用户交互和处理能力。
2. **响应速度快**: 直接与服务器通信，减少了数据传输时间，提高了响应速度。
3. **适用于局域网**: 通常用于局域网环境，对网络带宽和稳定性的要求较高。
4. **维护成本高**: 每次应用程序更新都需要在每个客户端进行安装和配置。
5. **安全性**: 可以实现更细致的权限控制和数据加密，适用于对安全性要求较高的环境。

[总的来说，B/S架构更适合互联网或大规模分布式的应用，而C/S架构则更适合对性能和安全性要求较高的内部网络环境](https://zhuanlan.zhihu.com/p/71222679)

## 

## 八股

### 1.进程线程协程的区别

**进程（Process）：**

- 进程是操作系统进行资源分配和调度的基本单位，是程序执行的实例。
- 每个进程都有独立的内存空间和系统资源。
- 进程间通信需要特定的IPC机制，如管道、信号、共享内存等。
- 进程切换开销较大，但是稳定性和安全性较高。

**线程（Thread）：**

- 线程是进程中的执行流程，是CPU调度和分派的基本单位。
- 线程共享其所属进程的内存空间和资源，但拥有独立的执行栈和程序计数器。
- 线程间的通信和数据共享更为方便，上下文切换开销小于进程。
- 线程适合于多核处理器，可以实现真正的并行计算。

**协程（Coroutine）：**

- 协程是一种用户态的轻量级线程，其调度完全由用户控制。
- 协程拥有自己的**寄存器上下文和栈**，但共享线程的资源。
- 协程能够在单线程中实现多任务的并发执行，切换开销极小。
- 协程适合于I/O密集型任务，可以提高程序的并发性能。





### 2.协程切换需要保存哪些东西

- **程序计数器（PC）**：保存了下一条指令的地址。
- **栈指针（SP）**：指向当前栈顶的位置。
- **通用寄存器**：如RAX, RBX, RCX, RDX等，这些寄存器可能保存有函数的局部变量、参数和返回值。

### 3.SYN攻击的解决方案

1. **增加SYN接收队列的大小**：通过调整操作系统设置，增加服务器可以处理的半开连接数，从而减轻攻击压力。
2. **启用SYN Cookies**：当服务器收到SYN请求时，不立即分配资源，而是通过特定算法生成一个cookie发送给客户端，在收到客户端回应的ACK包含该cookie时，才建立连接。
3. **减少SYN_ACK重试次数**：减少服务器对未完成握手的连接请求的重试次数，可以减少攻击者利用未完成握手的连接占用资源的机会。
4. **部署防火墙或入侵检测系统**：使用防火墙或入侵检测系统来识别和过滤异常的SYN包。
5. **使用云服务提供商的DDoS保护**：云服务提供商通常提供DDoS攻击防护服务，可以有效缓解SYN攻击带来的影响。

### 4.服务器有time_wait原因是什么，怎么解决

- **短连接频繁建立和关闭**：每当TCP连接关闭时，主动关闭连接的一方会进入 `TIME_WAIT` 状态，以确保所有数据包都正确完成传输。如果服务器处理了大量短暂的连接，就可能积累很多处于 `TIME_WAIT` 状态的连接。
- **保证连接可靠终止**：`TIME_WAIT` 状态确保即使最后一个ACK丢失，连接也能可靠地关闭。服务器会等待足够的时间（2倍MSL，即最大报文生存时间）来确保所有旧连接的数据包都不会影响新连接。

解决 `TIME_WAIT` 状态过多的问题，可以采取以下措施：

1. **调整TCP参数**：通过修改系统参数来减少 `TIME_WAIT` 状态的持续时间或者允许快速回收和重用处于 `TIME_WAIT` 状态的端口。例如，可以设置 `tcp_tw_reuse` 和 `tcp_tw_recycle` 为 `1` 来允许重用和快速回收
2. **使用长连接**：通过设置HTTP头中的 `Connection: keep-alive`，可以使连接保持打开状态，减少连接的频繁建立和关闭。
3. **增加本地端口范围**：通过修改 `ip_local_port_range` 参数，可以增加可用的本地端口范围，从而减轻 `TIME_WAIT` 状态对端口资源的占用。
4. **优化应用程序**：确保应用程序正确管理其连接，避免不必要的连接关闭和重新建立。

### 5.IP层是怎么知道下一跳的地址的

在IP层，确定下一跳地址的过程涉及到路由表的查找。当一个IP数据包需要被转发时，路由器或主机会检查其路由表来决定数据包的下一跳地址。这里是一个简化的过程：

1. **目的IP地址匹配**：路由器取出数据包的目的IP地址，并与路由表中的条目进行匹配。
2. **最长前缀匹配**：路由器使用最长前缀匹配原则，这意味着它会选择与目的IP地址最匹配的路由条目。
3. **下一跳地址**：一旦找到匹配的路由条目，路由器就会使用该条目中指定的下一跳地址来转发数据包。
4. **ARP解析**：如果下一跳是在本地网络上，路由器可能还需要使用ARP协议来解析下一跳的物理（MAC）地址。

例如，如果路由表中有一个条目指定了目的网络`192.168.1.0/24`的下一跳地址为`10.0.0.2`，那么所有目的地址为`192.168.1.x`的数据包都会被转发到10.0.0.2

### 6.time_wait的作用是什么

`TIME_WAIT` 状态在TCP连接中有两个主要的作用：

1. **确保TCP连接可靠终止**：当TCP连接关闭时，`TIME_WAIT` 确保最后一个ACK报文能够到达对方。如果这个ACK丢失，对方会重发FIN报文，而处于 `TIME_WAIT` 状态的一方可以重新发送ACK来完成四次挥手过程
2. **防止旧连接的数据包干扰新连接**：`TIME_WAIT` 确保连接关闭后足够长的时间内不会创建具有相同四元组（源IP、目的IP、源端口、目的端口）的新连接。这样可以避免网络中延迟的数据包影响新的连接

### 7.数据库的两阶段提交

数据库的两阶段提交（Two-Phase Commit, 2PC）是一种在分布式数据库系统中确保事务在所有节点上保持一致性的协议。它分为两个阶段：

**第一阶段（准备阶段）**:

1. 协调者向所有参与者发送准备请求。
2. 参与者执行事务操作，准备数据并锁定资源。
3. 参与者向协调者报告准备结果（成功或失败）。

**第二阶段（提交或回滚阶段）**:

1. 如果所有参与者都报告成功，协调者发送提交请求。
2. 参与者提交事务，释放资源，并向协调者报告完成。
3. 如果任何参与者报告失败，协调者发送回滚请求。
4. 参与者回滚事务，释放资源，并向协调者报告完成。

这个协议确保了即使在某些节点失败的情况下，整个系统的数据也能保持一致性。[ 两阶段提交的缺点包括可能的性能影响，因为它需要所有参与者在提交前达成一致，以及在协调者失败时可能导致的事务挂起。此外，它也可能因为长时间锁定资源而导致系统资源的低效使用。](https://zhuanlan.zhihu.com/p/639459801)



## 算法以及场景题

### 1.n个弹幕中随机抽取k个弹幕，不允许存储，时间复杂度为O（n），保证每个弹幕抽到的概率为相同

蓄水池抽样（Reservoir Sampling）是一种用于从未知大小的数据流中随机抽取固定数量的样本的算法。以下是该算法的具体步骤：

1. **初始化蓄水池：** 创建一个大小为k的蓄水池（通常k是要抽取的样本数量）。
2. **填充蓄水池：** 从数据流中依次读取前k个元素，将它们依次放入蓄水池中。
3. **处理剩余元素：** 对于剩余的数据流元素（第k+1个元素及之后的元素），依次处理每个元素i。
4. **处理第i个元素：**
   - 生成一个范围在[1, i]的随机整数j。
   - 如果j小于等于k，则用第i个元素替换蓄水池中的第j个元素。

重复步骤4直到处理完所有的数据流元素。

这个算法的核心思想在于，通过在每次处理数据流中的一个新元素时，随机决定是否将其纳入样本集合，从而保证了每个元素被选中的概率相等。这种方法在不知道数据流总大小的情况下，能够以O(n)的时间复杂度和O(k)的空间复杂度完成抽样。
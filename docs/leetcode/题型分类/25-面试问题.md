# 面试问题

## 项目相关

### 1.什么是跳表

   	跳表其实就是多层的有序链表，在最底层跳跃长度是1也就是普通的链表，越往上层走，跳表的下一个节点跳得越远，每一层成指数级增长。所以增删改查只需要log(N)的复杂度。

### 2.为什么要用跳表不用其他数据结构

​		因为要进行范围查询，哈希表对范围查询需要扫描整个表。而跳表不用。

### 3.跳表和红黑树的差别以及各自的优缺点

​		**跳表：**

​			优点：**简单而直观**，插入和删除操作相对容易不需要像红黑树那样复杂的平衡调整。范围查询效率更高。

​			缺点：**占用更多空间**

​		红黑树：

​			优点：较少的空间开销

​			缺点：**相对复杂**

### 4.节点挂掉如何转移数据

每个节点保存有自己的数据和前面一个节点的数据。增删改的时候需要同时对对应节点服务器以及下一个服务器进行操作。

当A - B - C当中的A节点挂了，中心节点会通知B节点，因为B节点保存可A的备份数据，就将B节点村的A的备份数据加入到B自己的数据中，同时将B新增的数据加入到C节点保存B的备份数据中。



### 5.新增节点如何转移数据

​		在节点A - C中新增一个节点B，需要对AC中间的数据进行划分。在哈希AB之间的数据需要转移到B，此时会通知C节点将AB之间的数据传输给B，同时将A的备份数据传输给B，然后将自己的备份数据设置为AB之间的数据。



### 6.如何保证数据的一致性

​		插入删除都需要两个节点都同时修改，只有一个节点修改成功，另外一个没有修改则会进行rollback回滚。

### 7.一致性哈希用什么实现

​		使用map-红黑树实现，把服务器映射到一个int类型的变量放在map的哈希环中。

### 8.tcmalloc和其余的内存池有什么区别，为什么要用

​		**tcmalloc（Thread-Caching Malloc）的特点：**

- **速度更快：** tcmalloc在处理小对象的分配和释放时，比glibc中的malloc（ptmalloc）快很多。例如，ptmalloc在一台2.8GHz的P4机器上执行一次小对象malloc及free大约需要300纳秒，而tcmalloc同样的操作大约只需要50纳秒
- **减少锁竞争：** tcmalloc为每个线程提供了本地缓存，这样小对象的分配几乎没有锁竞争，而大对象的分配则使用了有效的自旋锁来减少锁竞争
- **内存碎片控制：** tcmalloc通过特定的策略来分配内存，有效地控制内存碎片
- **内存利用率高：** tcmalloc的内存分配策略使得内存利用率比ptmalloc更高

**为什么要使用tcmalloc：**

- **性能提升：** 对于需要频繁分配和释放内存的应用程序，tcmalloc可以显著提升性能
- **多线程优化：** 在多线程环境下，tcmalloc的设计可以减少锁的竞争，提高程序的并发性能
- **内存管理：** tcmalloc提供了更好的内存管理机制，减少内存碎片，并且提高了内存的利用率

总的来说，tcmalloc是为了解决标准malloc在多线程环境下性能和内存利用率的问题而设计的。如果你的应用程序在这些方面有需求，那么使用tcmalloc可能会带来好处

### 9.项目是用来干什么的，实际生产的作用

​      为了解决在高并发场景中的通过分布式横向扩展节点来处理更多的数据和请求，从而提高系统的容量和吞吐量。并且通过一致性哈希实现负载均衡，防止单个节点的性能瓶颈。



## 八股

### 1.进程线程协程的区别

**进程（Process）：**

- 进程是操作系统进行资源分配和调度的基本单位，是程序执行的实例。
- 每个进程都有独立的内存空间和系统资源。
- 进程间通信需要特定的IPC机制，如管道、信号、共享内存等。
- 进程切换开销较大，但是稳定性和安全性较高。

**线程（Thread）：**

- 线程是进程中的执行流程，是CPU调度和分派的基本单位。
- 线程共享其所属进程的内存空间和资源，但拥有独立的执行栈和程序计数器。
- 线程间的通信和数据共享更为方便，上下文切换开销小于进程。
- 线程适合于多核处理器，可以实现真正的并行计算。

**协程（Coroutine）：**

- 协程是一种用户态的轻量级线程，其调度完全由用户控制。
- 协程拥有自己的**寄存器上下文和栈**，但共享线程的资源。
- 协程能够在单线程中实现多任务的并发执行，切换开销极小。
- 协程适合于I/O密集型任务，可以提高程序的并发性能。





### 2.协程切换需要保存哪些东西

- **程序计数器（PC）**：保存了下一条指令的地址。
- **栈指针（SP）**：指向当前栈顶的位置。
- **通用寄存器**：如RAX, RBX, RCX, RDX等，这些寄存器可能保存有函数的局部变量、参数和返回值。

### 3.SYN攻击的解决方案

1. **增加SYN接收队列的大小**：通过调整操作系统设置，增加服务器可以处理的半开连接数，从而减轻攻击压力。
2. **启用SYN Cookies**：当服务器收到SYN请求时，不立即分配资源，而是通过特定算法生成一个cookie发送给客户端，在收到客户端回应的ACK包含该cookie时，才建立连接。
3. **减少SYN_ACK重试次数**：减少服务器对未完成握手的连接请求的重试次数，可以减少攻击者利用未完成握手的连接占用资源的机会。
4. **部署防火墙或入侵检测系统**：使用防火墙或入侵检测系统来识别和过滤异常的SYN包。
5. **使用云服务提供商的DDoS保护**：云服务提供商通常提供DDoS攻击防护服务，可以有效缓解SYN攻击带来的影响。

### 4.服务器有time_wait原因是什么，怎么解决

- **短连接频繁建立和关闭**：每当TCP连接关闭时，主动关闭连接的一方会进入 `TIME_WAIT` 状态，以确保所有数据包都正确完成传输。如果服务器处理了大量短暂的连接，就可能积累很多处于 `TIME_WAIT` 状态的连接。
- **保证连接可靠终止**：`TIME_WAIT` 状态确保即使最后一个ACK丢失，连接也能可靠地关闭。服务器会等待足够的时间（2倍MSL，即最大报文生存时间）来确保所有旧连接的数据包都不会影响新连接。

解决 `TIME_WAIT` 状态过多的问题，可以采取以下措施：

1. **调整TCP参数**：通过修改系统参数来减少 `TIME_WAIT` 状态的持续时间或者允许快速回收和重用处于 `TIME_WAIT` 状态的端口。例如，可以设置 `tcp_tw_reuse` 和 `tcp_tw_recycle` 为 `1` 来允许重用和快速回收
2. **使用长连接**：通过设置HTTP头中的 `Connection: keep-alive`，可以使连接保持打开状态，减少连接的频繁建立和关闭。
3. **增加本地端口范围**：通过修改 `ip_local_port_range` 参数，可以增加可用的本地端口范围，从而减轻 `TIME_WAIT` 状态对端口资源的占用。
4. **优化应用程序**：确保应用程序正确管理其连接，避免不必要的连接关闭和重新建立。

### 5.IP层是怎么知道下一跳的地址的

在IP层，确定下一跳地址的过程涉及到路由表的查找。当一个IP数据包需要被转发时，路由器或主机会检查其路由表来决定数据包的下一跳地址。这里是一个简化的过程：

1. **目的IP地址匹配**：路由器取出数据包的目的IP地址，并与路由表中的条目进行匹配。
2. **最长前缀匹配**：路由器使用最长前缀匹配原则，这意味着它会选择与目的IP地址最匹配的路由条目。
3. **下一跳地址**：一旦找到匹配的路由条目，路由器就会使用该条目中指定的下一跳地址来转发数据包。
4. **ARP解析**：如果下一跳是在本地网络上，路由器可能还需要使用ARP协议来解析下一跳的物理（MAC）地址。

例如，如果路由表中有一个条目指定了目的网络`192.168.1.0/24`的下一跳地址为`10.0.0.2`，那么所有目的地址为`192.168.1.x`的数据包都会被转发到10.0.0.2

### 6.time_wait的作用是什么

`TIME_WAIT` 状态在TCP连接中有两个主要的作用：

1. **确保TCP连接可靠终止**：当TCP连接关闭时，`TIME_WAIT` 确保最后一个ACK报文能够到达对方。如果这个ACK丢失，对方会重发FIN报文，而处于 `TIME_WAIT` 状态的一方可以重新发送ACK来完成四次挥手过程
2. **防止旧连接的数据包干扰新连接**：`TIME_WAIT` 确保连接关闭后足够长的时间内不会创建具有相同四元组（源IP、目的IP、源端口、目的端口）的新连接。这样可以避免网络中延迟的数据包影响新的连接
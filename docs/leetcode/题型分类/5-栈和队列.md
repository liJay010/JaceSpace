# 5-栈和队列

## 1.栈

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```cpp
class Solution {
public:
    bool isValid(string s) {
        if(s.size() % 2 == 1) return false;
        stack<char> st;
        int cur = 0;
        while(cur < s.size())
        {
            if(s[cur] == '(' || s[cur] == '['|| s[cur] == '{') st.push(s[cur]);
            else 
            {
                if(st.empty()) return false;
                int top = st.top();
                st.pop();
                if(s[cur] == ')' && top != '(') return false;
                if(s[cur] == ']' && top != '[') return false;
                if(s[cur] == '}' && top != '{') return false;
            }
            cur++;
        }
        return st.empty();
    }
};
```

### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for(auto x : s)
        {
            if(res.size() == 0 || res.back() != x) res.push_back(x);
            else res.pop_back();
        }
        return res;
    }
};
```

### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        vector<int> res;
        int cur = 0;
        while(cur < tokens.size())
        {
            if(tokens[cur] == "+" ||tokens[cur] == "-" ||tokens[cur] == "*" ||tokens[cur] == "/" )
                {
                    int top1 = res.back();
                    res.pop_back();
                    int top2 = res.back();
                    res.pop_back();
                    int r = 0;
                    if(tokens[cur] == "+") r = top2 + top1;
                    if(tokens[cur] == "-") r = top2 - top1;
                    if(tokens[cur] == "*") r = top2 * top1;
                    if(tokens[cur] == "/") r = top2 / top1;
                    res.push_back(r);
                }
            else res.push_back(stoi(tokens[cur]));
            cur++;
        }
        return res.back();
    }
};
```

### [71. 简化路径](https://leetcode.cn/problems/simplify-path/)

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> res;
        stringstream ss(path);
        string s;
        while(getline(ss,s,'/'))
        {
            if(s == ".." && res.size() > 0) res.pop_back();
            else if(s != "" && s != "." && s != "..") res.push_back(s);
        }
        string result;
        for(string x: res)
        {
            result =result +  "/" + x;
        }
        return result == "" ? "/" : result;
    }
};
```



## 2.队列

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)（单调队列）

```cpp
class Solution {
    //单调队列
    class myQue
    {
    public:
        void push(int val)
        {
            while(!que.empty() && que.back() < val) que.pop_back();
            que.push_back(val);
        }
        void pop(int val)
        {
            if(!que.empty() && que.front() == val) que.pop_front();
        }
        int front()
        {
            return que.front();
        }
 
    private:
        deque<int> que;
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        myQue que;
        for(int i = 0; i < k; i++) que.push(nums[i]);
        res.push_back(que.front());
        for(int i = k; i < nums.size() ; i++)
        {
            que.push(nums[i]);
            que.pop(nums[i-k]);
            res.push_back(que.front());
        }
        return res;
    }
};
```

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)（堆--优先级队列）

```cpp
class Solution {
    class cmp
    {
        public:
        bool operator()(const pair<int,int> &a ,const pair<int,int> &b)
        {
            return a.second > b.second;
        }
    };
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        priority_queue<pair<int,int>,vector<pair<int,int>>,cmp> que;
        unordered_map<int,int> umap;
        vector<int> res;
        for(auto x: nums)  umap[x]++;
        for(auto x: umap)
        {
            que.push(x);
            if(que.size() > k) que.pop();
        }
        while(!que.empty())
        {
            res.push_back(que.top().first);
            que.pop();
        }
        return res;
    }
};
```

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)（堆--优先级队列）

```cpp
class Solution {
    class cmp
    {
        public:
        bool operator()(ListNode* a ,ListNode* b)
        {
            return a->val > b->val;
        }
    };
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*,vector<ListNode*>,cmp> que;
        for(auto x:lists) 
            if(x) que.push(x);
        ListNode* preroot = new ListNode(0);
        ListNode* cur = preroot;
        while(!que.empty())
        {
            ListNode* top = que.top();
            que.pop();
            cur->next = top;
            cur = cur->next;
            top = top->next;
            if(top) que.push(top);
        }
        cur->next =nullptr;
        return preroot->next;
    }
};
```

### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> st;
        int maxs = 0;
        st.push(-1);
        for(int i = 0; i < s.size();i++)
        {
            if(s[i] == '(') st.push(i);
            else if(!st.empty()) st.pop();
            if(!st.empty()) maxs = max(maxs,i - st.top());
            else st.push(i);
        }
        return maxs;
    }
};
```



## 3.单调栈/队列

### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;
        vector<int> res(temperatures.size());
        for(int i = 0; i < temperatures.size();i++)
        {
            while(!st.empty() && temperatures[st.top()] < temperatures[i])
            {
                res[st.top()] = i -  st.top();
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};
```

### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> umap;
        for(int i = 0; i < nums1.size();i++) umap[nums1[i]] = i;
        vector<int> res(nums1.size(),-1);
        stack<int> st;
        for(int i = 0; i < nums2.size();i++) 
        {
            while(!st.empty() && nums2[st.top()] < nums2[i])
            {
                if(umap.find(nums2[st.top()]) != umap.end())
                {
                    res[umap[nums2[st.top()]]] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
        return res;
    }
};
```

### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> res(nums.size(),-1);
        stack<int> st;
        for(int i = 0; i < nums.size() * 2;i++) 
        {
            while(!st.empty() && nums[st.top()] < nums[i % nums.size()])
            {
                res[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return res;
    }
};
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        stack<int> st;
        int res = 0;
        for(int i = 0; i < height.size();i++)
        {
            if(!st.empty() && height[st.top()] == height[i]) st.pop();
            while(!st.empty() && height[st.top()] < height[i])
            {
                int top = st.top();
                st.pop();
                if(!st.empty())
                {
                    int w = i - st.top() - 1;
                    int h = min(height[i],height[st.top()]) - height[top];
                    res += w*h;
                }
            }
            st.push(i);
        }
        return res;
    }
};
```

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        heights.push_back(0);
        heights.insert(heights.begin(),0);
        int res = 0;
        for(int i = 0; i < heights.size();i++)
        {
            if(!st.empty() && heights[st.top()] == heights[i]) st.pop();
            while(!st.empty() && heights[st.top()] > heights[i])
            {
                int top = st.top();
                st.pop();
                if(!st.empty())
                {
                    int w = i - st.top() - 1;
                    int h = heights[top];
                    res = max(w*h , res);
                }
            }
            st.push(i);
        }
        return res;
    }
};
```


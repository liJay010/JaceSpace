# 3-链表

**链表定义：**

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

**每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题**。

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* pre_head = new ListNode(0,head);
        ListNode* cur = pre_head;
        while(cur && cur->next)
        {
            if(cur->next->val == val) cur->next = cur->next->next;
            else cur = cur->next;
        }
        return pre_head->next;
    }
};
```

### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

```cpp
class MyLinkedList {
public:

    struct LinkNode{
        int val;
        LinkNode *next;
        LinkNode(int va):val(va),next(nullptr){}
    };

    MyLinkedList() {
        phead = new LinkNode(0); //初始化虚拟头节点
        size = 0;
    }

    int get(int index) {
        if (index < 0 || index >( size -1)) return -1;
        else
        {
            LinkNode *temp = phead->next;
            while (index--)
            {
                temp = temp->next;
            }
            return temp->val;
        }
    }

    void addAtHead(int val) { //头插法
        LinkNode *p = new LinkNode(val);
        p->next = phead->next;
        phead->next = p;
        size++;
    }

    void addAtTail(int val) {//尾插法
        LinkNode *p = new LinkNode(val);
        LinkNode *temp = phead;
        while (temp->next!=NULL)
        {
            temp=temp->next;
        }
        temp->next = p;
        size++;
    }

    void addAtIndex(int index, int val) {
        LinkNode *p = new LinkNode(val);
        LinkNode *temp = phead;

        if (index < 0 || index > size ) return;
        else
        {
            while (index--)
            {
                temp = temp->next;
            }
            p->next = temp->next;
            temp->next = p;

            size++;
        }
    }

    void deleteAtIndex(int index) {
        LinkNode *temp = phead;

        if (index >= size || index < 0) {
            return;
        }
        else
        {
            while (index--)
            {
                temp = temp->next;
            }
            temp->next = temp->next->next;

            size--;
        }
    }
private:
    int size;
    LinkNode *phead;
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
//1.迭代
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while(cur)
        {
            ListNode* t = cur->next;
            cur->next = pre;
            pre = cur;
            cur = t;
        }
        return pre;
    }
};


//2.递归
class Solution {
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(!cur) return pre;
        ListNode *next = cur->next;
        cur->next = pre;
        return reverse(cur,next);
    }
public:
    ListNode* reverseList(ListNode* head) {
         return reverse(nullptr,head);
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* prehead = new ListNode(0,head);
        ListNode* cur = prehead;
        while(cur->next && cur->next->next)
        {
            ListNode* t1 = cur->next->next->next;
            ListNode* t2 = cur->next;

            cur->next = cur->next->next;
            cur->next->next = t2;
            t2->next = t1;
            cur = cur->next->next;
        }
        return prehead->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* pre = new ListNode(0,head);
        ListNode* cur = pre;
        ListNode* p = cur;
        while(n--) cur = cur->next;
        while(cur->next)
        {
            cur = cur->next;
            p = p->next;
        }
        p->next = p->next->next;
        return pre->next;
    }
};
```

### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode * A = headA;
        ListNode * B = headB;
        while(A != B)
        {
            A = A ? A->next : headB;
            B = B ? B->next : headA;
        }
        return A;
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast && fast->next && fast->next->next)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) return true;
        }
        return false;
    }
};
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

![ii](https://pic.leetcode-cn.com/970cf34694dd893c64924e1559617f64ad6b5b272a81ac3de5836cb6fb42fed7-image.png)

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        bool is_loop = false;
        while(fast && fast->next && fast->next->next)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) 
            {
                is_loop = true;
                break;
            }
        }
        if(!is_loop) return NULL;
        slow = head;
        while(slow != fast)
        {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

和上一题相似，快慢指针，第一次相遇的时候开始，让slow为0，fast为第一次相遇的地点，再次遍历，就能找到环的入口，环的入口就是重复的数。slow = nums[slow] 为移动一下，fast = nums[nums[fast]]为移动两下。

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int fast = 0,slow = 0;
        while(true)
        {
            fast = nums[nums[fast]];
            slow = nums[slow];
            if(fast == slow) break;
        }
        int start = 0;
        while(start != fast)
        {
            start = nums[start];
            fast =  nums[fast];
        }
        return start;
    }
};
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = NULL;
        //求出链表长度
        int n = 0;
        while (cur)
        {
            cur = cur->next;
            n++;
        }
        //翻转前一半的链表
        cur = head;
        int cnt = n / 2;
        while (cnt--)
        {
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        if (n % 2 == 1) cur = cur->next;
        while (cur && pre)
        {
            if (cur->val != pre->val) return false;
            cur = cur->next;
            pre = pre->next;
        }
        return true;
    }
};
```



### [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* cur = head;
        vector<ListNode*> res;
        while(cur)
        {
            res.push_back(cur);
            cur = cur->next;
        }
        int left = 0 , right = res.size() - 1;
        cur = head;
        while(left < right)
        {
            cur->next = res[left++];
            cur = cur->next;
            cur->next = res[right--];
            cur = cur->next;
        }
        if(left == right)
        {
            cur->next = res[left];
            res[left]->next = nullptr;
        }
        else cur->next = nullptr;
    }
};
```


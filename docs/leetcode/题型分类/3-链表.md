# 3-链表

**链表定义：**

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

**每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题**。

### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

**题目难度： 简单                               用时：15   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(head==NULL) return head;
        ListNode* prehead = new ListNode(0);
        prehead->next = head;
        ListNode* cur = prehead;
        while (cur->next)
        {
            //找到了
            if ( cur->next->val == val) cur->next = cur->next->next;
            else cur = cur->next; //没找到就是else
        }
        return prehead->next;
    }
};
```

### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

**题目难度： 简单                               用时：15   分钟                                                标记：      完成** 

```cpp
class MyLinkedList {
public:

    struct LinkNode{
        int val;
        LinkNode *next;
        LinkNode(int va):val(va),next(nullptr){}
    };

    MyLinkedList() {
        phead = new LinkNode(0); //初始化虚拟头节点
        size = 0;
    }

    int get(int index) {
        if (index < 0 || index >( size -1)) return -1;
        else
        {
            LinkNode *temp = phead->next;
            while (index--)
            {
                temp = temp->next;
            }
            return temp->val;
        }
    }

    void addAtHead(int val) { //头插法
        LinkNode *p = new LinkNode(val);
        p->next = phead->next;
        phead->next = p;
        size++;
    }

    void addAtTail(int val) {//尾插法
        LinkNode *p = new LinkNode(val);
        LinkNode *temp = phead;
        while (temp->next!=NULL)
        {
            temp=temp->next;
        }
        temp->next = p;
        size++;
    }

    void addAtIndex(int index, int val) {
        LinkNode *p = new LinkNode(val);
        LinkNode *temp = phead;

        if (index < 0 || index > size ) return;
        else
        {
            while (index--)
            {
                temp = temp->next;
            }
            p->next = temp->next;
            temp->next = p;

            size++;
        }
    }

    void deleteAtIndex(int index) {
        LinkNode *temp = phead;

        if (index >= size || index < 0) {
            return;
        }
        else
        {
            while (index--)
            {
                temp = temp->next;
            }
            temp->next = temp->next->next;

            size--;
        }
    }
private:
    int size;
    LinkNode *phead;
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

**题目难度： 简单                               用时：16   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        ListNode* pre = NULL;
        ListNode* cur = head;
   
        while (cur)
        {
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**题目难度： 中等                               用时：16   分钟                                                标记：      未完成** 

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

**题目难度： 中等                               用时：8   分钟                                                标记：      完成** 

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* prehead = new ListNode*(-1,head);
        ListNode* fast = prehead;
        ListNode* slow = prehead;
        while (n--) fast =fast->next;
        while (fast->next)
        {
            fast =fast->next;
            slow =slow->next;
        }
        slow->next = slow->next->next;
        return prehead->next;
    }
};

```

### [面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

**题目难度： 简单                               用时：10  分钟                                                标记：      完成** 

```cpp
//面试题 02.07. 链表相交

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA=0, lenB = 0;
        ListNode* tA = headA;
        ListNode* tB = headB;
        while (tA!=NULL)
        {
            tA=tA->next;
            lenA++;
        }
        while (tB!=NULL)
        {
            tB=tB->next;
            lenB++;
        }
        //cout << lenA << " "<<lenB<<endl;

        if (lenA >= lenB)
        {
            tA = headA;
            tB = headB;
            int ca = lenA - lenB;
            while (ca--)
            {
                tA= tA->next;
            }
        } else
        {
            tA = headA;
            tB = headB;
            int cb = lenB - lenA;

            while (cb--)
            {
                tB= tB->next;
            }
            
        }
        while (tA!=tB && tA!=NULL && tB!=NULL)
        {
            tA = tA->next;
            tB = tB->next;
        }

        if (tA==NULL) return NULL;
        else{
            return tA;
        }

    }
};

```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

**题目难度： 简单                               用时：13分钟                                                标记：      完成** 

可以使用快慢指针法，分别定义 **fast 和 slow 指针**，从头结点出发，**fast指针每次移动两个节点，slow指针每次移动一个节点**，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while ( fast && fast->next && fast->next->next)
        {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) return true;
        }
        return false;
    }
};
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

**题目难度： 简单                               用时：12分钟                                                标记：      完成** 

如果有环，如何找到这个环的入口。也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

```cpp
//142. 环形链表 II
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head ;
        ListNode* slow = head;
        if (head==NULL) return NULL;
        while (fast->next!=NULL && fast->next->next!=NULL)
        {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow)
            {
                ListNode* temp = fast;
                ListNode* temp2 = head;
                while (temp!=temp2)
                {
                    temp2=temp2->next;
                    temp=temp->next;
                }
                return temp;
            }
        }
        return NULL;

    }
};

```

### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

和上一题相似，快慢指针，第一次相遇的时候开始，让slow为0，fast为第一次相遇的地点，再次遍历，就能找到环的入口，环的入口就是重复的数。slow = nums[slow] 为移动一下，fast = nums[nums[fast]]为移动两下。

假设有这样一个样例：[1,2,3,4,5,6,7,8,9,5]。如果我们按照上面的循环下去就会得到这样一个路径：1 2 3 4 5 [6 7 8 9] [6 7 8 9] [6 7 8 9] . . .这样就有了一个环，也就是 6 7 8 9。point 会一直在环中循环的前进。

这时我们设置两个一快(fast)一慢(slow)两个指针，一个每次走两步，一个每次走一步，这样让他们一直走下去，直到他们在重复的序列中相遇
![image.png](https://pic.leetcode-cn.com/970cf34694dd893c64924e1559617f64ad6b5b272a81ac3de5836cb6fb42fed7-image.png)

- C++

```

```

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        while (true)
        {
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast) break;
        }
        slow = 0;
        while (true)
        {
            slow = nums[slow];
            fast = nums[fast];
            if (slow == fast) break;
        }
        return slow;
    }
};
```



### [234.回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = NULL;
        //求出链表长度
        int n = 0;
        while (cur)
        {
            cur = cur->next;
            n++;
        }
        //翻转前一半的链表
        cur = head;
        int cnt = n / 2;
        while (cnt--)
        {
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        if (n % 2 == 1) cur = cur->next;
        while (cur && pre)
        {
            if (cur->val != pre->val) return false;
            cur = cur->next;
            pre = pre->next;
        }
        return true;
    }
};
```

### [143.重排链表](https://leetcode.cn/problems/reorder-list/submissions/)

**题目难度： 中等                     用时：                   10分钟                      标记： 未完成**

把链表放进数组中，然后通过双指针法，一前一后，来遍历数组，构造链表。

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* cur = head;
        while (cur)
        {
            vec.push_back(cur);
            cur = cur->next;
        }

        int left = 0 , right = vec.size() - 1;
        cur = head;
        while (left < right)
        {
            cur->next = vec[left];
            cur = cur->next;
            cur->next = vec[right];
            cur = cur->next;;
            left++;
            right--;
        }
        if (left == right)
        {
            cur->next = vec[left];
            cur->next->next = NULL;
        } else cur->next = NULL;
    }
};
```



### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```CPP
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *curA = headA;
        ListNode *curB = headB;
        while (curA != curB)
        {
            curA = curA == nullptr ? headB:curA->next;
            curB = curB == nullptr ? headA:curB->next;
        }
        return curA;
    }
};
```

### [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

**题目难度： 中等                     用时：                   11分钟                      标记： 完成**

```cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* curji_pre = new ListNode(0);
        ListNode* curou_pre = new ListNode(0);
        ListNode* curji = curji_pre;
        ListNode* curou = curou_pre;
        int cnt = 0;
        while (head)
        {
            if (cnt % 2 == 0)
            {
                curou->next = head;
                curou = curou->next;
            }
            else
            {
                curji->next = head;
                curji = curji->next;
            }
            head = head->next;
            cnt++;
        }
        curji->next = nullptr;
        curou->next = curji_pre->next;
        return curou_pre->next;
    }
};
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)（归并排序）（有意义）

快速找到一个链表的中点 -- 快慢指针

**题目难度： 中等                     用时：                   11分钟                      标记： 完成**

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head) return nullptr;
        if (!head->next) return head;
        //找到中间节点
        ListNode* fast = head;
        ListNode* slow = head; //中间节点
        ListNode* pre = nullptr; //中间节点
        while (fast && fast->next)
        {
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        pre->next = nullptr;
        ListNode* left = sortList(head);
        ListNode* right = sortList(slow);
        ListNode* res = new ListNode(0);
        ListNode* presss = res;



        //两个有序链表的合并
        while (left && right)
        {
            if (left->val > right ->val)
            {
                presss->next = right;
                right = right->next;
            } else
            {
                presss->next = left;
                left = left->next;
            }
            presss = presss->next;
        }
        preroot->next = right == nullptr ? left:right;
        return res->next;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

**题目难度： 中等                     用时：                   15分钟                      标记： 完成**

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        //两个链表相加
        ListNode* pre1 = new ListNode(0,l1);
        ListNode* pre2= new ListNode(0,l2);

        int fo = 0;
        while (pre1->next && pre2->next)
        {
            int temp = (pre1->next->val + pre2->next->val + fo);
            pre1->next->val = temp % 10;
            fo = temp / 10;
            //cout << pre1->next->val << " " << fo <<endl;
            pre1 = pre1->next;
            pre2 = pre2->next;
            
        }
        if (pre2->next) pre1->next = pre2->next;
        while (pre1->next)
        {
            int temp = (pre1->next->val + fo);
            pre1->next->val = temp % 10;
            fo = temp / 10;
            pre1 = pre1->next;
        }
        if (fo) pre1->next = new ListNode(1);
        return l1;
    }
};
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

**题目难度：简单                     用时： 20 分钟                      标记： 完成**

```cpp
//方法一：链表
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* preHead = new ListNode(-1);
        ListNode* Header = preHead;
        while (list1 && list2)
        {
            if (list1->val > list2->val )
            {
                preHead->next = list2;
                list2 = list2->next;
            }
            else
            {
                preHead->next = list1;
                list1 = list1->next;
            }
            preHead = preHead->next;
        }
        if (!list1 && list2)preHead->next = list2;
        if (list1 && !list2)preHead->next = list1;
        return Header->next;
    }
};
//方法二：递归
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1)return list2;
        if(!list2)return list1;
        if (list1->val > list2->val)
        {
            list2->next = mergeTwoLists(list1,  list2->next);
            return list2;
        }
        else
        {
            list1->next = mergeTwoLists(list1->next,  list2);
            return list1;
        }
    }
};
```

### [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

**题目难度：简单                     用时： 5分钟                      标记： 完成**

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* header = head;
        while (head && head->next)
        {
            if (head->val == head->next->val)
            {
                head->next = head->next->next;
            } else{
                head = head->next;
            }
        }
        return header;
    }
};
```


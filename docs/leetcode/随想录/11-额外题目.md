# 额外题目

## 1.数组题目

### [1365.有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        //使用哈希表记录数值
        vector<int> sorted_num = nums;
        //对数值进行排序
        std::sort(sorted_num.begin(), sorted_num.end());
        //建立哈希表 -- 值对应的就是小于他的个数 (0 <= nums[i] <= 100)
        int hamap[101];
        for (int i = sorted_num.size()-1; i >=0 ; --i) {
            hamap[sorted_num[i]] = i;
        }
        //遍历列表查表
        for (int i = 0; i < nums.size(); ++i) {
            sorted_num[i] =hamap[nums[i]];
        }
        return sorted_num;
    }
};
```

### [ 941.有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if (arr.size() < 3) return false; //数组小于3
        int i = 1;
        while (i<arr.size() && arr[i] > arr[i-1]) i++;//上升序列
        if (i == arr.size() || i == 1 )return false;
        while (i<arr.size() && arr[i] < arr[i-1]) i++;
        if (i == arr.size() )return true;
        return false;
    }
};


```

### [1207.独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        std::sort(arr.begin(), arr.end());
        int uset[1001]={0};
        int count = 1;
        for (int i = 1; i < arr.size(); ++i) {
            if(arr[i] != arr[i-1])
            {
                if (uset[count]!=0) return false;
                else uset[count] =  count;
                count = 0;
            }
            count++;
        }
        //处理最后一个情况
        if (uset[count]!=0) return false;
        return true;
    }
};
```

### [ 283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```cpp
//双指针
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int fast = 0 ,slow = 0;
        for (; fast < nums.size(); ++fast) {
            if (nums[fast]!=0)
                {
                    nums[slow] = nums[fast];
                    slow++;
                }

        }
        for(;slow < nums.size();slow++) nums[slow]=0;
    }
};
```

### [ 189. 旋转数组](https://leetcode.cn/problems/rotate-array/)

```cpp
//有多余空间
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        vector<int> front(nums.end() - k ,nums.end());
        vector<int> back(nums.begin(),nums.end() - k);
        front.insert(front.end(),back.begin(),back.end());
        nums.assign(front.begin(),front.end());
    }
};
//方法二
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k =  k % nums.size();
        std::reverse(nums.begin(), nums.end());
        std::reverse(nums.begin(), nums.begin()+k);
        std::reverse(nums.begin()+k, nums.end());
    }
};
```

### [ 724.寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

```cpp
//维护左右和
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int leftsum = 0,rightsum = accumulate(nums.begin(),nums.end(),0);

        for (int i = 0; i < nums.size(); ++i) {
            rightsum-=nums[i];
            if (leftsum == rightsum) return i;
            leftsum+=nums[i];
        }
        return -1;
    }
};
```

### [922. 按奇偶排序数组II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i) {
            if (i % 2 != nums[i] % 2)
            {
                for (int j = i+1; j < nums.size(); ++j) {
                    if (i % 2 == nums[j] % 2)
                    {
                        int temp = nums[j];
                        nums[j] = nums[i];
                        nums[i] = temp;
                        break;
                    }
                }
            }
        }
        return nums;
    }
};
```

## 2.链表题目

### [234.回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> vec;
        int n = 0;
        while (head)
        {
            vec.push_back(head->val);
            head=head->next;
            n++;
        }
        for (int i = 0; i < n/2; ++i) {
            if (vec[i]!=vec[n-i-1]) return false;
        }
        return true;
    }
};
```

### [143.重排链表](https://leetcode.cn/problems/reorder-list/submissions/)

把链表放进数组中，然后通过双指针法，一前一后，来遍历数组，构造链表。

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        ListNode* res = head;
        vector<ListNode*> vec;
        while (res)
        {
            vec.push_back(res);
            res = res->next;
        }
        //交换
        int i = 0,j=vec.size()-1;
        res = head;
        while (i < j)
        {
            res->next = vec[i];
            res = res->next;
            res->next = vec[j];
            res = res->next;
            i++;
            j--;
        }
        if (i==j)
        {
            res->next=vec[i];
            res = res->next;
        }
        res->next=NULL;
        head = vec[0];
    }
};
```

## 3.哈希表

### [ 205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        char map[128] = {0};
        char mapt[128] ={0};
        int i;
        for ( i = 0; i < s.size(); ++i) {
            if (map[s[i]]==0)
            {
                map[s[i]] = t[i];
                if (mapt[t[i]]!=0) return false;
                mapt[t[i]] =s[i];
            }
            else
            {
                if (map[s[i]]!=t[i])return false;
            }
        }
        return true;
    }
};
```

### [1002. 查找常用字符](https://leetcode.cn/problems/find-common-characters/)

```cpp
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<int> map(26,0);
        vector<string> res;
        for (int i = 0; i < words[0].size(); ++i) {
            map[words[0][i] - 'a']++;
        }
        
        for (int i = 0; i < 26; ++i) {
            if (map[i]!=0)
            {
                for (int j = 1; j < words.size(); ++j) {
                    int now = std::count(words[j].begin(), words[j].end(),i+'a');
                    map[i] = min(map[i],now);
                }
            }
        }
        for (int i = 0; i < 26; ++i) {
            while (map[i]--)
            {
                string s(1,i+'a');
                res.push_back(s);
            }
        }


        return res;
    }
};
```

## 4.字符串

### [925.长按键入](https://leetcode.cn/problems/long-pressed-name/)

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        //情况一[a],[b] 只有一个字符的时候
        if (name.size()==1 && typed.size()==1&&name[0]!=typed[0])return false;

        char cur = name[0];//记录当前字符
        int count = 1;//记录当前字符个数
        int fast = 0;//记录typed指针指向
        for (int i = 1; i < name.size(); ++i) {
            if (cur!=name[i])
            {
                while (count--)
                {
                    //情况二fast指向不等于
                    if (typed[fast]!=cur) return false;
                    fast++;
                }
                while (fast<typed.size() && typed[fast] == cur) fast++;
                cur = name[i];
                count = 1;
                //情况三typed遍历完了，而name还有
                if (fast==typed.size())return false;
            } else
            {
                count++;
            }
        }
        //情况四typed后面还有与name不同的字符
        while (fast<typed.size())
        {
            if (typed[fast]!=cur) return false;
            fast++;
        }
        return true;
    }
};
```

## 5.二叉数 & 回溯 & 贪心

### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```cpp
class Solution {
public:
    void taval(TreeNode* root,vector<int> vec,long long &sum)
    {
        vec.push_back(root->val);
        //遇到叶子节点收集结果
        if (root->left == NULL && root->right ==NULL)
        {
            long long i= 1;
            int k=vec.size()-1;
            while (k>=0)
            {
                sum+=vec[k] * i;
                i*=10;
                k--;
            }
            return;
        }
        if (root->left) taval(root->left,vec,sum);
        if (root->right) taval(root->right,vec,sum);

    }
    int sumNumbers(TreeNode* root) {
        vector<int> vec;
        long long sum=0;
        taval(root,vec,sum);
        return (int)sum;
    }
};

```

### [ 1382.将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/)

```cpp
// 1.有序树转成有序数组
// 2.有序数组转平衡二叉树
class Solution {
    vector<int>res;
    void midtraval(TreeNode* root)
    {
        if (root==NULL) return;
        midtraval(root->left);
        res.push_back(root->val);
        midtraval(root->right);

    }
    TreeNode*  buildtree(int left ,int right)
    {
        if (left>right)  return NULL;
        else if(right == left)
        {
            TreeNode* r = new TreeNode(res[right]);
            return r;
        }
        //数组切分
        TreeNode* tree = new TreeNode(res[(left+right)/2]);
        tree->left = buildtree(left,(left+right)/2-1);
        tree->right =buildtree((left+right)/2+1,right);
        return tree;
    }
public:
    TreeNode* balanceBST(TreeNode* root) {
        //利用中序遍历变成有序数组，然后再构建平衡二叉数
        midtraval(root);
        TreeNode* tree = buildtree(0,res.size()-1);
        return tree;
    }
};
```

### [1221. 分割平衡字符串](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)

```cpp
class Solution {
public:
    int balancedStringSplit(string s) {
        int count = 0;
        int r = 0, l =0;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == 'R') r++;
            else l++;
            if (r==l)
            {
                count++;
                r=0;
                l=0;
            }
        }
        return count;
    }
};
```

## 6.动态规划

### [5.最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(), false));
        int maxstart,malen=0;
        for (int i = s.size()-1; i >=0 ; --i) {
            for (int j = i; j < s.size(); ++j) {
                if (s[i] == s[j] && (j - i <= 1 || dp[i+1][j-1]))
                {
                     dp[i][j] = true;
                }
                if (dp[i][j] && malen < j - i +1)
                {
                    malen = j - i +1;
                    maxstart = i;
                }

            }
        }
        return s.substr(maxstart,malen);
    }
};
```

### [ 132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

```cpp
//困难题目
class Solution {
public:
    int minCut(string s) {
        //建立dp数组，二维数组，i - j之间的字符串是否回文
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(), false));
        for (int i = s.size()-1; i >=0 ; --i) {
            for (int j = i; j < s.size(); ++j) {
                if (s[i] == s[j] && (j - i <=1 || dp[i+1][j-1])) dp[i][j] = true;
            }
        }
        vector<int> res(s.size());
        //初始化
        for (int i = 0; i < s.size(); ++i) {
            res[i] = i;
        }
        //遍历res数组
        for (int i = 1; i < s.size(); ++i) {
            if (dp[0][i])
            {
                res[i] = 0;
                continue;
            }
            for (int j = 0; j < i; ++j) {
                if (dp[j+1][i])
                {
                    res[i] = min(res[i],res[j]+1);
                }
            }
        }

        return res[s.size()-1];

    }
};
```

### [673.最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(),1);         //记录为以num[i]结束的最长子序列长度
        vector<int> count(nums.size(),1);	   //记录为以num[i]结束的最长子序列长度个数
        int maccount = 1;
        for (int i = 1; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i])
                {
                    if (dp[j] + 1 > dp[i]) //需要更新dp[i]，以及以j结束的count
                    {
                        dp[i] = dp[j] + 1;
                        count[i] = count[j];
                    }
                    else if (dp[j] + 1 == dp[i])//以j结束的最长字符串长度等于i count需要加j
                    {
                        count[i] += count[j];
                    }
                }
                maccount = max(dp[i],maccount);
            }
            
        }
        //寻找最长的长度
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (dp[i] == maccount) res+=count[i];
        }
        return res;
    }
};
```

## 其余（图论、查并集、模拟、位运算）

[841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

（深度优先搜索）

```cpp
//此题无需回溯，因为都有标记了
class Solution {
    void dfssearch(vector<vector<int>>& rooms,int num , vector<bool> &isvisited)
    {
        if (isvisited[num]) return; //此房屋已经被访问
        isvisited[num] = true;
        for (int i = 0; i < rooms[num].size(); ++i) {
            dfssearch(rooms,rooms[num][i], isvisited);
        }
    }

public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<bool> isvisited(rooms.size(), false);
        dfssearch(rooms,0, isvisited);
        for (int i = 0; i < isvisited.size(); ++i) {
            if (!isvisited[i])return false;
        }
        return true;
    }
};
```

[ 127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

（广度优先搜索）

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // 将vector转成unordered_set，提高查询速度
        unordered_set<string> wordSet(wordList.begin(),wordList.end());
        // 如果endWord没有在wordSet出现，直接返回0
        if (wordSet.find(endWord) == wordSet.end()) return 0;
        // 记录word是否访问过
        unordered_map<string,int> Map;// <word, 查询到这个word路径长度>
        // 初始化队列
        queue<string> que;
        // 初始化visitMap
        que.push(beginWord);
        Map.insert(pair(beginWord,1));

        while (!que.empty())
        {
            string word = que.front();
            que.pop();
            int path = Map[word];//记录当前长度
            for (int i = 0; i < word.size(); ++i) {
                string newword = word;
                for (int j = 0; j < 26; ++j) {
                    newword[i] = j + 'a';
                    if (newword == endWord) return path+1;
                    // wordSet出现了newWord，并且newWord没有被访问过
                    if (wordSet.find(newword)!=wordSet.end() &&
                            Map.find(newword)==Map.end())
                    {
                        Map.insert(pair(newword,path+1));
                        que.push(newword);
                    }
                }
            }
        }
        return 0;
    }
};
```

[684.冗余连接](https://leetcode.cn/problems/redundant-connection/)

题目说是**无向图**，返回一条可以删去的边，使得结果图是一个有着N个节点的树。

如果有多个答案，则返回二维数组中最后出现的边。

那么我们就可以从前向后遍历每一条边，边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。

如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，如果再加入这条边一定就出现环了。

```cpp
class Solution {
    int n = 1005; // 节点数量3 到 1000
    int father[1005];
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }

// 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
// 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
// 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        init();
        for (int i = 0; i < edges.size(); ++i) {
            if (same(edges[i][0],edges[i][1])) return edges[i];
            join(edges[i][0],edges[i][1]);
        }
        return {};
    }
};

```

[657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/)

```cpp

```

[31.下一个排列](https://leetcode.cn/problems/next-permutation/)

```cpp

```

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```cpp

```

[1356. 根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)

```cpp

```


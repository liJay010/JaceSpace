# 额外题目

## 1.数组题目

### [1365.有多少小于当前数字的数字](https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
        unordered_map<int,int>umap;
        vector<int> res(nums.begin(),nums.end());
        std::sort(nums.begin(), nums.end());
        for (int i = nums.size() -1 ; i >= 0; --i) {
            umap[nums[i]] = i;
        }
        for (int i = 0; i < res.size(); ++i) {
            res[i] = umap[res[i]];
        }
        return res;
    }
};
```

### [ 941.有效的山脉数组](https://leetcode.cn/problems/valid-mountain-array/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if (arr.size() < 3) return false;
        //从前往后
        int st = 1;
        while (st < arr.size() && arr[st] > arr[st-1])st++;
        //从后往前
        int ed = arr.size() - 2;
        while (ed >= 0 && arr[ed] > arr[ed+1])ed--;
        if (st == 1 || ed == arr.size() - 2) return false;//在原地
        if (st-1 == ed+1) return true;
        return false;
    }
};

```

### [1207.独一无二的出现次数](https://leetcode.cn/problems/unique-number-of-occurrences/)

**题目难度： 简单                     用时：                   10 分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        unordered_map<int,int> umap;
        for (int i = 0; i < arr.size(); ++i) {
            umap[arr[i]]+=1;
        }
        unordered_set<int> uset;
        for (auto x:umap) {
            if (uset.find(x.second)!=uset.end()) return false;
            uset.insert(x.second);
        }
        return true;
    }
};
```

### [ 189. 旋转数组](https://leetcode.cn/problems/rotate-array/)

**题目难度： 简单                     用时：                   5分钟                      标记： 完成**

```cpp
//有多余空间
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        vector<int> front(nums.end() - k ,nums.end());
        vector<int> back(nums.begin(),nums.end() - k);
        front.insert(front.end(),back.begin(),back.end());
        nums.assign(front.begin(),front.end());
    }
};
//方法二
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k =  k % nums.size();
        std::reverse(nums.begin(), nums.end());
        std::reverse(nums.begin(), nums.begin()+k);
        std::reverse(nums.begin()+k, nums.end());
    }
};
```

### [ 724.寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
//维护左右和
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int leftsum = 0,rightsum = accumulate(nums.begin(),nums.end(),0);
        for (int i = 0; i < nums.size(); ++i) {
            rightsum-=nums[i];
            if (leftsum == rightsum) return i;
            leftsum+=nums[i];
        }
        return -1;
    }
};
```

### [922. 按奇偶排序数组II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        //双指针
        for (int i = 0; i < nums.size(); ++i) {
            if (i % 2 != nums[i] % 2)
            {
                int r = nums.size() - 1;
                while (r >= 0 && i % 2 != nums[r] % 2) r--;
                swap(nums[i],nums[r]);
            }
        }
        return nums;
    }
};
```

## 2.链表题目

### [234.回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

**题目难度： 简单                     用时：                   10分钟                      标记： 完成**

```cpp
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = NULL;
        //求出链表长度
        int n = 0;
        while (cur)
        {
            cur = cur->next;
            n++;
        }
        //翻转前一半的链表
        cur = head;
        int cnt = n / 2;
        while (cnt--)
        {
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        if (n % 2 == 1) cur = cur->next;
        while (cur && pre)
        {
            if (cur->val != pre->val) return false;
            cur = cur->next;
            pre = pre->next;
        }
        return true;
    }
};
```

### [143.重排链表](https://leetcode.cn/problems/reorder-list/submissions/)（未）

**题目难度： 中等                     用时：                   10分钟                      标记： 未完成**

把链表放进数组中，然后通过双指针法，一前一后，来遍历数组，构造链表。

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        vector<ListNode*> vec;
        ListNode* cur = head;
        while (cur)
        {
            vec.push_back(cur);
            cur = cur->next;
        }

        int left = 0 , right = vec.size() - 1;
        cur = head;
        while (left < right)
        {
            cur->next = vec[left];
            cur = cur->next;
            cur->next = vec[right];
            cur = cur->next;;
            left++;
            right--;
        }
        if (left == right)
        {
            cur->next = vec[left];
            cur->next->next = NULL;
        } else cur->next = NULL;
    }
};
```

## 3.哈希表

### [ 205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```cpp
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        char map[128] = {0};
        char mapt[128] ={0};
        int i;
        for ( i = 0; i < s.size(); ++i) {
            if (map[s[i]]==0)
            {
                map[s[i]] = t[i];
                if (mapt[t[i]]!=0) return false;
                mapt[t[i]] =s[i];
            }
            else
            {
                if (map[s[i]]!=t[i])return false;
            }
        }
        return true;
    }
};
```

### [1002. 查找常用字符](https://leetcode.cn/problems/find-common-characters/)

```cpp
class Solution {
public:
    vector<string> commonChars(vector<string>& words) {
        vector<int> map(26,0);
        vector<string> res;
        for (int i = 0; i < words[0].size(); ++i) {
            map[words[0][i] - 'a']++;
        }
        
        for (int i = 0; i < 26; ++i) {
            if (map[i]!=0)
            {
                for (int j = 1; j < words.size(); ++j) {
                    int now = std::count(words[j].begin(), words[j].end(),i+'a');
                    map[i] = min(map[i],now);
                }
            }
        }
        for (int i = 0; i < 26; ++i) {
            while (map[i]--)
            {
                string s(1,i+'a');
                res.push_back(s);
            }
        }


        return res;
    }
};
```

## 4.字符串

### [925.长按键入](https://leetcode.cn/problems/long-pressed-name/)

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        //情况一[a],[b] 只有一个字符的时候
        if (name.size()==1 && typed.size()==1&&name[0]!=typed[0])return false;

        char cur = name[0];//记录当前字符
        int count = 1;//记录当前字符个数
        int fast = 0;//记录typed指针指向
        for (int i = 1; i < name.size(); ++i) {
            if (cur!=name[i])
            {
                while (count--)
                {
                    //情况二fast指向不等于
                    if (typed[fast]!=cur) return false;
                    fast++;
                }
                while (fast<typed.size() && typed[fast] == cur) fast++;
                cur = name[i];
                count = 1;
                //情况三typed遍历完了，而name还有
                if (fast==typed.size())return false;
            } else
            {
                count++;
            }
        }
        //情况四typed后面还有与name不同的字符
        while (fast<typed.size())
        {
            if (typed[fast]!=cur) return false;
            fast++;
        }
        return true;
    }
};
```

## 5.二叉数 & 回溯 & 贪心

### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```cpp
class Solution {
public:
    void taval(TreeNode* root,vector<int> vec,long long &sum)
    {
        vec.push_back(root->val);
        //遇到叶子节点收集结果
        if (root->left == NULL && root->right ==NULL)
        {
            long long i= 1;
            int k=vec.size()-1;
            while (k>=0)
            {
                sum+=vec[k] * i;
                i*=10;
                k--;
            }
            return;
        }
        if (root->left) taval(root->left,vec,sum);
        if (root->right) taval(root->right,vec,sum);

    }
    int sumNumbers(TreeNode* root) {
        vector<int> vec;
        long long sum=0;
        taval(root,vec,sum);
        return (int)sum;
    }
};

```

### [ 1382.将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/)

```cpp
// 1.有序树转成有序数组
// 2.有序数组转平衡二叉树
class Solution {
    vector<int>res;
    void midtraval(TreeNode* root)
    {
        if (root==NULL) return;
        midtraval(root->left);
        res.push_back(root->val);
        midtraval(root->right);

    }
    TreeNode*  buildtree(int left ,int right)
    {
        if (left>right)  return NULL;
        else if(right == left)
        {
            TreeNode* r = new TreeNode(res[right]);
            return r;
        }
        //数组切分
        TreeNode* tree = new TreeNode(res[(left+right)/2]);
        tree->left = buildtree(left,(left+right)/2-1);
        tree->right =buildtree((left+right)/2+1,right);
        return tree;
    }
public:
    TreeNode* balanceBST(TreeNode* root) {
        //利用中序遍历变成有序数组，然后再构建平衡二叉数
        midtraval(root);
        TreeNode* tree = buildtree(0,res.size()-1);
        return tree;
    }
};
```

### [1221. 分割平衡字符串](https://leetcode.cn/problems/split-a-string-in-balanced-strings/)

```cpp
class Solution {
public:
    int balancedStringSplit(string s) {
        int count = 0;
        int r = 0, l =0;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == 'R') r++;
            else l++;
            if (r==l)
            {
                count++;
                r=0;
                l=0;
            }
        }
        return count;
    }
};
```

## 6.动态规划

### [5.最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool>> dp(s.size(),vector<bool>(s.size(), false));
        int maxstart,malen=0;
        for (int i = s.size()-1; i >=0 ; --i) {
            for (int j = i; j < s.size(); ++j) {
                if (s[i] == s[j] && (j - i <= 1 || dp[i+1][j-1]))
                {
                     dp[i][j] = true;
                }
                if (dp[i][j] && malen < j - i +1)
                {
                    malen = j - i +1;
                    maxstart = i;
                }

            }
        }
        return s.substr(maxstart,malen);
    }
};
```

### [ 132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

```cpp
//困难题目
class Solution {
public:
    int minCut(string s) {
        //建立dp数组，二维数组，i - j之间的字符串是否回文
        vector<vector<bool>>dp(s.size(),vector<bool>(s.size(), false));
        for (int i = s.size()-1; i >=0 ; --i) {
            for (int j = i; j < s.size(); ++j) {
                if (s[i] == s[j] && (j - i <=1 || dp[i+1][j-1])) dp[i][j] = true;
            }
        }
        vector<int> res(s.size());
        //初始化
        for (int i = 0; i < s.size(); ++i) {
            res[i] = i;
        }
        //遍历res数组
        for (int i = 1; i < s.size(); ++i) {
            if (dp[0][i])
            {
                res[i] = 0;
                continue;
            }
            for (int j = 0; j < i; ++j) {
                if (dp[j+1][i])
                {
                    res[i] = min(res[i],res[j]+1);
                }
            }
        }

        return res[s.size()-1];

    }
};
```

### [673.最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

```cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(),1);         //记录为以num[i]结束的最长子序列长度
        vector<int> count(nums.size(),1);	   //记录为以num[i]结束的最长子序列长度个数
        int maccount = 1;
        for (int i = 1; i < nums.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[j] < nums[i])
                {
                    if (dp[j] + 1 > dp[i]) //需要更新dp[i]，以及以j结束的count
                    {
                        dp[i] = dp[j] + 1;
                        count[i] = count[j];
                    }
                    else if (dp[j] + 1 == dp[i])//以j结束的最长字符串长度等于i count需要加j
                    {
                        count[i] += count[j];
                    }
                }
                maccount = max(dp[i],maccount);
            }
            
        }
        //寻找最长的长度
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (dp[i] == maccount) res+=count[i];
        }
        return res;
    }
};
```

## 其余（图论、查并集、模拟、位运算）

[841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

（深度优先搜索）

```cpp
//此题无需回溯，因为都有标记了
class Solution {
    void dfssearch(vector<vector<int>>& rooms,int num , vector<bool> &isvisited)
    {
        if (isvisited[num]) return; //此房屋已经被访问
        isvisited[num] = true;
        for (int i = 0; i < rooms[num].size(); ++i) {
            dfssearch(rooms,rooms[num][i], isvisited);
        }
    }

public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vector<bool> isvisited(rooms.size(), false);
        dfssearch(rooms,0, isvisited);
        for (int i = 0; i < isvisited.size(); ++i) {
            if (!isvisited[i])return false;
        }
        return true;
    }
};
```

[ 127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

（广度优先搜索）

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // 将vector转成unordered_set，提高查询速度
        unordered_set<string> wordSet(wordList.begin(),wordList.end());
        // 如果endWord没有在wordSet出现，直接返回0
        if (wordSet.find(endWord) == wordSet.end()) return 0;
        // 记录word是否访问过
        unordered_map<string,int> Map;// <word, 查询到这个word路径长度>
        // 初始化队列
        queue<string> que;
        // 初始化visitMap
        que.push(beginWord);
        Map.insert(pair(beginWord,1));

        while (!que.empty())
        {
            string word = que.front();
            que.pop();
            int path = Map[word];//记录当前长度
            for (int i = 0; i < word.size(); ++i) {
                string newword = word;
                for (int j = 0; j < 26; ++j) {
                    newword[i] = j + 'a';
                    if (newword == endWord) return path+1;
                    // wordSet出现了newWord，并且newWord没有被访问过
                    if (wordSet.find(newword)!=wordSet.end() &&
                            Map.find(newword)==Map.end())
                    {
                        Map.insert(pair(newword,path+1));
                        que.push(newword);
                    }
                }
            }
        }
        return 0;
    }
};
```

[684.冗余连接](https://leetcode.cn/problems/redundant-connection/)

题目说是**无向图**，返回一条可以删去的边，使得结果图是一个有着N个节点的树。

如果有多个答案，则返回二维数组中最后出现的边。

那么我们就可以从前向后遍历每一条边，边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。

如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，如果再加入这条边一定就出现环了。

```cpp
class Solution {
    int n = 1005; // 节点数量3 到 1000
    int father[1005];
    void init() {
        for (int i = 0; i < n; ++i) {
            father[i] = i;
        }
    }

// 并查集里寻根的过程
    int find(int u) {
        return u == father[u] ? u : father[u] = find(father[u]);
    }
// 将v->u 这条边加入并查集
    void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return ;
        father[v] = u;
    }
// 判断 u 和 v是否找到同一个根
    bool same(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        init();
        for (int i = 0; i < edges.size(); ++i) {
            if (same(edges[i][0],edges[i][1])) return edges[i];
            join(edges[i][0],edges[i][1]);
        }
        return {};
    }
};

```

[657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/)

```cpp
class Solution {
public:
    bool judgeCircle(string moves) {
        return (count(moves.begin(), moves.end(),'U')==count(moves.begin(), moves.end(),'D') &&
                count(moves.begin(), moves.end(),'L')==count(moves.begin(), moves.end(),'R'));
    }
};
```

[31.下一个排列](https://leetcode.cn/problems/next-permutation/)

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        for (int i = nums.size()-1; i >=0 ; --i) {
            for (int j = nums.size()-1; j >i ; --j) {
                if (nums[j] > nums[i])
                {
                    //交换
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                    reverse(nums.begin()+i+1,nums.end());
                    return;
                }

            }
        }
        reverse(nums.begin(),nums.end());
    }
};
```

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```cpp
class Solution {
    int calc(vector<vector<int>>& grid,int i ,int j)
    {
        int c = 0;
        if (i - 1 >= 0 && grid[i-1][j] == 1) c++;
        if (i + 1 < grid.size() && grid[i+1][j] == 1) c++;
        if (j - 1 >= 0 && grid[i][j-1] == 1) c++;
        if (j + 1 < grid[0].size() && grid[i][j+1] == 1) c++;
        return 4 - c;
    }
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int row = grid.size() , col = grid[0].size();
        int count = 0;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (grid[i][j] == 1)
                {
                    count += calc(grid,i,j);
                }
            }
        }
        return count;
    }
};
```

[1356. 根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/)

这种方法，只循环n的二进制中1的个数次，比方法一高效的多

```cpp
class Solution {
public:
    static int cal_one_num(int n)
    {
        int count = 0;
        while(n)
        {
            n &= (n-1);
            count++;
        }
        return count;
    }
    static bool cmps(int a, int b)
    {
        int c = cal_one_num(a);
        int d = cal_one_num(b);
        if (c == d) return a < b;
        return c < d;
    }
    vector<int> sortByBits(vector<int>& arr) {

        std::sort(arr.begin(), arr.end(), cmps);
        return arr;
    }
};
```


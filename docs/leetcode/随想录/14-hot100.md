# Hot100

### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

```cpp
class Solution {
    vector<string> res;
    void backtracking(int n,string now,int start)
    {
        if (now.size() == n*2)
        {
            res.push_back(now);
            return;
        }
        for (int i = start; i < n * 2; ++i) {
            if (std::count(now.begin(), now.end(),'(') < n)backtracking( n,now+"(",i+1);
            if (std::count(now.begin(), now.end(),'(') > std::count(now.begin(), now.end(),')'))backtracking( n,now+")",i+1);
        }
    }
public:
    vector<string> generateParenthesis(int n) {
        backtracking(n,"",0);
        return res;
    }
};


```



### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)（巧妙方法）

```cpp
class Solution {
//    /下标计算
public:
    int longestValidParentheses(string s) {
        stack<int>stack1;
        stack1.push(-1); //定义一个栈，里面添加 -1
        int maxs = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '(') stack1.push(i); //遇到（ 则把该下标加入栈
            else
            {
                if (stack1.size() > 0) stack1.pop(); // 如果栈里面有元素 ， 直接弹出
                if (stack1.size() == 0) stack1.push(i); //如果栈里面无元素 ，则把下标加入
                else
                {
                    int top = stack1.top();
                    maxs = max(maxs,i - top);
                }

            }
        }
        return maxs;
    }
};

```

### [33. 搜索旋转排序数组（未完成）](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while (left <= right)
        {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return mid;
            if(nums[mid] == nums[left]) left++;
            else if(nums[mid] <= nums[right])
            {
                if(nums[mid] < target && target <= nums[right]) left = mid + 1;
                else right = mid - 1;
            }
            else
            {
                if(nums[mid] > target && target >= nums[left]) right = mid - 1;
                else left = mid + 1;
            }
            
        }
        return -1;
    }
};
```

### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int zero = 0, two = nums.size() - 1;
        for (int i = 0; i <= two; i++) {
            if (nums[i] == 0) swap(nums[zero++], nums[i]);
            else if (nums[i] == 2) swap(nums[two--], nums[i--]);
        }
    }
};


```


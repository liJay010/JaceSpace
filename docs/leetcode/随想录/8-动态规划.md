# 动态规划

## 动态规划步骤

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的。

#### 动态规划的解题步骤（动规五部曲）

1. 确定dp数组（dp table）以及下标的含义

2. 确定递推公式

3. dp数组如何初始化

4. 确定遍历顺序

5. 举例推导dp数组

   

# 1.基础题目

### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

**题目难度：简单             用时：          5 分钟                   标记： 完成**

```cpp
//509. 斐波那契数
//递归
class Solution {
public:
    int fib(int n) {
        int res;
        if (n == 0) return 0;
        if(n == 1 || n ==2) return 1;
        else return fib(n-1)+fib(n-2);
    }
};

//动态规划
class Solution {
public:
    int fib(int n) {
        if(n==0)return 0;
        vector<int> res;
        res.resize(n+1);
        res[0] = 0;
        res[1] = 1;
        for (int i = 2; i <= n; ++i) {
            res[i] = res[i-1] + res[i-2];
        }
        return res[n];
    }
};
```

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

**题目难度：简单             用时：          5 分钟                   标记： 完成**

```cpp
//70. 爬楼梯
class Solution {
public:

    int climbStairs(int n) {

        if (n == 0) return 0;
        if (n == 1) return 1;
        if (n == 2) return 2;
        int a[46] = {0};
        a[0]=0,a[1]=1,a[2]=2;

        for (int i = 3; i <= n; ++i) {
            a[i] = a[i-1] + a[i -2];
        }
        return a[n];

    }
};
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

**题目难度：简单             用时：          5 分钟                   标记： 完成**

```cpp
//746. 使用最小花费爬楼梯
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> res(cost.size()+1,0);
        if (cost.size() == 1) return cost[0];
        if (cost.size() == 2) return min(cost[0],cost[1]);
        for (int i = 2; i <= cost.size(); ++i) {
            res[i] =min(res[i-1] + cost[i-1],res[i-2]+ cost[i-2]);
        }
        return res[cost.size()];
    }
};
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

**题目难度：简单             用时：          5 分钟                   标记： 完成**

```cpp
//62. 不同路径
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> res(m,vector<int>(n,1));
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                res[i][j] = res[i][j-1] + res[i-1][j];
            }
        }
        return res[m-1][n-1];
    }
};
```

### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

**题目难度：简单             用时：          12 分钟                   标记： 完成**

```cpp
//63. 不同路径 II
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if (obstacleGrid.back().back() == 1) return 0;
        //改变标识
        for (int i = 0; i < obstacleGrid.size(); ++i) {
            for (int j = 0; j < obstacleGrid[0].size(); ++j) {
                if (obstacleGrid[i][j]) obstacleGrid[i][j] = -1;
            }
        }
		//第一层
        int flag = 1;
        for (int i = 0; i < obstacleGrid.size(); ++i) {
            if (obstacleGrid[i][0] == -1) flag=0;
            else obstacleGrid[i][0] = flag;
        }
        flag = 1;
        for (int i = 0; i < obstacleGrid[0].size(); ++i) {
            if (obstacleGrid[0][i] == -1) flag=0;
            else obstacleGrid[0][i] = flag;
        }


        int m = obstacleGrid.size(),n =obstacleGrid[0].size();
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                if (obstacleGrid[i][j] == -1) continue;
                else if (obstacleGrid[i-1][j] == -1 && obstacleGrid[i][j-1] == -1) obstacleGrid[i][j] = 0;
                else if (obstacleGrid[i][j-1] == -1) obstacleGrid[i][j] = obstacleGrid[i-1][j];
                else if (obstacleGrid[i-1][j] == -1) obstacleGrid[i][j] = obstacleGrid[i][j-1];
                else if (obstacleGrid[i-1][j] != -1 && obstacleGrid[i][j-1] != -1) 
                obstacleGrid[i][j] = obstacleGrid[i][j-1] + obstacleGrid[i-1][j];

            }
   

        return obstacleGrid[m-1][n-1];
    }
};
```

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

**题目难度：中等             用时：          12 分钟                   标记： 未完成**

从1遍历j，然后有两种渠道得到dp[i].

一个是j * (i - j) 直接相乘。

一个是j * dp[i - j]，相当于是拆分(i - j)

```cpp
//343. 整数拆分
class Solution {
public:
    int num[59];
    int integerBreak(int n) {
        num[2] = 1;
        for (int i = 3; i <= n; ++i) {
            for (int j = 1; j <= i /2; ++j) {
                num[i]  = max(max(num[i],j*(i-j)),j*num[i-j]);
            }
        }
        return num[n];

    }
};

```

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

**题目难度：中等             用时：          10 分钟                   标记： 完成**

```cpp
class Solution {
public:
    int numTrees(int n) {
        int dp[20]={1};
        dp[1] = 1;
        //递推公式dp[i] += dp[i-j] * dp[j]
        for (int i = 2; i <=n ; ++i) {
            for (int j = 0; j < i ; ++j) {
                dp[i] +=  dp[j] * dp[i- j - 1] ;
            }
        }
        return dp[n];
    }
};
```

# 2.背包问题

## 1.0-1背包

问题描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

在下面的讲解中，我举一个例子：

背包最大重量为**4**。

**物品为：**

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**一维dp数组（滚动数组）**

动规五部曲分析如下：

**1.确定dp数组的定义**

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

**2.一维dp数组的递推公式**

dp[j]为 容量为j的背包所背的最大价值，dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的

```cpp
dp[i-1][j]
```

，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```cpp
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

**3.一维dp数组初始化**

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

**4.一维dp数组遍历顺序**(先物品，再背包，**背包倒序**)

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15



**完整代码：**

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}

```

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

**题目难度：中等             用时：          10 分钟                   标记： 完成**

题解：分为等和子集，可以理解为把集合划分为两份。让两份和相等。那么和的二分之一为背包容量，nums为物品，物品的价值等于物品的重量，求价值最大化。就是一个01背包问题，求最大背包能不能填满，即填满后等不等于nums的二分之一。

```cpp
//416. 分割等和子集
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(),nums.end(),0);
        if (sum % 2 == 1) return false;
        else sum/=2;
        vector<int>dp(sum+1,0);

        for (int i = 0; i < nums.size(); ++i) {
            for (int j = sum; j >=nums[i]  ; --j) {
                dp[j] = max(dp[j],dp[j - nums[i]]+nums[i]);
            }
        }

        return dp.back() == sum;
    }
};

```

### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)（未）

**题目难度：中等             用时：          10 分钟                   标记： 未完成**

那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。

**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。

那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。

```cpp
//1049. 最后一块石头的重量 II
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = accumulate(stones.begin(),stones.end(),0) / 2;
        vector<int> dp(sum+1,0);
        for (int i = 0; i < stones.size(); ++i) {
            for (int j = sum; j >= stones[i]; --j) {
                dp[j] = max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return accumulate(stones.begin(),stones.end(),0)  - 2 * dp.back();
    }
};
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/)（未）

**题目难度：中等             用时：          10 分钟                   标记： 未完成**

```cpp
//494. 目标和
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        if ((accumulate(nums.begin(),nums.end(),0) - target) % 2 == 1) return 0;
        if ((accumulate(nums.begin(),nums.end(),0) - target < 0))return 0;
        int ta = (accumulate(nums.begin(),nums.end(),0) - target) / 2;

        vector<int> dp;
        dp.resize(ta+1);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = ta; j >= nums[i]; --j) {
            dp[j]+=dp[j - nums[i]];
            }
        }
        return dp[ta];
    }
};
```

### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)（未）

**题目难度：中等             用时：          24 分钟                   标记： 未完成**

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        //dp[i][j]为 i 个0 ，j个0时候，能最多的子集
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        //dp[i][j] = max(dp[i][j],dp[i - ze][j-one] + 1);
        for (int i = 0; i < strs.size(); ++i) {
            int ze = std::count(strs[i].begin(), strs[i].end(),'0');
            int one = strs[i].size() - ze;
            for (int j = m; j >=  ze; --j) {
                for (int k = n; k >= one; --k) {
                    dp[j][k] = max( dp[j][k],dp[j - ze][k-one] + 1);
                }
            }
        }
        return dp[m][n];
    }
};

```

## 2.完全背包问题

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**每件商品都有无限个！**

问背包能背的物品最大价值是多少？

首先在回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)（组合）

**题目难度：中等             用时：          8 分钟                   标记： 完成**

```cpp
//518. 零钱兑换 II
class Solution {
public:
    int change(int amount, vector<int>& coins) {

        vector<int> dp(amount+1,0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); ++i) {
            for (int j = coins[i]; j <= amount; ++j) {
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};

```

### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)（未-排列）

**题目难度：中等             用时：          6 分钟                   标记： 未完成**

```cpp
//377. 组合总和 Ⅳ
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {

        vector<int> dp(target+1,0);
        dp[0] = 1;

        for (int i = 0; i <= target ; ++i)
         {
             for (int j = 0; j < nums.size(); ++j){
                 if (i-nums[j]>=0 && dp[i] < INT_MAX - dp[i-nums[j]])
                dp[i]+=dp[i-nums[j]];
            }
        }

        return dp[target];
    }
};
```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

**题目难度：中等             用时：          6 分钟                   标记： 完成**

```cpp
//322. 零钱兑换
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); ++i) {
            for (int j = coins[i]; j <= amount ; ++j) {
                if (dp[j-coins[i]]!=INT_MAX)
                {
                    dp[j] = min(dp[j],dp[j-coins[i]]+1);
                }
            }
        }
        if(dp[amount]==INT_MAX) return -1;
        return dp[amount];
    }
};

```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

**题目难度：中等             用时：          12 分钟                   标记： 完成**

```cpp
//279. 完全平方数
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1,INT_MAX);
        dp[0] = 0;
        for (int i = 0; i <= n; ++i) {
            for (int j = 1; j*j <= i ; ++j) {
                dp[i] = min(dp[i-j*j]+1,dp[i]);
            }
        }
        return dp[n];

    }
};
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)（未）

**题目难度：中等             用时：          20 分钟                   标记： 未完成**

```cpp
//139. 单词拆分
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {

        vector<bool> dp(s.size()+1, false);
        dp[0] = true;
        for (int i = 0; i <= s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j]== true && std::find(wordDict.begin(), wordDict.end(),s.substr(j,i-j)) !=wordDict.end())
                    dp[i] = true;
            }
        }
        return dp[s.size()];
    }
};
```

## 3.总结

#### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：

- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.分割等和子集.html)
- [动态规划：1049.最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.最后一块石头的重量II.html)

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.目标和.html)
- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)
- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.组合总和Ⅳ.html)
- [动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

- [动态规划：474.一和零(opens new window)](https://programmercarl.com/0474.一和零.html)

问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.零钱兑换.html)
- [动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)

#### 遍历顺序

#### 01背包

一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

#### 完全背包

说完01背包，再看看完全背包。

先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

相关题目如下：

- 求组合数：[动态规划：518.零钱兑换II(opens new window)](https://programmercarl.com/0518.零钱兑换II.html)
- 求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)、[动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)

如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：

- 求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.零钱兑换.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.完全平方数.html)

**对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了**。

# 3.打家劫舍

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

**题目难度：中等             用时：          5 分钟                   标记： 完成**

```cpp
//状态转移方程 当前最大值取决于前一个偷不偷 dp[i]为最大值
//dp[i] = max(dp[i-1],dp[i-2] + nums[i])
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        if (nums.size() == 2) return max(nums[0],nums[1]);
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for (int i = 2; i < nums.size(); ++i) {
            dp[i] = max(dp[i-1],dp[i-2] + nums[i]);
        }
        return dp.back();
    }
};
```

### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

**题目难度：中等             用时：          5 分钟                   标记： 完成**

```cpp
//213. 打家劫舍 II
//和I 一样 去掉前后两个元素分别比较
class Solution {
public:
    int rob(vector<int>& nums)
    {
        if(nums.size() == 1)return nums[0];
        vector<int> s(nums.begin()+1,nums.end());
        vector<int> s2(nums.begin(),nums.end()-1);
        return max(getmax(s),getmax(s2));
    }
    int getmax(vector<int>& nums) {
        if(nums.size() == 1)return nums[0];
        vector<int> dp(nums.size(),0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for (int i = 2; i < nums.size() ; ++i) {
            dp[i] = max(dp[i-1],nums[i] + dp[i-2]);
        }

        return dp[nums.size()-1];
    }
};
```

### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)（未）

**题目难度：中等             用时：          15 分钟                   标记： 未完成**

动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。**这道题目算是树形dp的入门题目**（**注意用后序遍历的方式推导**）

```cpp
class Solution {
    // 树返回一个列表，分别表示偷或者不偷此节点的最大值
    vector<int> robmax(TreeNode* root)
    {
        if (root == NULL) return {0,0};
        vector<int> left = robmax(root->left);
        vector<int> right = robmax(root->right);
        //偷cur，不能偷左右
        int tou = root->val + left[1] + right[1];
        //不偷cur，取左右最大
        int bu = max(left[0],left[1])+ max(right[1],right[0]);
        return {tou,bu};
    }
public:
    int rob(TreeNode* root) {
        vector<int> res =robmax( root);
        return max(res[0], res[1]);
    }
};
```

# 4.买股票

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)（未）

**题目难度：简单             用时：          10 分钟                   标记： 未完成**

1.确定状态dp【i】【0】为第i天持有股票，包括买入。dp【i】【1】为没有股票，包括没买和卖出

2.初始化{-prices[0],0}

3.状态转移，dp【i】【0】 =  前一天持有股票 和今天买入股票的最大值。dp【i】【1】 =  前一天不买股票和今天卖出股票的最大值

4.最后一定是dp【i】【1】不持有股票的状态

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2)); // dp[i]【0】【1】 分别
        dp[0]= {-prices[0],0};
        for (int i = 1; i < prices.size(); ++i) {
            dp[i][0] = max(dp[i-1][0],-prices[i]);
            dp[i][1] = max(dp[i-1][1],prices[i] + dp[i-1][0]);
        }
        return dp[prices.size() -1][1];

    }
};
```

